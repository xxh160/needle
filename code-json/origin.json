[
    {
        "id":1,
        "description":"\n        Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\n        You may assume that each input would have exactly one solution, and you may not use the same element twice.\n        \n        You can return the answer in any order.\n        \n         \n        \n        Example 1:\n        \n        Input: nums = [2,7,11,15], target = 9\n        Output: [0,1]\n        Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n        Example 2:\n        \n        Input: nums = [3,2,4], target = 6\n        Output: [1,2]\n        Example 3:\n        \n        Input: nums = [3,3], target = 6\n        Output: [0,1]\n         \n        \n        Constraints:\n        \n        2 <= nums.length <= 10^4\n        -10^9 <= nums[i] <= 10^9\n        -10^9 <= target <= 10^9\n        Only one valid answer exists.",
        "tag":["Array","Hash Table"],
        "answer":["\n        class Solution {\n            public:\n                vector<int> twoSum(vector<int>& nums, int target) {\n                    int n = nums.size();\n                    for (int i = 0; i < n; ++i) {\n                        for (int j = i + 1; j < n; ++j) {\n                            if (nums[i] + nums[j] == target) {\n                                return {i, j};\n                            }\n                        }\n                    }\n                    return {};\n                }\n            };","\n        class Solution {\n            public:\n                vector<int> twoSum(vector<int>& nums, int target) {\n                    unordered_map<int, int> hashtable;\n                    for (int i = 0; i < nums.size(); ++i) {\n                        auto it = hashtable.find(target - nums[i]);\n                        if (it != hashtable.end()) {\n                            return {it->second, i};\n                        }\n                        hashtable[nums[i]] = i;\n                    }\n                    return {};\n                }\n            };","\n        class Solution {\n            public:\n                vector<int> twoSum(vector<int>& nums, int target) {\n                    map<int,int> a;\n                    vector<int> b(2,-1);\n                    for(int i=0;i<nums.size();i++)\n                        a.insert(map<int,int>::value_type(nums[i],i));\n                    for(int i=0;i<nums.size();i++)\n                    {\n                        if(a.count(target-nums[i])>0&&(a[target-nums[i]]!=i))\n                        {\n                            b[0]=i;\n                            b[1]=a[target-nums[i]];\n                            break;\n                        }\n                    }\n                    return b;\n                };\n            };","\n        class Solution {\n                public:\n                    vector<int> twoSum(vector<int>& nums, int target) {\n                        map<int,int> a;\n                        vector<int> b(2,-1);\n                        for(int i=0;i<nums.size();i++)\n                        {\n                            if(a.count(target-nums[i])>0)\n                            {\n                                b[0]=a[target-nums[i]];\n                                b[1]=i;\n                                break;\n                            }\n                            a[nums[i]]=i;\n                        }\n                        return b;\n                    };\n                };"]
    },
    {
        "id":2,
        "description":"\n        Given a string s, find the length of the longest \nsubstring\n without repeating characters.\n\n \n\nExample 1:\n\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\nExample 2:\n\nInput: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\nExample 3:\n\nInput: s = \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n \n\nConstraints:\n\n0 <= s.length <= 5 * 10^4\ns consists of English letters, digits, symbols and spaces.",
        "tag":["Hash Table","String","Sliding Window"],
        "answer":["\n        class Solution {\n            public:\n                int lengthOfLongestSubstring(string s) {\n                    unordered_set<char> occ;\n                    int n = s.size();\n                    int rk = -1, ans = 0;\n                    for (int i = 0; i < n; ++i) {\n                        if (i != 0) {\n                            occ.erase(s[i - 1]);\n                        }\n                        while (rk + 1 < n && !occ.count(s[rk + 1])) {\n                            occ.insert(s[rk + 1]);\n                            ++rk;\n                        }\n                        ans = max(ans, rk - i + 1);\n                    }\n                    return ans;\n                }\n            };\n        ","\n        int lengthOfLongestSubstring(string s) {\n            vector<int> m(128, 0);\n            int ans = 0;\n            int i = 0;\n            for (int j = 0; j < s.size(); j++) {\n                i = max(i, m[s[j]]);\n                m[s[j]] = j + 1;\n                ans = max(ans, j - i + 1);\n            }\n            return ans;\n        }\n        ","\n        class Solution\n{\npublic:\n    int lengthOfLongestSubstring(string s)\n    {\n        //s[start,end) 前面包含 后面不包含\n        int start(0), end(0), length(0), result(0);\n        int sSize = int(s.size());\n        while (end < sSize)\n        {\n            char tmpChar = s[end];\n            for (int index = start; index < end; index++)\n            {\n                if (tmpChar == s[index])\n                {\n                    start = index + 1;\n                    length = end - start;\n                    break;\n                }\n            }\n\n            end++;\n            length++;\n            result = max(result, length);\n        }\n        return result;\n    }\n};\n        ","\n        class Solution\n{\npublic:\n    int lengthOfLongestSubstring(string s)\n    {\n        //s[start,end) 前面包含 后面不包含\n        int start(0), end(0), length(0), result(0);\n        int sSize = int(s.size());\n        unordered_map<char, int> hash;\n        while (end < sSize)\n        {\n            char tmpChar = s[end];\n            //仅当s[start,end) 中存在s[end]时更新start\n            if (hash.find(tmpChar) != hash.end() && hash[tmpChar] >= start)\n            {\n                start = hash[tmpChar] + 1;\n                length = end - start;\n            }\n            hash[tmpChar] = end;\n\n            end++;\n            length++;\n            result = max(result, length);\n        }\n        return result;\n    }\n};\n        ","\n        class Solution\n{\npublic:\n    int lengthOfLongestSubstring(string s)\n    {\n        //s[start,end) 前面包含 后面不包含\n        int start(0), end(0), length(0), result(0);\n        int sSize = int(s.size());\n        vector<int> vec(128, -1);\n        while (end < sSize)\n        {\n            char tmpChar = s[end];\n            //仅当s[start,end) 中存在s[end]时更新start\n            if (vec[int(tmpChar)] >= start)\n            {\n                start = vec[int(tmpChar)] + 1;\n                length = end - start;\n            }\n            vec[int(tmpChar)] = end;\n\n            end++;\n            length++;\n            result = max(result, length);\n        }\n        return result;\n    }\n};\n        "]
    },
    {
        "id":3,
        "description":"\n        Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n\nThe overall run time complexity should be O(log (m+n)).\n\n \n\nExample 1:\n\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\nExample 2:\n\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n \n\nConstraints:\n\nnums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-10^6 <= nums1[i], nums2[i] <= 10^6\n        ",
        "tag":["Array","Binary Search","Divide and Conquer"],
        "answer":["\n        class Solution {\n            public:\n                int getKthElement(const vector<int>& nums1, const vector<int>& nums2, int k) {\n                    int m = nums1.size();\n                    int n = nums2.size();\n                    int index1 = 0, index2 = 0;\n            \n                    while (true) {\n                        if (index1 == m) {\n                            return nums2[index2 + k - 1];\n                        }\n                        if (index2 == n) {\n                            return nums1[index1 + k - 1];\n                        }\n                        if (k == 1) {\n                            return min(nums1[index1], nums2[index2]);\n                        }\n            \n                        int newIndex1 = min(index1 + k / 2 - 1, m - 1);\n                        int newIndex2 = min(index2 + k / 2 - 1, n - 1);\n                        int pivot1 = nums1[newIndex1];\n                        int pivot2 = nums2[newIndex2];\n                        if (pivot1 <= pivot2) {\n                            k -= newIndex1 - index1 + 1;\n                            index1 = newIndex1 + 1;\n                        }\n                        else {\n                            k -= newIndex2 - index2 + 1;\n                            index2 = newIndex2 + 1;\n                        }\n                    }\n                }\n            \n                double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n                    int totalLength = nums1.size() + nums2.size();\n                    if (totalLength % 2 == 1) {\n                        return getKthElement(nums1, nums2, (totalLength + 1) / 2);\n                    }\n                    else {\n                        return (getKthElement(nums1, nums2, totalLength / 2) + getKthElement(nums1, nums2, totalLength / 2 + 1)) / 2.0;\n                    }\n                }\n            };\n        ","\n        class Solution {\n            public:\n                double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n                    if (nums1.size() > nums2.size()) {\n                        return findMedianSortedArrays(nums2, nums1);\n                    }\n                    \n                    int m = nums1.size();\n                    int n = nums2.size();\n                    int left = 0, right = m;\n                    int median1 = 0, median2 = 0;\n            \n                    while (left <= right) {\n                        int i = (left + right) / 2;\n                        int j = (m + n + 1) / 2 - i;\n            \n                        int nums_im1 = (i == 0 ? INT_MIN : nums1[i - 1]);\n                        int nums_i = (i == m ? INT_MAX : nums1[i]);\n                        int nums_jm1 = (j == 0 ? INT_MIN : nums2[j - 1]);\n                        int nums_j = (j == n ? INT_MAX : nums2[j]);\n            \n                        if (nums_im1 <= nums_j) {\n                            median1 = max(nums_im1, nums_jm1);\n                            median2 = min(nums_i, nums_j);\n                            left = i + 1;\n                        } else {\n                            right = i - 1;\n                        }\n                    }\n            \n                    return (m + n) % 2 == 0 ? (median1 + median2) / 2.0 : median1;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n                    int len = nums1.size() + nums2.size();\n                    const int k = len / 2; \n                    int i = 0, j = 0;\n                    double res1 = 0, res2 = 0;\n                    nums1.push_back(INT_MAX);\n                    nums2.push_back(INT_MAX);\n                    while (i + j <= k) {\n                        res1 = res2;\n                        res2 = nums1[i] <= nums2[j] ? nums1[i++] : nums2[j++];\n                    }\n                    return len % 2 == 1 ? res2 : (res1 + res2) / 2;\n                }\n            };\n        "]
    },
    {
        "id":4,
        "description":"\n        Given a string s, return the longest \npalindromic\n \nsubstring\n in s.\n\n \n\nExample 1:\n\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\nExample 2:\n\nInput: s = \"cbbd\"\nOutput: \"bb\"\n \n\nConstraints:\n\n1 <= s.length <= 1000\ns consist of only digits and English letters.\n        ",
        "tag":["String","Dynamic Programming"],
        "answer":["\n        #include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string longestPalindrome(string s) {\n        int n = s.size();\n        if (n < 2) {\n            return s;\n        }\n\n        int maxLen = 1;\n        int begin = 0;\n        vector<vector<int>> dp(n, vector<int>(n));\n        for (int i = 0; i < n; i++) {\n            dp[i][i] = true;\n        }\n        for (int L = 2; L <= n; L++) {\n            for (int i = 0; i < n; i++) {\n                int j = L + i - 1;\n                if (j >= n) {\n                    break;\n                }\n\n                if (s[i] != s[j]) {\n                    dp[i][j] = false;\n                } else {\n                    if (j - i < 3) {\n                        dp[i][j] = true;\n                    } else {\n                        dp[i][j] = dp[i + 1][j - 1];\n                    }\n                }\n\n                if (dp[i][j] && j - i + 1 > maxLen) {\n                    maxLen = j - i + 1;\n                    begin = i;\n                }\n            }\n        }\n        return s.substr(begin, maxLen);\n    }\n};\n        ","\n        class Solution {\n            public:\n                pair<int, int> expandAroundCenter(const string& s, int left, int right) {\n                    while (left >= 0 && right < s.size() && s[left] == s[right]) {\n                        --left;\n                        ++right;\n                    }\n                    return {left + 1, right - 1};\n                }\n            \n                string longestPalindrome(string s) {\n                    int start = 0, end = 0;\n                    for (int i = 0; i < s.size(); ++i) {\n                        auto [left1, right1] = expandAroundCenter(s, i, i);\n                        auto [left2, right2] = expandAroundCenter(s, i, i + 1);\n                        if (right1 - left1 > end - start) {\n                            start = left1;\n                            end = right1;\n                        }\n                        if (right2 - left2 > end - start) {\n                            start = left2;\n                            end = right2;\n                        }\n                    }\n                    return s.substr(start, end - start + 1);\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int expand(const string& s, int left, int right) {\n                    while (left >= 0 && right < s.size() && s[left] == s[right]) {\n                        --left;\n                        ++right;\n                    }\n                    return (right - left - 2) / 2;\n                }\n            \n                string longestPalindrome(string s) {\n                    int start = 0, end = -1;\n                    string t = \"#\";\n                    for (char c: s) {\n                        t += c;\n                        t += '#';\n                    }\n                    t += '#';\n                    s = t;\n            \n                    vector<int> arm_len;\n                    int right = -1, j = -1;\n                    for (int i = 0; i < s.size(); ++i) {\n                        int cur_arm_len;\n                        if (right >= i) {\n                            int i_sym = j * 2 - i;\n                            int min_arm_len = min(arm_len[i_sym], right - i);\n                            cur_arm_len = expand(s, i - min_arm_len, i + min_arm_len);\n                        } else {\n                            cur_arm_len = expand(s, i, i);\n                        }\n                        arm_len.push_back(cur_arm_len);\n                        if (i + cur_arm_len > right) {\n                            j = i;\n                            right = i + cur_arm_len;\n                        }\n                        if (cur_arm_len * 2 + 1 > end - start) {\n                            start = i - cur_arm_len;\n                            end = i + cur_arm_len;\n                        }\n                    }\n            \n                    string ans;\n                    for (int i = start; i <= end; ++i) {\n                        if (s[i] != '#') {\n                            ans += s[i];\n                        }\n                    }\n                    return ans;\n                }\n            };\n        "]
    },
    {
        "id":11,
        "description":"\n        Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\nFor example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\nI can be placed before V (5) and X (10) to make 4 and 9. \nX can be placed before L (50) and C (100) to make 40 and 90. \nC can be placed before D (500) and M (1000) to make 400 and 900.\nGiven a roman numeral, convert it to an integer.\n\n \n\nExample 1:\n\nInput: s = \"III\"\nOutput: 3\nExplanation: III = 3.\nExample 2:\n\nInput: s = \"LVIII\"\nOutput: 58\nExplanation: L = 50, V= 5, III = 3.\nExample 3:\n\nInput: s = \"MCMXCIV\"\nOutput: 1994\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n \n\nConstraints:\n\n1 <= s.length <= 15\ns contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').\nIt is guaranteed that s is a valid roman numeral in the range [1, 3999].\n        ",
        "tag":["Hash Table","Math","String"],
        "answer":["\n        class Solution {\n            private:\n                unordered_map<char, int> symbolValues = {\n                    {'I', 1},\n                    {'V', 5},\n                    {'X', 10},\n                    {'L', 50},\n                    {'C', 100},\n                    {'D', 500},\n                    {'M', 1000},\n                };\n            \n            public:\n                int romanToInt(string s) {\n                    int ans = 0;\n                    int n = s.length();\n                    for (int i = 0; i < n; ++i) {\n                        int value = symbolValues[s[i]];\n                        if (i < n - 1 && value < symbolValues[s[i + 1]]) {\n                            ans -= value;\n                        } else {\n                            ans += value;\n                        }\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int romanToInt(string s) {\n                    int result=0;\n                    map<char,int> luomab={\n                        {'I',1},\n                        {'V',5},\n                        {'X',10},\n                        {'L',50},\n                        {'C',100},\n                        {'D', 500},\n                        {'M', 1000}\n                    };//初始化哈希表\n                    for(int i=0;i<s.length();i++)\n                    {\n                        if(luomab[s[i]] < luomab[s[i+1]])\n                            result -= luomab[s[i]];\n                        else\n                        {\n                            result += luomab[s[i]];\n                        }\n                    }\n                    return result;\n                }\n            };\n        ","\n        \nclass Solution {\n    public:\n        int romanToInt(string s) {\n     map<char,int> Map;\n            Map['I']=1;\n            Map['V']=5;\n            Map['X']=10;\n            Map['L']=50;\n            Map['C']=100;\n            Map['D']=500;\n            Map['M']=1000;\n    \n            int n=0;\n            for(int i=0;i<s.length();i++)\n            {\n                if(Map[s[i]]<Map[s[i+1]]) n-=Map[s[i]];\n                if(Map[s[i]]>=Map[s[i+1]]) n+=Map[s[i]];\n            }\n            return n;\n    \n        }\n    };\n        "]
    },
    {
        "id":15,
        "description":"\n        Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n\n0 <= a, b, c, d < n\na, b, c, and d are distinct.\nnums[a] + nums[b] + nums[c] + nums[d] == target\nYou may return the answer in any order.\n\n \n\nExample 1:\n\nInput: nums = [1,0,-1,0,-2,2], target = 0\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\nExample 2:\n\nInput: nums = [2,2,2,2,2], target = 8\nOutput: [[2,2,2,2]]\n \n\nConstraints:\n\n1 <= nums.length <= 200\n-10^9 <= nums[i] <= 10^9\n-10^9 <= target <= 10^9\n        ",
        "tag":["Array","Two Pointers","Sorting"],
        "answer":["\n        class Solution {\n            public:\n                vector<vector<int>> fourSum(vector<int>& nums, int target) {\n                    vector<vector<int>> quadruplets;\n                    if (nums.size() < 4) {\n                        return quadruplets;\n                    }\n                    sort(nums.begin(), nums.end());\n                    int length = nums.size();\n                    for (int i = 0; i < length - 3; i++) {\n                        if (i > 0 && nums[i] == nums[i - 1]) {\n                            continue;\n                        }\n                        if ((long) nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) {\n                            break;\n                        }\n                        if ((long) nums[i] + nums[length - 3] + nums[length - 2] + nums[length - 1] < target) {\n                            continue;\n                        }\n                        for (int j = i + 1; j < length - 2; j++) {\n                            if (j > i + 1 && nums[j] == nums[j - 1]) {\n                                continue;\n                            }\n                            if ((long) nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target) {\n                                break;\n                            }\n                            if ((long) nums[i] + nums[j] + nums[length - 2] + nums[length - 1] < target) {\n                                continue;\n                            }\n                            int left = j + 1, right = length - 1;\n                            while (left < right) {\n                                long sum = (long) nums[i] + nums[j] + nums[left] + nums[right];\n                                if (sum == target) {\n                                    quadruplets.push_back({nums[i], nums[j], nums[left], nums[right]});\n                                    while (left < right && nums[left] == nums[left + 1]) {\n                                        left++;\n                                    }\n                                    left++;\n                                    while (left < right && nums[right] == nums[right - 1]) {\n                                        right--;\n                                    }\n                                    right--;\n                                } else if (sum < target) {\n                                    left++;\n                                } else {\n                                    right--;\n                                }\n                            }\n                        }\n                    }\n                    return quadruplets;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<vector<int>> fourSum(vector<int> &nums, int target) {\n                    sort(nums.begin(), nums.end());\n                    vector<vector<int>> ans;\n                    int n = nums.size();\n                    for (int a = 0; a < n - 3; a++) {\n                        long long x = nums[a];\n                        if (a > 0 && x == nums[a - 1]) continue;\n                        if (x + nums[a + 1] + nums[a + 2] + nums[a + 3] > target) break;\n                        if (x + nums[n - 3] + nums[n - 2] + nums[n - 1] < target) continue;\n                        for (int b = a + 1; b < n - 2; b++) {\n                            long long y = nums[b];\n                            if (b > a + 1 && y == nums[b - 1]) continue;\n                            if (x + y + nums[b + 1] + nums[b + 2] > target) break;\n                            if (x + y + nums[n - 2] + nums[n - 1] < target) continue;\n                            int c = b + 1, d = n - 1;\n                            while (c < d) { \n                                long long s = x + y + nums[c] + nums[d];\n                                if (s > target) d--;\n                                else if (s < target) c++;\n                                else { // s == target\n                                    ans.push_back({(int) x, (int) y, nums[c], nums[d]});\n                                    for (c++; c < d && nums[c] == nums[c - 1]; c++);\n                                    for (d--; d > c && nums[d] == nums[d + 1]; d--);\n                                }\n                            }\n                        }\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<vector<int>> fourSum(vector<int>& nums, int target) {\n                    int n = nums.size();\n                    vector<vector<int>> ans;\n                    if (n < 4) {\n                        return ans;\n                    }\n                    sort(nums.begin(), nums.end());\n                    for (int i = 0; i < n - 3; ++i) {\n                        if (i && nums[i] == nums[i - 1]) {\n                            continue;\n                        }\n                        for (int j = i + 1; j < n - 2; ++j) {\n                            if (j > i + 1 && nums[j] == nums[j - 1]) {\n                                continue;\n                            }\n                            int k = j + 1, l = n - 1;\n                            while (k < l) {\n                                long long x = (long long) nums[i] + nums[j] + nums[k] + nums[l];\n                                if (x < target) {\n                                    ++k;\n                                } else if (x > target) {\n                                    --l;\n                                } else {\n                                    ans.push_back({nums[i], nums[j], nums[k++], nums[l--]});\n                                    while (k < l && nums[k] == nums[k - 1]) {\n                                        ++k;\n                                    }\n                                    while (k < l && nums[l] == nums[l + 1]) {\n                                        --l;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    return ans;\n                }\n            };\n        "]
    },
    {
        "id":18,
        "description":"\n        You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\n\nMerge all the linked-lists into one sorted linked-list and return it.\n\n \n\nExample 1:\n\nInput: lists = [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]\nExplanation: The linked-lists are:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\nmerging them into one sorted list:\n1->1->2->3->4->4->5->6\nExample 2:\n\nInput: lists = []\nOutput: []\nExample 3:\n\nInput: lists = [[]]\nOutput: []\n \n\nConstraints:\n\nk == lists.length\n0 <= k <= 10^4\n0 <= lists[i].length <= 500\n-10^4 <= lists[i][j] <= 10^4\nlists[i] is sorted in ascending order.\nThe sum of lists[i].length will not exceed 10^4.\n        ",
        "tag":["Linked List","Divide and Conquer","Heap (Priority Queue)","Merge Sort"],
        "answer":["\n        class Solution {\n            public:\n                ListNode* mergeTwoLists(ListNode *a, ListNode *b) {\n                    if ((!a) || (!b)) return a ? a : b;\n                    ListNode head, *tail = &head, *aPtr = a, *bPtr = b;\n                    while (aPtr && bPtr) {\n                        if (aPtr->val < bPtr->val) {\n                            tail->next = aPtr; aPtr = aPtr->next;\n                        } else {\n                            tail->next = bPtr; bPtr = bPtr->next;\n                        }\n                        tail = tail->next;\n                    }\n                    tail->next = (aPtr ? aPtr : bPtr);\n                    return head.next;\n                }\n            \n                ListNode* merge(vector <ListNode*> &lists, int l, int r) {\n                    if (l == r) return lists[l];\n                    if (l > r) return nullptr;\n                    int mid = (l + r) >> 1;\n                    return mergeTwoLists(merge(lists, l, mid), merge(lists, mid + 1, r));\n                }\n            \n                ListNode* mergeKLists(vector<ListNode*>& lists) {\n                    return merge(lists, 0, lists.size() - 1);\n                }\n            };\n        ","\n        class Solution {\n            public:\n                ListNode* mergeTwoLists(ListNode *a, ListNode *b) {\n                    if ((!a) || (!b)) return a ? a : b;\n                    ListNode head, *tail = &head, *aPtr = a, *bPtr = b;\n                    while (aPtr && bPtr) {\n                        if (aPtr->val < bPtr->val) {\n                            tail->next = aPtr; aPtr = aPtr->next;\n                        } else {\n                            tail->next = bPtr; bPtr = bPtr->next;\n                        }\n                        tail = tail->next;\n                    }\n                    tail->next = (aPtr ? aPtr : bPtr);\n                    return head.next;\n                }\n            \n                ListNode* mergeKLists(vector<ListNode*>& lists) {\n                    ListNode *ans = nullptr;\n                    for (size_t i = 0; i < lists.size(); ++i) {\n                        ans = mergeTwoLists(ans, lists[i]);\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                struct Status {\n                    int val;\n                    ListNode *ptr;\n                    bool operator < (const Status &rhs) const {\n                        return val > rhs.val;\n                    }\n                };\n            \n                priority_queue <Status> q;\n            \n                ListNode* mergeKLists(vector<ListNode*>& lists) {\n                    for (auto node: lists) {\n                        if (node) q.push({node->val, node});\n                    }\n                    ListNode head, *tail = &head;\n                    while (!q.empty()) {\n                        auto f = q.top(); q.pop();\n                        tail->next = f.ptr; \n                        tail = tail->next;\n                        if (f.ptr->next) q.push({f.ptr->next->val, f.ptr->next});\n                    }\n                    return head.next;\n                }\n            };\n        "]
    },
    {
        "id":19,
        "description":"\n        Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.\n\nConsider the number of unique elements of nums to be k, to get accepted, you need to do the following things:\n\nChange the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums.\nReturn k.\nCustom Judge:\n\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\nIf all assertions pass, then your solution will be accepted.\n\n \n\nExample 1:\n\nInput: nums = [1,1,2]\nOutput: 2, nums = [1,2,_]\nExplanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\nExample 2:\n\nInput: nums = [0,0,1,1,1,2,2,3,3,4]\nOutput: 5, nums = [0,1,2,3,4,_,_,_,_,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n \n\nConstraints:\n\n1 <= nums.length <= 3 * 10^4\n-100 <= nums[i] <= 100\nnums is sorted in non-decreasing order.\n        ",
        "tag":["Array","Two Pointers"],
        "answer":["\n        class Solution {\n            public:\n                int removeDuplicates(vector<int>& nums) {\n                    int n = nums.size();\n                    if (n == 0) {\n                        return 0;\n                    }\n                    int fast = 1, slow = 1;\n                    while (fast < n) {\n                        if (nums[fast] != nums[fast - 1]) {\n                            nums[slow] = nums[fast];\n                            ++slow;\n                        }\n                        ++fast;\n                    }\n                    return slow;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int removeDuplicates(vector<int>& nums) {\n                    int length = nums.size();\n                    if (length == 0) return 0;\n                    int slow = 0, fast = 1;\n                    while (fast < length) {\n                        if (nums[fast] != nums[slow]) {\n                            nums[++slow] = nums[fast];\n                        }\n                        fast++;\n                    }\n                    return slow + 1;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int removeDuplicates(vector<int>& nums) {\n                    set<int> ans;\n                    for (auto &i : nums) {\n                        ans.emplace(i);\n                    }\n                    nums.clear();\n                    vector<int> tmp(ans.begin(), ans.end());\n                    nums = tmp;\n                    return nums.size();\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int removeDuplicates(vector<int>& nums) {\n                    int left = 0;\n                    for (int right = 0; right < nums.size(); ++right) {\n                        if (nums[left] != nums[right]) {\n                            nums[left + 1] = nums[right];\n                            ++left;\n                        }\n                    }\n                    return left + 1;\n                }\n            };\n        "]
    },
    {
        "id":20,
        "description":"\n        Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.\n\nConsider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:\n\nChange the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums.\nReturn k.\nCustom Judge:\n\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint val = ...; // Value to remove\nint[] expectedNums = [...]; // The expected answer with correct length.\n                            // It is sorted with no values equaling val.\n\nint k = removeElement(nums, val); // Calls your implementation\n\nassert k == expectedNums.length;\nsort(nums, 0, k); // Sort the first k elements of nums\nfor (int i = 0; i < actualLength; i++) {\n    assert nums[i] == expectedNums[i];\n}\nIf all assertions pass, then your solution will be accepted.\n\n \n\nExample 1:\n\nInput: nums = [3,2,2,3], val = 3\nOutput: 2, nums = [2,2,_,_]\nExplanation: Your function should return k = 2, with the first two elements of nums being 2.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\nExample 2:\n\nInput: nums = [0,1,2,2,3,0,4,2], val = 2\nOutput: 5, nums = [0,1,4,0,3,_,_,_]\nExplanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\nNote that the five elements can be returned in any order.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n \n\nConstraints:\n\n0 <= nums.length <= 100\n0 <= nums[i] <= 50\n0 <= val <= 100\n        ",
        "tag":["Array","Two Pointers"],
        "answer":["\n        class Solution {\n            public:\n                int removeElement(vector<int>& nums, int val) {\n                    int n = nums.size();\n                    int left = 0;\n                    for (int right = 0; right < n; right++) {\n                        if (nums[right] != val) {\n                            nums[left] = nums[right];\n                            left++;\n                        }\n                    }\n                    return left;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int removeElement(vector<int>& nums, int val) {\n                    int left = 0, right = nums.size();\n                    while (left < right) {\n                        if (nums[left] == val) {\n                            nums[left] = nums[right - 1];\n                            right--;\n                        } else {\n                            left++;\n                        }\n                    }\n                    return left;\n                }\n            };\n        ","\n        \nclass Solution {\n    public:\n        int removeElement(vector<int>& nums, int val) {\n                    int left,right;\n                    left = 0;\n                    right =nums.size() - 1;\n                    while(left <= right)\n                    {\n                        if(nums[left] == val){\n                            nums[left] = nums[right];\n                            right --;\n                        }\n                        if(nums[left] != val)\n                            left ++;\n                    }\n                    return right + 1;\n    \n        }\n    };\n        "]
    },
    {
        "id":21,
        "description":"\n        Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\n\n \n\nExample 1:\n\nInput: haystack = \"sadbutsad\", needle = \"sad\"\nOutput: 0\nExplanation: \"sad\" occurs at index 0 and 6.\nThe first occurrence is at index 0, so we return 0.\nExample 2:\n\nInput: haystack = \"leetcode\", needle = \"leeto\"\nOutput: -1\nExplanation: \"leeto\" did not occur in \"leetcode\", so we return -1.\n \n\nConstraints:\n\n1 <= haystack.length, needle.length <= 10^4\nhaystack and needle consist of only lowercase English characters.\n        ",
        "tag":["Two Pointers","String","String Matching"],
        "answer":["\n        class Solution {\n            public:\n                int strStr(string haystack, string needle) {\n                    int n = haystack.size(), m = needle.size();\n                    for (int i = 0; i + m <= n; i++) {\n                        bool flag = true;\n                        for (int j = 0; j < m; j++) {\n                            if (haystack[i + j] != needle[j]) {\n                                flag = false;\n                                break;\n                            }\n                        }\n                        if (flag) {\n                            return i;\n                        }\n                    }\n                    return -1;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int strStr(string haystack, string needle) {\n                    int n = haystack.size(), m = needle.size();\n                    if (m == 0) {\n                        return 0;\n                    }\n                    vector<int> pi(m);\n                    for (int i = 1, j = 0; i < m; i++) {\n                        while (j > 0 && needle[i] != needle[j]) {\n                            j = pi[j - 1];\n                        }\n                        if (needle[i] == needle[j]) {\n                            j++;\n                        }\n                        pi[i] = j;\n                    }\n                    for (int i = 0, j = 0; i < n; i++) {\n                        while (j > 0 && haystack[i] != needle[j]) {\n                            j = pi[j - 1];\n                        }\n                        if (haystack[i] == needle[j]) {\n                            j++;\n                        }\n                        if (j == m) {\n                            return i - m + 1;\n                        }\n                    }\n                    return -1;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                void getNext(int* next, const string& s) {\n                    int j = 0;\n                    next[0] = 0;\n                    for(int i = 1; i < s.size(); i++) {\n                        while (j > 0 && s[i] != s[j]) {\n                            j = next[j - 1];\n                        }\n                        if (s[i] == s[j]) {\n                            j++;\n                        }\n                        next[i] = j;\n                    }\n                }\n                int strStr(string haystack, string needle) {\n                    if (needle.size() == 0) {\n                        return 0;\n                    }\n                    int next[needle.size()];\n                    getNext(next, needle);\n                    int j = 0;\n                    for (int i = 0; i < haystack.size(); i++) {\n                        while(j > 0 && haystack[i] != needle[j]) {\n                            j = next[j - 1];\n                        }\n                        if (haystack[i] == needle[j]) {\n                            j++;\n                        }\n                        if (j == needle.size() ) {\n                            return (i - needle.size() + 1);\n                        }\n                    }\n                    return -1;\n                }\n            };\n        "]
    },
    {
        "id":22,
        "description":"\n        Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.\n\nThe integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.\n\nReturn the quotient after dividing dividend by divisor.\n\nNote: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−2^31, 2^31 − 1]. For this problem, if the quotient is strictly greater than 2^31 - 1, then return 2^31 - 1, and if the quotient is strictly less than -2^31, then return -2^31.\n\n \n\nExample 1:\n\nInput: dividend = 10, divisor = 3\nOutput: 3\nExplanation: 10/3 = 3.33333.. which is truncated to 3.\nExample 2:\n\nInput: dividend = 7, divisor = -3\nOutput: -2\nExplanation: 7/-3 = -2.33333.. which is truncated to -2.\n \n\nConstraints:\n\n-2^31 <= dividend, divisor <= 2^31 - 1\ndivisor != 0\n        ",
        "tag":["Bit Manipulation","Math"],
        "answer":["\n        class Solution {\n            public:\n                int divide(int dividend, int divisor) {\n                    if (dividend == INT_MIN) {\n                        if (divisor == 1) {\n                            return INT_MIN;\n                        }\n                        if (divisor == -1) {\n                            return INT_MAX;\n                        }\n                    }\n                    if (divisor == INT_MIN) {\n                        return dividend == INT_MIN ? 1 : 0;\n                    }\n                    if (dividend == 0) {\n                        return 0;\n                    }\n                    \n                    bool rev = false;\n                    if (dividend > 0) {\n                        dividend = -dividend;\n                        rev = !rev;\n                    }\n                    if (divisor > 0) {\n                        divisor = -divisor;\n                        rev = !rev;\n                    }\n            \n                    auto quickAdd = [](int y, int z, int x) {\n                        int result = 0, add = y;\n                        while (z) {\n                            if (z & 1) {\n                                if (result < x - add) {\n                                    return false;\n                                }\n                                result += add;\n                            }\n                            if (z != 1) {\n                                if (add < x - add) {\n                                    return false;\n                                }\n                                add += add;\n                            }\n                            z >>= 1;\n                        }\n                        return true;\n                    };\n                    \n                    int left = 1, right = INT_MAX, ans = 0;\n                    while (left <= right) {\n                        int mid = left + ((right - left) >> 1);\n                        bool check = quickAdd(divisor, mid, dividend);\n                        if (check) {\n                            ans = mid;\n                            if (mid == INT_MAX) {\n                                break;\n                            }\n                            left = mid + 1;\n                        }\n                        else {\n                            right = mid - 1;\n                        }\n                    }\n            \n                    return rev ? -ans : ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int divide(int dividend, int divisor) {\n                    if (dividend == INT_MIN) {\n                        if (divisor == 1) {\n                            return INT_MIN;\n                        }\n                        if (divisor == -1) {\n                            return INT_MAX;\n                        }\n                    }\n                    if (divisor == INT_MIN) {\n                        return dividend == INT_MIN ? 1 : 0;\n                    }\n                    if (dividend == 0) {\n                        return 0;\n                    }\n                    \n                    bool rev = false;\n                    if (dividend > 0) {\n                        dividend = -dividend;\n                        rev = !rev;\n                    }\n                    if (divisor > 0) {\n                        divisor = -divisor;\n                        rev = !rev;\n                    }\n            \n                    vector<int> candidates = {divisor};\n                    while (candidates.back() >= dividend - candidates.back()) {\n                        candidates.push_back(candidates.back() + candidates.back());\n                    }\n                    int ans = 0;\n                    for (int i = candidates.size() - 1; i >= 0; --i) {\n                        if (candidates[i] >= dividend) {\n                            ans += (1 << i);\n                            dividend -= candidates[i];\n                        }\n                    }\n            \n                    return rev ? -ans : ans;\n                }\n            };\n        ","\n        int divide(int a, int b) {\n            if (a == INT_MIN && b == -1) return INT_MAX;\n        \n                int sign = (a > 0) ^ (b > 0) ? -1 : 1;\n        \n                if (a > 0) a = -a;\n                if (b > 0) b = -b;\n                \n                int res = 0;\n                while (a <= b) {\n                    int value = b;\n                    int k = 1;\n                    while (value >= 0xc0000000 && a <= value + value) {\n                        value += value;\n                        if (k > INT_MAX / 2) return INT_MIN;\n                        k += k;\n                    }\n                    a -= value;\n                    res += k;\n                }\n        \n                return sign == 1 ? res : -res;\n        }\n        "]
    },
    {
        "id":23,
        "description":"\n        You are given a string s and an array of strings words. All the strings of words are of the same length.\n\nA concatenated substring in s is a substring that contains all the strings of any permutation of words concatenated.\n\nFor example, if words = [\"ab\",\"cd\",\"ef\"], then \"abcdef\", \"abefcd\", \"cdabef\", \"cdefab\", \"efabcd\", and \"efcdab\" are all concatenated strings. \"acdbef\" is not a concatenated substring because it is not the concatenation of any permutation of words.\nReturn the starting indices of all the concatenated substrings in s. You can return the answer in any order.\n\n \n\nExample 1:\n\nInput: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\nOutput: [0,9]\nExplanation: Since words.length == 2 and words[i].length == 3, the concatenated substring has to be of length 6.\nThe substring starting at 0 is \"barfoo\". It is the concatenation of [\"bar\",\"foo\"] which is a permutation of words.\nThe substring starting at 9 is \"foobar\". It is the concatenation of [\"foo\",\"bar\"] which is a permutation of words.\nThe output order does not matter. Returning [9,0] is fine too.\nExample 2:\n\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\nOutput: []\nExplanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\nThere is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\nWe return an empty array.\nExample 3:\n\nInput: s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\nOutput: [6,9,12]\nExplanation: Since words.length == 3 and words[i].length == 3, the concatenated substring has to be of length 9.\nThe substring starting at 6 is \"foobarthe\". It is the concatenation of [\"foo\",\"bar\",\"the\"] which is a permutation of words.\nThe substring starting at 9 is \"barthefoo\". It is the concatenation of [\"bar\",\"the\",\"foo\"] which is a permutation of words.\nThe substring starting at 12 is \"thefoobar\". It is the concatenation of [\"the\",\"foo\",\"bar\"] which is a permutation of words.\n \n\nConstraints:\n\n1 <= s.length <= 10^4\n1 <= words.length <= 5000\n1 <= words[i].length <= 30\ns and words[i] consist of lowercase English letters.\n        ",
        "tag":["Hash Table","String","Sliding Window"],
        "answer":["\n        class Solution {\n            public:\n                vector<int> findSubstring(string &s, vector<string> &words) {\n                    vector<int> res;\n                    int m = words.size(), n = words[0].size(), ls = s.size();\n                    for (int i = 0; i < n && i + m * n <= ls; ++i) {\n                        unordered_map<string, int> differ;\n                        for (int j = 0; j < m; ++j) {\n                            ++differ[s.substr(i + j * n, n)];\n                        }\n                        for (string &word: words) {\n                            if (--differ[word] == 0) {\n                                differ.erase(word);\n                            }\n                        }\n                        for (int start = i; start < ls - m * n + 1; start += n) {\n                            if (start != i) {\n                                string word = s.substr(start + (m - 1) * n, n);\n                                if (++differ[word] == 0) {\n                                    differ.erase(word);\n                                }\n                                word = s.substr(start - n, n);\n                                if (--differ[word] == 0) {\n                                    differ.erase(word);\n                                }\n                            }\n                            if (differ.empty()) {\n                                res.emplace_back(start);\n                            }\n                        }\n                    }\n                    return res;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<int> findSubstring(string s, vector<string>& words) {\n                    vector<int> res;\n                    int n = s.size(), m = words.size(), d = words[0].size();\n                    int len = 0;\n                    unordered_map<string, int> um;\n                    for (string w : words) {\n                        len += w.size();\n                        um[w]++;\n                    }\n            \n                    vector<unordered_map<string, int> > vu(d);\n                    for (int i = 0; i < d && i + len <= n; i++) {\n                        for (int j = i; j < i + len; j += d) {\n                            string w = s.substr(j, d);\n                            vu[i][w]++;\n                        }\n                        if (vu[i] == um) {\n                            res.emplace_back(i);\n                        }\n                    }\n            \n                    for (int i = d; i + len <= n; i++) {\n                        int r = i % d;\n                        string wa = s.substr(i - d, d), wb = s.substr(i + len - d, d);\n                        if(--vu[r][wa] == 0) vu[r].erase(wa);\n                        vu[r][wb]++;\n                        if (vu[r] == um) {\n                            res.emplace_back(i);\n                        }\n                    }\n            \n                    return res;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<int> findSubstring(string s, vector<string>& words) {\n                    vector<int> res;\n                    unordered_map<string, int> search;\n                    for (auto &word : words) ++search[word];\n                    int n = s.size(), m = words.size(), len = words[0].size();\n                    for (int i = 0, j = 0; i < n - m * len + 1; ++i) {\n                        unordered_map<string, int> sub; \n                        for (j = 0; j < m; ++j) {\n                            auto word = s.substr(i + j * len, len);\n                            if (!search.count(word)) break;\n                            if (++sub[word] > search[word]) break;\n                        }\n                        if (j == m) res.push_back(i);\n                    }\n                    return res;\n                }\n            };\n        "]
    },
    {
        "id":24,
        "description":"\n        A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\n\nFor example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\nThe next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n\nFor example, the next permutation of arr = [1,2,3] is [1,3,2].\nSimilarly, the next permutation of arr = [2,3,1] is [3,1,2].\nWhile the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.\nGiven an array of integers nums, find the next permutation of nums.\n\nThe replacement must be in place and use only constant extra memory.\n\n \n\nExample 1:\n\nInput: nums = [1,2,3]\nOutput: [1,3,2]\nExample 2:\n\nInput: nums = [3,2,1]\nOutput: [1,2,3]\nExample 3:\n\nInput: nums = [1,1,5]\nOutput: [1,5,1]\n \n\nConstraints:\n\n1 <= nums.length <= 100\n0 <= nums[i] <= 100\n        ",
        "tag":["Array","Two Pointers"],
        "answer":["\n        class Solution {\n            public:\n                void nextPermutation(vector<int>& nums) {\n                    int i = nums.size() - 2;\n                    while (i >= 0 && nums[i] >= nums[i + 1]) {\n                        i--;\n                    }\n                    if (i >= 0) {\n                        int j = nums.size() - 1;\n                        while (j >= 0 && nums[i] >= nums[j]) {\n                            j--;\n                        }\n                        swap(nums[i], nums[j]);\n                    }\n                    reverse(nums.begin() + i + 1, nums.end());\n                }\n            };\n        ","\n        class Solution {\n            private:\n                int findp(vector<int>& nums, int left, int right, int& target){\n                    while(left <= right){\n                        int mid = left + (right - left) / 2;\n                        if(nums[mid] <= target) right = mid - 1;\n                        else  left = mid + 1;\n                    }\n                    return right;\n                }\n            public:\n                void nextPermutation(vector<int>& nums) {\n                    int n = nums.size();\n                    if(n < 2) return;\n                    int p = n - 2;\n                    while(p >= 0){\n                        if(nums[p] >= nums[p + 1]) {\n                            p--;\n                            continue;\n                        }\n                        else break;\n                    }\n                    if(p == -1){\n                        reverse(nums.begin(), nums.end());\n                        return;\n                    }\n                    int q = findp(nums, p + 1, n - 1, nums[p]);\n                    int tmp = nums[p];\n                    nums[p] = nums[q];\n                    nums[q] = tmp;\n                    reverse(nums.begin() + (p + 1), nums.end());\n                    return;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                void nextPermutation(vector<int>& nums) {\n                    int cur=nums.size()-2;\n            \n                    while(cur>=0&&nums[cur]>=nums[cur+1])\n                    {\n                        cur--;\n                    }\n            \n                    if(cur<0)\n                        sort(nums.begin(),nums.end());\n                    else\n                    {\n                        int pos=nums.size()-1;\n                        while(nums[pos]<=nums[cur])\n                        {\n                            pos--;\n                        }\n            \n                        swap(nums[cur],nums[pos]);\n                        reverse(nums.begin()+cur+1,nums.end());\n                    }\n                    \n                }\n            };\n        ","\n        class Solution {\n            public:\n                void nextPermutation(vector<int>& nums) {\n                    int n = nums.size();\n                    if(n < 2) return;\n                    for(int i = nums.size()-2; i >= 0; i--){\n                        int poi;\n                        int nowMin;\n                        bool find = false;\n                        for(int j = i+1; j < n; j++){\n                            if(nums[j] > nums[i]){\n                                if(find == false){\n                                    find = true;\n                                    poi = j;\n                                    nowMin = nums[j];\n                                }   \n                                else{\n                                    if(nowMin > nums[j]){\n                                        poi = j;\n                                        nowMin = nums[j]; \n                                    }\n                                }\n                            }\n                        }\n                        if(find == true){\n                            nums[poi] = nums[i];\n                            nums[i] = nowMin;\n                            sort(nums.begin()+i+1,nums.end());\n                            return;\n                        }\n                    }\n                    sort(nums.begin(),nums.end());\n                }\n            };\n        "]
    },
    {
        "id":25,
        "description":"\n        Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses \nsubstring\n.\n\n \n\nExample 1:\n\nInput: s = \"(()\"\nOutput: 2\nExplanation: The longest valid parentheses substring is \"()\".\nExample 2:\n\nInput: s = \")()())\"\nOutput: 4\nExplanation: The longest valid parentheses substring is \"()()\".\nExample 3:\n\nInput: s = \"\"\nOutput: 0\n \n\nConstraints:\n\n0 <= s.length <= 3 * 10^4\ns[i] is '(', or ')'.\n        ",
        "tag":["Stack","String","Dynamic Programming"],
        "answer":["\n        class Solution {\n            public:\n                int longestValidParentheses(string s) {\n                    int maxans = 0, n = s.length();\n                    vector<int> dp(n, 0);\n                    for (int i = 1; i < n; i++) {\n                        if (s[i] == ')') {\n                            if (s[i - 1] == '(') {\n                                dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;\n                            } else if (i - dp[i - 1] > 0 && s[i - dp[i - 1] - 1] == '(') {\n                                dp[i] = dp[i - 1] + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;\n                            }\n                            maxans = max(maxans, dp[i]);\n                        }\n                    }\n                    return maxans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int longestValidParentheses(string s) {\n                    int maxans = 0;\n                    stack<int> stk;\n                    stk.push(-1);\n                    for (int i = 0; i < s.length(); i++) {\n                        if (s[i] == '(') {\n                            stk.push(i);\n                        } else {\n                            stk.pop();\n                            if (stk.empty()) {\n                                stk.push(i);\n                            } else {\n                                maxans = max(maxans, i - stk.top());\n                            }\n                        }\n                    }\n                    return maxans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int longestValidParentheses(string s) {\n                    int left = 0, right = 0, maxlength = 0;\n                    for (int i = 0; i < s.length(); i++) {\n                        if (s[i] == '(') {\n                            left++;\n                        } else {\n                            right++;\n                        }\n                        if (left == right) {\n                            maxlength = max(maxlength, 2 * right);\n                        } else if (right > left) {\n                            left = right = 0;\n                        }\n                    }\n                    left = right = 0;\n                    for (int i = (int)s.length() - 1; i >= 0; i--) {\n                        if (s[i] == '(') {\n                            left++;\n                        } else {\n                            right++;\n                        }\n                        if (left == right) {\n                            maxlength = max(maxlength, 2 * left);\n                        } else if (left > right) {\n                            left = right = 0;\n                        }\n                    }\n                    return maxlength;\n                }\n            };\n        "]
    },
    {
        "id":26,
        "description":"\n        There is an integer array nums sorted in ascending order (with distinct values).\n\nPrior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\n\nGiven the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\n\nYou must write an algorithm with O(log n) runtime complexity.\n\n \n\nExample 1:\n\nInput: nums = [4,5,6,7,0,1,2], target = 0\nOutput: 4\nExample 2:\n\nInput: nums = [4,5,6,7,0,1,2], target = 3\nOutput: -1\nExample 3:\n\nInput: nums = [1], target = 0\nOutput: -1\n \n\nConstraints:\n\n1 <= nums.length <= 5000\n-10^4 <= nums[i] <= 10^4\nAll values of nums are unique.\nnums is an ascending array that is possibly rotated.\n-10^4 <= target <= 10^4\n        ",
        "tag":["Array","Binary Search"],
        "answer":["\n        class Solution {\n            public:\n                int search(vector<int>& nums, int target) {\n                    int n = (int)nums.size();\n                    if (!n) {\n                        return -1;\n                    }\n                    if (n == 1) {\n                        return nums[0] == target ? 0 : -1;\n                    }\n                    int l = 0, r = n - 1;\n                    while (l <= r) {\n                        int mid = (l + r) / 2;\n                        if (nums[mid] == target) return mid;\n                        if (nums[0] <= nums[mid]) {\n                            if (nums[0] <= target && target < nums[mid]) {\n                                r = mid - 1;\n                            } else {\n                                l = mid + 1;\n                            }\n                        } else {\n                            if (nums[mid] < target && target <= nums[n - 1]) {\n                                l = mid + 1;\n                            } else {\n                                r = mid - 1;\n                            }\n                        }\n                    }\n                    return -1;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int search(vector<int>& nums, int target) {\n                    int lo = 0, hi = nums.size() - 1;\n                    while (lo < hi) {\n                        int mid = (lo + hi) / 2;\n                        if ((nums[0] > target) ^ (nums[0] > nums[mid]) ^ (target > nums[mid]))\n                            lo = mid + 1;\n                        else\n                            hi = mid;\n                    }\n                    return lo == hi && nums[lo] == target ? lo : -1;\n                }\n            };\n        ","\n        class Solution {\n\n            public:\n                int result = 0;\n                int mid = 0;\n                int findOrder(int m, int n, vector<int>& nums, int target){\n                    if(m == n){\n                        if(target == nums[m]) return m;\n                        else return -1;\n                    }\n                    mid = (m+n)/2;\n                    if(target<=nums[mid]){\n                        result = findOrder(m,mid,nums,target);\n                    }\n                    else{\n                        result = findOrder(mid+1,n,nums,target);\n                    }\n                    return result;\n                }\n                int findDisOrder(int m, int n, vector<int>& nums, int target){\n                    if(m == n){\n                        if(target == nums[m]) return m;\n                        else return -1;\n                    }\n                    mid = (m+n)/2;\n                    if(nums[m] <= nums[mid]){\n                        if(nums[m] <= target && target <= nums[mid]){\n                            result = findOrder(m,mid,nums,target);\n                        }\n                        else{\n                            result = findDisOrder(mid+1,n,nums,target);\n                        }\n                    }\n                    else{\n                        if(nums[mid+1] <= target && target <= nums[n]){\n                            result = findOrder(mid+1,n,nums,target);\n                        }\n                        else{\n                            result = findDisOrder(m,mid,nums,target);\n                        }   \n                    }\n                    return result;\n                }\n                int search(vector<int>& nums, int target) {\n                    int len = nums.size(), i = 0;\n                    return  findDisOrder(i,len-1,nums, target);\n                }\n            };\n        "]
    },
    {
        "id":27,
        "description":"\n        Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\n\nIf target is not found in the array, return [-1, -1].\n\nYou must write an algorithm with O(log n) runtime complexity.\n\n \n\nExample 1:\n\nInput: nums = [5,7,7,8,8,10], target = 8\nOutput: [3,4]\nExample 2:\n\nInput: nums = [5,7,7,8,8,10], target = 6\nOutput: [-1,-1]\nExample 3:\n\nInput: nums = [], target = 0\nOutput: [-1,-1]\n \n\nConstraints:\n\n0 <= nums.length <= 10^5\n-10^9 <= nums[i] <= 10^9\nnums is a non-decreasing array.\n-10^9 <= target <= 10^9\n        ",
        "tag":["Array","Binary Search"],
        "answer":["\n        class Solution { \npublic:\n    int binarySearch(vector<int>& nums, int target, bool lower) {\n        int left = 0, right = (int)nums.size() - 1, ans = (int)nums.size();\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            if (nums[mid] > target || (lower && nums[mid] >= target)) {\n                right = mid - 1;\n                ans = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return ans;\n    }\n\n    vector<int> searchRange(vector<int>& nums, int target) {\n        int leftIdx = binarySearch(nums, target, true);\n        int rightIdx = binarySearch(nums, target, false) - 1;\n        if (leftIdx <= rightIdx && rightIdx < nums.size() && nums[leftIdx] == target && nums[rightIdx] == target) {\n            return vector<int>{leftIdx, rightIdx};\n        } \n        return vector<int>{-1, -1};\n    }\n};\n        ","\n        class Solution {\n            int lower_bound(vector<int> &nums, int target) {\n                int left = 0, right = (int) nums.size() - 1;\n                while (left <= right) {\n                    int mid = left + (right - left) / 2;\n                    if (nums[mid] < target)\n                        left = mid + 1;\n                    else\n                        right = mid - 1;\n                }\n                return left;\n            }\n        \n            int lower_bound2(vector<int> &nums, int target) {\n                int left = 0, right = nums.size();\n                while (left < right) {\n                    int mid = left + (right - left) / 2;\n                    if (nums[mid] < target)\n                        left = mid + 1;\n                    else\n                        right = mid;\n                }\n                return left;\n            }\n        \n            int lower_bound3(vector<int> &nums, int target) {\n                int left = -1, right = nums.size();\n                while (left + 1 < right) {\n                    int mid = left + (right - left) / 2;\n                    if (nums[mid] < target)\n                        left = mid;\n                    else\n                        right = mid;\n                }\n                return right;\n            }\n        \n        public:\n            vector<int> searchRange(vector<int> &nums, int target) {\n                int start = lower_bound(nums, target);\n                if (start == nums.size() || nums[start] != target)\n                    return {-1, -1};\n                int end = lower_bound(nums, target + 1) - 1;\n                return {start, end};\n            }\n        };\n        ","\n        class Solution {\n            public:\n                vector<int> searchRange(vector<int>& nums, int target) {\n                    if(nums.empty()) return {-1,-1};\n                \n                    int l = 0, r = nums.size() - 1;\n                    while( l < r)\n                    {\n                        int mid = (l + r )/2;\n                        if(nums[mid] >= target) r = mid;\n                        else l = mid + 1;\n                    }\n                    if( nums[r] != target) return {-1,-1};\n                    int L = r;\n                    l = 0, r = nums.size() - 1;\n                    while( l < r)\n                    {\n                        int mid = (l + r + 1)/2;\n                        if(nums[mid] <= target ) l = mid;\n                        else r = mid - 1;\n                    }\n                    return {L,r};\n                }\n            };\n        "]
    },
    {
        "id":28,
        "description":"\n        Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\nYou must write an algorithm with O(log n) runtime complexity.\n\n \n\nExample 1:\n\nInput: nums = [1,3,5,6], target = 5\nOutput: 2\nExample 2:\n\nInput: nums = [1,3,5,6], target = 2\nOutput: 1\nExample 3:\n\nInput: nums = [1,3,5,6], target = 7\nOutput: 4\n \n\nConstraints:\n\n1 <= nums.length <= 10^4\n-10^4 <= nums[i] <= 10^4\nnums contains distinct values sorted in ascending order.\n-10^4 <= target <= 10^4\n        ",
        "tag":["Array","Binary Search"],
        "answer":["\n        class Solution {\n            public:\n                int searchInsert(vector<int>& nums, int target) {\n                    int n = nums.size();\n                    int left = 0, right = n - 1, ans = n;\n                    while (left <= right) {\n                        int mid = ((right - left) >> 1) + left;\n                        if (target <= nums[mid]) {\n                            ans = mid;\n                            right = mid - 1;\n                        } else {\n                            left = mid + 1;\n                        }\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int searchInsert(vector<int>& nums, int target) {\n                    auto n = find(nums.begin(),nums.end(),target);\n                    if(n != nums.end())\n                    {\n                        return n - nums.begin();\n                    }\n                    else\n                    {\n                        return lower_bound(nums.begin(),nums.end(),target) - nums.begin();\n                    }\n                }\n            };\n        ","\n        \nclass Solution {\n    public:\n        int searchInsert(vector<int>& nums, int target) {\n            int n=nums.size();\n            int l=0,r=n-1,mid;\n            while(l<=r){\n                mid=(l+r)/2;\n                if (target>nums[mid]){\n                    l=mid+1;\n                    continue;\n                }\n                else if (target<nums[mid]){\n                    r=mid-1;\n                    continue;\n                }\n                else break;\n            }\n            if (l>r) return l;\n            else return mid;\n        }\n    };\n        "]
    }
]