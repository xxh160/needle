[
    {
        "id":1,
        "description":"\n        Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\n        You may assume that each input would have exactly one solution, and you may not use the same element twice.\n        \n        You can return the answer in any order.\n        \n         \n        \n        Example 1:\n        \n        Input: nums = [2,7,11,15], target = 9\n        Output: [0,1]\n        Explanation: Because nums[0] + nums[1] == 9, we return [0, 1].\n        Example 2:\n        \n        Input: nums = [3,2,4], target = 6\n        Output: [1,2]\n        Example 3:\n        \n        Input: nums = [3,3], target = 6\n        Output: [0,1]\n         \n        \n        Constraints:\n        \n        2 <= nums.length <= 10^4\n        -10^9 <= nums[i] <= 10^9\n        -10^9 <= target <= 10^9\n        Only one valid answer exists.",
        "tag":["Array","Hash Table"],
        "answer":["\n        class Solution {\n            public:\n                vector<int> twoSum(vector<int>& nums, int target) {\n                    int n = nums.size();\n                    for (int i = 0; i < n; ++i) {\n                        for (int j = i + 1; j < n; ++j) {\n                            if (nums[i] + nums[j] == target) {\n                                return {i, j};\n                            }\n                        }\n                    }\n                    return {};\n                }\n            };","\n        class Solution {\n            public:\n                vector<int> twoSum(vector<int>& nums, int target) {\n                    unordered_map<int, int> hashtable;\n                    for (int i = 0; i < nums.size(); ++i) {\n                        auto it = hashtable.find(target - nums[i]);\n                        if (it != hashtable.end()) {\n                            return {it->second, i};\n                        }\n                        hashtable[nums[i]] = i;\n                    }\n                    return {};\n                }\n            };","\n        class Solution {\n            public:\n                vector<int> twoSum(vector<int>& nums, int target) {\n                    map<int,int> a;\n                    vector<int> b(2,-1);\n                    for(int i=0;i<nums.size();i++)\n                        a.insert(map<int,int>::value_type(nums[i],i));\n                    for(int i=0;i<nums.size();i++)\n                    {\n                        if(a.count(target-nums[i])>0&&(a[target-nums[i]]!=i))\n                        {\n                            b[0]=i;\n                            b[1]=a[target-nums[i]];\n                            break;\n                        }\n                    }\n                    return b;\n                };\n            };","\n        class Solution {\n                public:\n                    vector<int> twoSum(vector<int>& nums, int target) {\n                        map<int,int> a;\n                        vector<int> b(2,-1);\n                        for(int i=0;i<nums.size();i++)\n                        {\n                            if(a.count(target-nums[i])>0)\n                            {\n                                b[0]=a[target-nums[i]];\n                                b[1]=i;\n                                break;\n                            }\n                            a[nums[i]]=i;\n                        }\n                        return b;\n                    };\n                };"]
    },
    {
        "id":2,
        "description":"\n        Given a string s, find the length of the longest \nsubstring\n without repeating characters.\n\n \n\nExample 1:\n\nInput: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\nExample 2:\n\nInput: s = \"bbbbb\"\nOutput: 1\nExplanation: The answer is \"b\", with the length of 1.\nExample 3:\n\nInput: s = \"pwwkew\"\nOutput: 3\nExplanation: The answer is \"wke\", with the length of 3.\nNotice that the answer must be a substring, \"pwke\" is a subsequence and not a substring.\n \n\nConstraints:\n\n0 <= s.length <= 5 * 10^4\ns consists of English letters, digits, symbols and spaces.",
        "tag":["Hash Table","String","Sliding Window"],
        "answer":["\n        class Solution {\n            public:\n                int lengthOfLongestSubstring(string s) {\n                    unordered_set<char> occ;\n                    int n = s.size();\n                    int rk = -1, ans = 0;\n                    for (int i = 0; i < n; ++i) {\n                        if (i != 0) {\n                            occ.erase(s[i - 1]);\n                        }\n                        while (rk + 1 < n && !occ.count(s[rk + 1])) {\n                            occ.insert(s[rk + 1]);\n                            ++rk;\n                        }\n                        ans = max(ans, rk - i + 1);\n                    }\n                    return ans;\n                }\n            };\n        ","\n        int lengthOfLongestSubstring(string s) {\n            vector<int> m(128, 0);\n            int ans = 0;\n            int i = 0;\n            for (int j = 0; j < s.size(); j++) {\n                i = max(i, m[s[j]]);\n                m[s[j]] = j + 1;\n                ans = max(ans, j - i + 1);\n            }\n            return ans;\n        }\n        ","\n        class Solution\n{\npublic:\n    int lengthOfLongestSubstring(string s)\n    {\n        //s[start,end) 前面包含 后面不包含\n        int start(0), end(0), length(0), result(0);\n        int sSize = int(s.size());\n        while (end < sSize)\n        {\n            char tmpChar = s[end];\n            for (int index = start; index < end; index++)\n            {\n                if (tmpChar == s[index])\n                {\n                    start = index + 1;\n                    length = end - start;\n                    break;\n                }\n            }\n\n            end++;\n            length++;\n            result = max(result, length);\n        }\n        return result;\n    }\n};\n        ","\n        class Solution\n{\npublic:\n    int lengthOfLongestSubstring(string s)\n    {\n        //s[start,end) 前面包含 后面不包含\n        int start(0), end(0), length(0), result(0);\n        int sSize = int(s.size());\n        unordered_map<char, int> hash;\n        while (end < sSize)\n        {\n            char tmpChar = s[end];\n            //仅当s[start,end) 中存在s[end]时更新start\n            if (hash.find(tmpChar) != hash.end() && hash[tmpChar] >= start)\n            {\n                start = hash[tmpChar] + 1;\n                length = end - start;\n            }\n            hash[tmpChar] = end;\n\n            end++;\n            length++;\n            result = max(result, length);\n        }\n        return result;\n    }\n};\n        ","\n        class Solution\n{\npublic:\n    int lengthOfLongestSubstring(string s)\n    {\n        //s[start,end) 前面包含 后面不包含\n        int start(0), end(0), length(0), result(0);\n        int sSize = int(s.size());\n        vector<int> vec(128, -1);\n        while (end < sSize)\n        {\n            char tmpChar = s[end];\n            //仅当s[start,end) 中存在s[end]时更新start\n            if (vec[int(tmpChar)] >= start)\n            {\n                start = vec[int(tmpChar)] + 1;\n                length = end - start;\n            }\n            vec[int(tmpChar)] = end;\n\n            end++;\n            length++;\n            result = max(result, length);\n        }\n        return result;\n    }\n};\n        "]
    },
    {
        "id":3,
        "description":"\n        Given two sorted arrays nums1 and nums2 of size m and n respectively, return the median of the two sorted arrays.\n\nThe overall run time complexity should be O(log (m+n)).\n\n \n\nExample 1:\n\nInput: nums1 = [1,3], nums2 = [2]\nOutput: 2.00000\nExplanation: merged array = [1,2,3] and median is 2.\nExample 2:\n\nInput: nums1 = [1,2], nums2 = [3,4]\nOutput: 2.50000\nExplanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.\n \n\nConstraints:\n\nnums1.length == m\nnums2.length == n\n0 <= m <= 1000\n0 <= n <= 1000\n1 <= m + n <= 2000\n-10^6 <= nums1[i], nums2[i] <= 10^6\n        ",
        "tag":["Array","Binary Search","Divide and Conquer"],
        "answer":["\n        class Solution {\n            public:\n                int getKthElement(const vector<int>& nums1, const vector<int>& nums2, int k) {\n                    int m = nums1.size();\n                    int n = nums2.size();\n                    int index1 = 0, index2 = 0;\n            \n                    while (true) {\n                        if (index1 == m) {\n                            return nums2[index2 + k - 1];\n                        }\n                        if (index2 == n) {\n                            return nums1[index1 + k - 1];\n                        }\n                        if (k == 1) {\n                            return min(nums1[index1], nums2[index2]);\n                        }\n            \n                        int newIndex1 = min(index1 + k / 2 - 1, m - 1);\n                        int newIndex2 = min(index2 + k / 2 - 1, n - 1);\n                        int pivot1 = nums1[newIndex1];\n                        int pivot2 = nums2[newIndex2];\n                        if (pivot1 <= pivot2) {\n                            k -= newIndex1 - index1 + 1;\n                            index1 = newIndex1 + 1;\n                        }\n                        else {\n                            k -= newIndex2 - index2 + 1;\n                            index2 = newIndex2 + 1;\n                        }\n                    }\n                }\n            \n                double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n                    int totalLength = nums1.size() + nums2.size();\n                    if (totalLength % 2 == 1) {\n                        return getKthElement(nums1, nums2, (totalLength + 1) / 2);\n                    }\n                    else {\n                        return (getKthElement(nums1, nums2, totalLength / 2) + getKthElement(nums1, nums2, totalLength / 2 + 1)) / 2.0;\n                    }\n                }\n            };\n        ","\n        class Solution {\n            public:\n                double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n                    if (nums1.size() > nums2.size()) {\n                        return findMedianSortedArrays(nums2, nums1);\n                    }\n                    \n                    int m = nums1.size();\n                    int n = nums2.size();\n                    int left = 0, right = m;\n                    int median1 = 0, median2 = 0;\n            \n                    while (left <= right) {\n                        int i = (left + right) / 2;\n                        int j = (m + n + 1) / 2 - i;\n            \n                        int nums_im1 = (i == 0 ? INT_MIN : nums1[i - 1]);\n                        int nums_i = (i == m ? INT_MAX : nums1[i]);\n                        int nums_jm1 = (j == 0 ? INT_MIN : nums2[j - 1]);\n                        int nums_j = (j == n ? INT_MAX : nums2[j]);\n            \n                        if (nums_im1 <= nums_j) {\n                            median1 = max(nums_im1, nums_jm1);\n                            median2 = min(nums_i, nums_j);\n                            left = i + 1;\n                        } else {\n                            right = i - 1;\n                        }\n                    }\n            \n                    return (m + n) % 2 == 0 ? (median1 + median2) / 2.0 : median1;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n                    int len = nums1.size() + nums2.size();\n                    const int k = len / 2; \n                    int i = 0, j = 0;\n                    double res1 = 0, res2 = 0;\n                    nums1.push_back(INT_MAX);\n                    nums2.push_back(INT_MAX);\n                    while (i + j <= k) {\n                        res1 = res2;\n                        res2 = nums1[i] <= nums2[j] ? nums1[i++] : nums2[j++];\n                    }\n                    return len % 2 == 1 ? res2 : (res1 + res2) / 2;\n                }\n            };\n        "]
    },
    {
        "id":4,
        "description":"\n        Given a string s, return the longest \npalindromic\n \nsubstring\n in s.\n\n \n\nExample 1:\n\nInput: s = \"babad\"\nOutput: \"bab\"\nExplanation: \"aba\" is also a valid answer.\nExample 2:\n\nInput: s = \"cbbd\"\nOutput: \"bb\"\n \n\nConstraints:\n\n1 <= s.length <= 1000\ns consist of only digits and English letters.\n        ",
        "tag":["String","Dynamic Programming"],
        "answer":["\n        #include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    string longestPalindrome(string s) {\n        int n = s.size();\n        if (n < 2) {\n            return s;\n        }\n\n        int maxLen = 1;\n        int begin = 0;\n        vector<vector<int>> dp(n, vector<int>(n));\n        for (int i = 0; i < n; i++) {\n            dp[i][i] = true;\n        }\n        for (int L = 2; L <= n; L++) {\n            for (int i = 0; i < n; i++) {\n                int j = L + i - 1;\n                if (j >= n) {\n                    break;\n                }\n\n                if (s[i] != s[j]) {\n                    dp[i][j] = false;\n                } else {\n                    if (j - i < 3) {\n                        dp[i][j] = true;\n                    } else {\n                        dp[i][j] = dp[i + 1][j - 1];\n                    }\n                }\n\n                if (dp[i][j] && j - i + 1 > maxLen) {\n                    maxLen = j - i + 1;\n                    begin = i;\n                }\n            }\n        }\n        return s.substr(begin, maxLen);\n    }\n};\n        ","\n        class Solution {\n            public:\n                pair<int, int> expandAroundCenter(const string& s, int left, int right) {\n                    while (left >= 0 && right < s.size() && s[left] == s[right]) {\n                        --left;\n                        ++right;\n                    }\n                    return {left + 1, right - 1};\n                }\n            \n                string longestPalindrome(string s) {\n                    int start = 0, end = 0;\n                    for (int i = 0; i < s.size(); ++i) {\n                        auto [left1, right1] = expandAroundCenter(s, i, i);\n                        auto [left2, right2] = expandAroundCenter(s, i, i + 1);\n                        if (right1 - left1 > end - start) {\n                            start = left1;\n                            end = right1;\n                        }\n                        if (right2 - left2 > end - start) {\n                            start = left2;\n                            end = right2;\n                        }\n                    }\n                    return s.substr(start, end - start + 1);\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int expand(const string& s, int left, int right) {\n                    while (left >= 0 && right < s.size() && s[left] == s[right]) {\n                        --left;\n                        ++right;\n                    }\n                    return (right - left - 2) / 2;\n                }\n            \n                string longestPalindrome(string s) {\n                    int start = 0, end = -1;\n                    string t = \"#\";\n                    for (char c: s) {\n                        t += c;\n                        t += '#';\n                    }\n                    t += '#';\n                    s = t;\n            \n                    vector<int> arm_len;\n                    int right = -1, j = -1;\n                    for (int i = 0; i < s.size(); ++i) {\n                        int cur_arm_len;\n                        if (right >= i) {\n                            int i_sym = j * 2 - i;\n                            int min_arm_len = min(arm_len[i_sym], right - i);\n                            cur_arm_len = expand(s, i - min_arm_len, i + min_arm_len);\n                        } else {\n                            cur_arm_len = expand(s, i, i);\n                        }\n                        arm_len.push_back(cur_arm_len);\n                        if (i + cur_arm_len > right) {\n                            j = i;\n                            right = i + cur_arm_len;\n                        }\n                        if (cur_arm_len * 2 + 1 > end - start) {\n                            start = i - cur_arm_len;\n                            end = i + cur_arm_len;\n                        }\n                    }\n            \n                    string ans;\n                    for (int i = start; i <= end; ++i) {\n                        if (s[i] != '#') {\n                            ans += s[i];\n                        }\n                    }\n                    return ans;\n                }\n            };\n        "]
    },
    {
        "id":5,
        "description":"\n        The string \"PAYPALISHIRING\" is written in a zigzag pattern on a given number of rows like this: (you may want to display this pattern in a fixed font for better legibility)\n\nP   A   H   N\nA P L S I I G\nY   I   R\nAnd then read line by line: \"PAHNAPLSIIGYIR\"\n\nWrite the code that will take a string and make this conversion given a number of rows:\n\nstring convert(string s, int numRows);\n \n\nExample 1:\n\nInput: s = \"PAYPALISHIRING\", numRows = 3\nOutput: \"PAHNAPLSIIGYIR\"\nExample 2:\n\nInput: s = \"PAYPALISHIRING\", numRows = 4\nOutput: \"PINALSIGYAHRPI\"\nExplanation:\nP     I    N\nA   L S  I G\nY A   H R\nP     I\nExample 3:\n\nInput: s = \"A\", numRows = 1\nOutput: \"A\"\n \n\nConstraints:\n\n1 <= s.length <= 1000\ns consists of English letters (lower-case and upper-case), ',' and '.'.\n1 <= numRows <= 1000\n        ",
        "tag":["String"],
        "answer":["\n        class Solution {\n            public:\n                string convert(string s, int numRows) {\n                    int n = s.length(), r = numRows;\n                    if (r == 1 || r >= n) {\n                        return s;\n                    }\n                    int t = r * 2 - 2;\n                    int c = (n + t - 1) / t * (r - 1);\n                    vector<string> mat(r, string(c, 0));\n                    for (int i = 0, x = 0, y = 0; i < n; ++i) {\n                        mat[x][y] = s[i];\n                        if (i % t < r - 1) {\n                            ++x;\n                        } else {\n                            --x;\n                            ++y;\n                        }\n                    }\n                    string ans;\n                    for (auto &row : mat) {\n                        for (char ch : row) {\n                            if (ch) {\n                                ans += ch;\n                            }\n                        }\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                string convert(string s, int numRows) {\n                    int n = s.length(), r = numRows;\n                    if (r == 1 || r >= n) {\n                        return s;\n                    }\n                    vector<string> mat(r);\n                    for (int i = 0, x = 0, t = r * 2 - 2; i < n; ++i) {\n                        mat[x] += s[i];\n                        i % t < r - 1 ? ++x : --x;\n                    }\n                    string ans;\n                    for (auto &row : mat) {\n                        ans += row;\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                string convert(string s, int numRows) {\n                    int n = s.length(), r = numRows;\n                    if (r == 1 || r >= n) {\n                        return s;\n                    }\n                    string ans;\n                    int t = r * 2 - 2;\n                    for (int i = 0; i < r; ++i) {\n                        for (int j = 0; j + i < n; j += t) {\n                            ans += s[j + i];\n                            if (0 < i && i < r - 1 && j + t - i < n) {\n                                ans += s[j + t - i];\n                            }\n                        }\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                string convert(string s, int numRows) {\n            \n                    if (numRows == 1) return s;\n            \n                    vector<string> rows(min(numRows, int(s.size())));\n                    int curRow = 0;\n                    bool goingDown = false;\n            \n                    for (char c : s) {\n                        rows[curRow] += c;\n                        if (curRow == 0 || curRow == numRows - 1) {\n                            goingDown = !goingDown;\n                        }\n                        curRow += goingDown ? 1 : -1;\n                    }\n            \n                    string ret;\n                    for (string row : rows) {\n                        ret += row;\n                    }\n            \n                    return ret;\n                }\n            };\n        "]
    },
    {
        "id":6,
        "description":"\n        Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-2^31, 2^31 - 1], then return 0.\n\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).\n\n \n\nExample 1:\n\nInput: x = 123\nOutput: 321\nExample 2:\n\nInput: x = -123\nOutput: -321\nExample 3:\n\nInput: x = 120\nOutput: 21\n \n\nConstraints:\n\n-2^31 <= x <= 2^31 - 1\n        ",
        "tag":["Math"],
        "answer":["\n        class Solution {\n            public:\n                int reverse(int x) {\n                    int rev = 0;\n                    while (x != 0) {\n                        if (rev < INT_MIN / 10 || rev > INT_MAX / 10) {\n                            return 0;\n                        }\n                        int digit = x % 10;\n                        x /= 10;\n                        rev = rev * 10 + digit;\n                    }\n                    return rev;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int reverse(int x) {\n                    int ans = 0;\n                    while(x != 0){\n                        int z = x % 10;\n                        if (INT32_MIN/10 > ans) return 0;\n                        if (INT32_MAX/10 < ans) return 0;\n                        ans = ans*10+z;\n                        x/=10;\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int reverse(int x) {\n                    long ans = 0;\n                    int res = 0;\n                    while(x!=0)\n                    {\n                        int temp = x % 10;\n                        ans = ans*10 + temp;\n                        x /= 10;\n                    }\n                    res = int(ans)==ans ? ans : 0;\n            \n                    return res;\n                }\n            };\n        "]
    },
    {
        "id":7,
        "description":"\n        Implement the myAtoi(string s) function, which converts a string to a 32-bit signed integer (similar to C/C++'s atoi function).\n\nThe algorithm for myAtoi(string s) is as follows:\n\nRead in and ignore any leading whitespace.\nCheck if the next character (if not already at the end of the string) is '-' or '+'. Read this character in if it is either. This determines if the final result is negative or positive respectively. Assume the result is positive if neither is present.\nRead in next the characters until the next non-digit character or the end of the input is reached. The rest of the string is ignored.\nConvert these digits into an integer (i.e. \"123\" -> 123, \"0032\" -> 32). If no digits were read, then the integer is 0. Change the sign as necessary (from step 2).\nIf the integer is out of the 32-bit signed integer range [-2^31, 2^31 - 1], then clamp the integer so that it remains in the range. Specifically, integers less than -2^31 should be clamped to -2^31, and integers greater than 2^31 - 1 should be clamped to 2^31 - 1.\nReturn the integer as the final result.\nNote:\n\nOnly the space character ' ' is considered a whitespace character.\nDo not ignore any characters other than the leading whitespace or the rest of the string after the digits.\n \n\nExample 1:\n\nInput: s = \"42\"\nOutput: 42\nExplanation: The underlined characters are what is read in, the caret is the current reader position.\nStep 1: \"42\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"42\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"42\" (\"42\" is read in)\n           ^\nThe parsed integer is 42.\nSince 42 is in the range [-2^31, 2^31 - 1], the final result is 42.\nExample 2:\n\nInput: s = \"   -42\"\nOutput: -42\nExplanation:\nStep 1: \"   -42\" (leading whitespace is read and ignored)\n            ^\nStep 2: \"   -42\" ('-' is read, so the result should be negative)\n             ^\nStep 3: \"   -42\" (\"42\" is read in)\n               ^\nThe parsed integer is -42.\nSince -42 is in the range [-2^31, 2^31 - 1], the final result is -42.\nExample 3:\n\nInput: s = \"4193 with words\"\nOutput: 4193\nExplanation:\nStep 1: \"4193 with words\" (no characters read because there is no leading whitespace)\n         ^\nStep 2: \"4193 with words\" (no characters read because there is neither a '-' nor '+')\n         ^\nStep 3: \"4193 with words\" (\"4193\" is read in; reading stops because the next character is a non-digit)\n             ^\nThe parsed integer is 4193.\nSince 4193 is in the range [-2^31, 2^31 - 1], the final result is 4193.\n \n\nConstraints:\n\n0 <= s.length <= 200\ns consists of English letters (lower-case and upper-case), digits (0-9), ' ', '+', '-', and '.'.\n        ",
        "tag":["String"],
        "answer":["\n        class Automaton {\n            string state = \"start\";\n            unordered_map<string, vector<string>> table = {\n                {\"start\", {\"start\", \"signed\", \"in_number\", \"end\"}},\n                {\"signed\", {\"end\", \"end\", \"in_number\", \"end\"}},\n                {\"in_number\", {\"end\", \"end\", \"in_number\", \"end\"}},\n                {\"end\", {\"end\", \"end\", \"end\", \"end\"}}\n            };\n        \n            int get_col(char c) {\n                if (isspace(c)) return 0;\n                if (c == '+' or c == '-') return 1;\n                if (isdigit(c)) return 2;\n                return 3;\n            }\n        public:\n            int sign = 1;\n            long long ans = 0;\n        \n            void get(char c) {\n                state = table[state][get_col(c)];\n                if (state == \"in_number\") {\n                    ans = ans * 10 + c - '0';\n                    ans = sign == 1 ? min(ans, (long long)INT_MAX) : min(ans, -(long long)INT_MIN);\n                }\n                else if (state == \"signed\")\n                    sign = c == '+' ? 1 : -1;\n            }\n        };\n        \n        class Solution {\n        public:\n            int myAtoi(string str) {\n                Automaton automaton;\n                for (char c : str)\n                    automaton.get(c);\n                return automaton.sign * automaton.ans;\n            }\n        };\n        ","\n        #include <iostream>\n#include <string>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int myAtoi(string str) {\n        unsigned long len = str.length();\n\n        int index = 0;\n        while (index < len) {\n            if (str[index] != ' ') {\n                break;\n            }\n            index++;\n        }\n\n        if (index == len) {\n            return 0;\n        }\n\n        int sign = 1;\n        if (str[index] == '+') {\n            index++;\n        } else if (str[index] == '-') {\n            sign = -1;\n            index++;\n        }\n\n        int res = 0;\n        while (index < len) {\n            char curChar = str[index];\n            if (curChar < '0' || curChar > '9') {\n                break;\n            }\n\n            if (res > INT_MAX / 10 || (res == INT_MAX / 10 && (curChar - '0') > INT_MAX % 10)) {\n                return INT_MAX;\n            }\n            if (res < INT_MIN / 10 || (res == INT_MIN / 10 && (curChar - '0') > -(INT_MIN % 10))) {\n                return INT_MIN;\n            }\n\n            res = res * 10 + sign * (curChar - '0');\n            index++;\n        }\n        return res;\n    }\n};\n        ","\n        class Solution {\n            public:\n                int transInt(string target) {\n                    if (target == \"\") {\n                        return 0;\n                    }\n                    int PosOrNeg = 1;\n                    if (target[0] == '-') {\n                        PosOrNeg = -1;\n                        target = target.substr(1, target.size() - 1);\n                    }\n                    long long res = 0;\n                    long long weight = 1;\n                    int left = 0;\n                    for (int i = 0; i < target.size(); i++) {\n                        if (target[i] != '0') { left = i; break; }\n                    }\n                    if (left == 0&&target[0]=='0') { return 0; }\n                    for (int i = target.size() - 1; i > left - 1; i--) {\n                        res = res + weight * ((long long)target[i] - 48);\n                        weight *= 10;\n                        if (weight >= 100000000000) {\n                            res = PosOrNeg > 0 ? INT32_MAX : INT32_MIN;\n                            return res;\n                            break;\n                        }\n                    }\n                    res = PosOrNeg * res;\n                    res = res>INT32_MAX?INT32_MAX:res;\n                    res = res<INT32_MIN?INT32_MIN:res; \n                    return res;\n                }\n            \n                string findNumPart(string s) {\n                    string res;\n                    int left = 0;\n                    for (; left < s.size(); left++) {\n                        if ((int)s[left] >= 48 && (int)s[left] <= 57) {\n                            break;\n                        }\n                    }\n            \n                    if (left != 0) {\n                        for (int i = 0; i < left - 1; i++) {\n                            if ((int)s[i] != 32) { return \"\"; }\n                        }\n                        if (s[left - 1] != '+'&&s[left - 1] != '-'&&s[left - 1] != ' ') { return \"\"; }\n                    }\n            \n            \n                    int right = left;\n                    if (right > 0 && s[right - 1] == '-') { left--; }\n                    for (; right < s.size(); right++) {\n                        if ((int)s[right] < 48 || (int)s[right]>57) {\n                            break;\n                        }\n                    }\n                    res = s.substr(left, right - left);\n                    return res;\n                }\n                int myAtoi(string s) {\n                    int res = 0;\n                    string target = findNumPart(s);\n                    res = transInt(target);\n                    return res;\n                }\n            };\n        ","\n        int myAtoi(string s) {\n            int result = 0;\n            int sign = 1;\n            int index = 0;\n        \n            while (index < s.size() && ' ' == s[index])index++;\n            if (index < s.size() && '-' == s[index]) { sign = -1; index++; }\n            else if (index < s.size() && '+' == s[index])index++;\n        \n            while (index < s.size() && s[index] >= '0' && s[index] <= '9') {\n                int num = s[index] - '0';\n                if (result > (INT_MAX - num) / 10)return INT_MAX;\n                if (result < (INT_MIN + num) / 10) return INT_MIN;\n                result = result * 10 + sign * num;\n                index++;\n            }\n            return result;\n        }\n        "]
    },
    {
        "id":8,
        "description":"\n        Given an integer x, return true if x is a \npalindrome\n, and false otherwise.\n\n \n\nExample 1:\n\nInput: x = 121\nOutput: true\nExplanation: 121 reads as 121 from left to right and from right to left.\nExample 2:\n\nInput: x = -121\nOutput: false\nExplanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.\nExample 3:\n\nInput: x = 10\nOutput: false\nExplanation: Reads 01 from right to left. Therefore it is not a palindrome.\n \n\nConstraints:\n\n-2^31 <= x <= 2^31 - 1\n        ",
        "tag":["Math"],
        "answer":["\n        class Solution {\n            public:\n                bool isPalindrome(int x) {\n                    if (x < 0 || (x % 10 == 0 && x != 0)) {\n                        return false;\n                    }\n            \n                    int revertedNumber = 0;\n                    while (x > revertedNumber) {\n                        revertedNumber = revertedNumber * 10 + x % 10;\n                        x /= 10;\n                    }\n                    return x == revertedNumber || x == revertedNumber / 10;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool isPalindrome(int x) {\n                    long long s=0,y=x;\n                    while(y){\n                        s=s*10+y%10;\n                        y/=10;\n                    }\n                    if(s==x&&s>=0) return 1;\n                    return 0;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool isPalindrome(int x) {\n                    string s = to_string(x);\n                    return s == string(s.rbegin(),s.rend());\n                }\n            };\n        "]
    },
    {
        "id":9,
        "description":"\n        Given an input string s and a pattern p, implement regular expression matching with support for '.' and '*' where:\n\n'.' Matches any single character.​​​​\n'*' Matches zero or more of the preceding element.\nThe matching should cover the entire input string (not partial).\n\n \n\nExample 1:\n\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\nExample 2:\n\nInput: s = \"aa\", p = \"a*\"\nOutput: true\nExplanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\nExample 3:\n\nInput: s = \"ab\", p = \".*\"\nOutput: true\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\n \n\nConstraints:\n\n1 <= s.length <= 20\n1 <= p.length <= 20\ns contains only lowercase English letters.\np contains only lowercase English letters, '.', and '*'.\nIt is guaranteed for each appearance of the character '*', there will be a previous valid character to match.\n        ",
        "tag":["Recursion","String","Dynamic Programming"],
        "answer":["\n        class Solution {\n            public:\n                bool isMatch(string s, string p) {\n                    int m = s.size();\n                    int n = p.size();\n            \n                    auto matches = [&](int i, int j) {\n                        if (i == 0) {\n                            return false;\n                        }\n                        if (p[j - 1] == '.') {\n                            return true;\n                        }\n                        return s[i - 1] == p[j - 1];\n                    };\n            \n                    vector<vector<int>> f(m + 1, vector<int>(n + 1));\n                    f[0][0] = true;\n                    for (int i = 0; i <= m; ++i) {\n                        for (int j = 1; j <= n; ++j) {\n                            if (p[j - 1] == '*') {\n                                f[i][j] |= f[i][j - 2];\n                                if (matches(i, j - 1)) {\n                                    f[i][j] |= f[i - 1][j];\n                                }\n                            }\n                            else {\n                                if (matches(i, j)) {\n                                    f[i][j] |= f[i - 1][j - 1];\n                                }\n                            }\n                        }\n                    }\n                    return f[m][n];\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool isMatch(string s, string p) {\n                    int m=s.size(),n=p.size();\n                    vector<vector<int>> dp(m+1,vector<int>(n+1,false));\n                    dp[0][0]=true;\n            \n                    for(int i=2;i<=n;i++){\n                        if(p[i-1]=='*')\n                        dp[0][i]=dp[0][i-2];\n                    }\n            \n                    for(int i=1;i<=m;i++){\n                        for(int j=1;j<=n;j++){\n                            //匹配*\n                            if(p[j-1]=='*'){\n                                 dp[i][j]=dp[i][j-2]||(dp[i-1][j]&&(s[i-1]==p[j-2]||p[j-2]=='.'));\n                            }\n                            else{\n                                 dp[i][j]=dp[i-1][j-1]&&(s[i-1]==p[j-1]||p[j-1]=='.');\n                            }\n                        }\n                    }\n                    return dp[m][n];\n                }\n            };\n        ","\n        class Solution {\n            public:\n            \n                int sn;\n                int pn;\n            \n                vector<vector<bool>> memo;\n            \n                bool backtracking(string&s,string&p,int sindx,int pindx) {\n            \n                    if(!memo[sindx][pindx]) return false;\n            \n                    if(sindx==sn){ \n                        memo[sindx][pindx] = pindx==pn||(pindx+1<pn&&p[pindx+1]=='*'&&backtracking(s,p,sindx,pindx+2));\n                        return memo[sindx][pindx];\n                    }\n                    else if(pn==pindx) {\n                        memo[sindx][pindx] = false;\n                        return false;\n                    }\n            \n                    \n            \n                    if(s[sindx]==p[pindx]||p[pindx]=='.') {\n            \n                        if(pindx+1<pn&&p[pindx+1]=='*') {\n                            memo[sindx][pindx] = backtracking(s,p,sindx+1,pindx)||backtracking(s,p,sindx+1,pindx+2)||backtracking(s,p,sindx,pindx+2);\n                            return memo[sindx][pindx];\n                        }\n                        else {\n                            memo[sindx][pindx] = backtracking(s,p,sindx+1,pindx+1);\n                            return memo[sindx][pindx];\n                        } \n                    }else{\n                        if(pindx+1<pn&&p[pindx+1]=='*') {\n                            memo[sindx][pindx] = backtracking(s,p,sindx,pindx+2);\n                            return memo[sindx][pindx];\n                        }\n                        else {\n                            memo[sindx][pindx] = false;\n                            return false;\n                        }\n                    }\n            \n                }\n            \n                bool isMatch(string s, string p) {\n                    sn = s.size();\n                    pn = p.size();\n            \n                    memo = vector<vector<bool>>(sn+1,vector<bool>(pn+1,true));\n            \n                    return backtracking(s,p,0,0);\n            \n                }\n            };\n        "]
    },
    {
        "id":10,
        "description":"\n        Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\nFor example, 2 is written as II in Roman numeral, just two one's added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\nI can be placed before V (5) and X (10) to make 4 and 9. \nX can be placed before L (50) and C (100) to make 40 and 90. \nC can be placed before D (500) and M (1000) to make 400 and 900.\nGiven an integer, convert it to a roman numeral.\n\n \n\nExample 1:\n\nInput: num = 3\nOutput: \"III\"\nExplanation: 3 is represented as 3 ones.\nExample 2:\n\nInput: num = 58\nOutput: \"LVIII\"\nExplanation: L = 50, V = 5, III = 3.\nExample 3:\n\nInput: num = 1994\nOutput: \"MCMXCIV\"\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n \n\nConstraints:\n\n1 <= num <= 3999\n        ",
        "tag":["Hash Table","Math","String"],
        "answer":["\n        const pair<int, string> valueSymbols[] = {\n            {1000, \"M\"},\n            {900,  \"CM\"},\n            {500,  \"D\"},\n            {400,  \"CD\"},\n            {100,  \"C\"},\n            {90,   \"XC\"},\n            {50,   \"L\"},\n            {40,   \"XL\"},\n            {10,   \"X\"},\n            {9,    \"IX\"},\n            {5,    \"V\"},\n            {4,    \"IV\"},\n            {1,    \"I\"},\n        };\n        \n        class Solution {\n        public:\n            string intToRoman(int num) {\n                string roman;\n                for (const auto &[value, symbol] : valueSymbols) {\n                    while (num >= value) {\n                        num -= value;\n                        roman += symbol;\n                    }\n                    if (num == 0) {\n                        break;\n                    }\n                }\n                return roman;\n            }\n        };\n        \",\"\n        const string thousands[] = {\"\", \"M\", \"MM\", \"MMM\"};\nconst string hundreds[]  = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\nconst string tens[]      = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\nconst string ones[]      = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\n\nclass Solution {\npublic:\n    string intToRoman(int num) {\n        return thousands[num / 1000] + hundreds[num % 1000 / 100] + tens[num % 100 / 10] + ones[num % 10];\n    }\n};\n        \",\"\n        class Solution {\n            public:\n                string intToRoman(int num) {\n                    int values[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n                    string reps[] = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\n            \n                    string res;\n                    int \n                    for (int i = 0; i < 13; i ++ )\n                        while(num >= values[i])\n                        {\n                            num -= values[i];\n                            res += reps[i];\n                        }\n                    return res;\n                }\n            };\n        "]
    },
    {
        "id":11,
        "description":"\n        Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n\nSymbol       Value\nI             1\nV             5\nX             10\nL             50\nC             100\nD             500\nM             1000\nFor example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\nI can be placed before V (5) and X (10) to make 4 and 9. \nX can be placed before L (50) and C (100) to make 40 and 90. \nC can be placed before D (500) and M (1000) to make 400 and 900.\nGiven a roman numeral, convert it to an integer.\n\n \n\nExample 1:\n\nInput: s = \"III\"\nOutput: 3\nExplanation: III = 3.\nExample 2:\n\nInput: s = \"LVIII\"\nOutput: 58\nExplanation: L = 50, V= 5, III = 3.\nExample 3:\n\nInput: s = \"MCMXCIV\"\nOutput: 1994\nExplanation: M = 1000, CM = 900, XC = 90 and IV = 4.\n \n\nConstraints:\n\n1 <= s.length <= 15\ns contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M').\nIt is guaranteed that s is a valid roman numeral in the range [1, 3999].\n        ",
        "tag":["Hash Table","Math","String"],
        "answer":["\n        class Solution {\n            private:\n                unordered_map<char, int> symbolValues = {\n                    {'I', 1},\n                    {'V', 5},\n                    {'X', 10},\n                    {'L', 50},\n                    {'C', 100},\n                    {'D', 500},\n                    {'M', 1000},\n                };\n            \n            public:\n                int romanToInt(string s) {\n                    int ans = 0;\n                    int n = s.length();\n                    for (int i = 0; i < n; ++i) {\n                        int value = symbolValues[s[i]];\n                        if (i < n - 1 && value < symbolValues[s[i + 1]]) {\n                            ans -= value;\n                        } else {\n                            ans += value;\n                        }\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int romanToInt(string s) {\n                    int result=0;\n                    map<char,int> luomab={\n                        {'I',1},\n                        {'V',5},\n                        {'X',10},\n                        {'L',50},\n                        {'C',100},\n                        {'D', 500},\n                        {'M', 1000}\n                    };//初始化哈希表\n                    for(int i=0;i<s.length();i++)\n                    {\n                        if(luomab[s[i]] < luomab[s[i+1]])\n                            result -= luomab[s[i]];\n                        else\n                        {\n                            result += luomab[s[i]];\n                        }\n                    }\n                    return result;\n                }\n            };\n        ","\n        \nclass Solution {\n    public:\n        int romanToInt(string s) {\n     map<char,int> Map;\n            Map['I']=1;\n            Map['V']=5;\n            Map['X']=10;\n            Map['L']=50;\n            Map['C']=100;\n            Map['D']=500;\n            Map['M']=1000;\n    \n            int n=0;\n            for(int i=0;i<s.length();i++)\n            {\n                if(Map[s[i]]<Map[s[i+1]]) n-=Map[s[i]];\n                if(Map[s[i]]>=Map[s[i+1]]) n+=Map[s[i]];\n            }\n            return n;\n    \n        }\n    };\n        "]
    },
    {
        "id":12,
        "description":"\n        Write a function to find the longest common prefix string amongst an array of strings.\n\nIf there is no common prefix, return an empty string \"\".\n\n \n\nExample 1:\n\nInput: strs = [\"flower\",\"flow\",\"flight\"]\nOutput: \"fl\"\nExample 2:\n\nInput: strs = [\"dog\",\"racecar\",\"car\"]\nOutput: \"\"\nExplanation: There is no common prefix among the input strings.\n \n\nConstraints:\n\n1 <= strs.length <= 200\n0 <= strs[i].length <= 200\nstrs[i] consists of only lowercase English letters.\n        ",
        "tag":["Trie","String"],
        "answer":["\n        class Solution {\n            public:\n                string longestCommonPrefix(vector<string>& strs) {\n                    if (!strs.size()) {\n                        return \"\";\n                    }\n                    string prefix = strs[0];\n                    int count = strs.size();\n                    for (int i = 1; i < count; ++i) {\n                        prefix = longestCommonPrefix(prefix, strs[i]);\n                        if (!prefix.size()) {\n                            break;\n                        }\n                    }\n                    return prefix;\n                }\n            \n                string longestCommonPrefix(const string& str1, const string& str2) {\n                    int length = min(str1.size(), str2.size());\n                    int index = 0;\n                    while (index < length && str1[index] == str2[index]) {\n                        ++index;\n                    }\n                    return str1.substr(0, index);\n                }\n            };\n        ","\n        class Solution {\n            public:\n                string longestCommonPrefix(vector<string>& strs) {\n                    if (!strs.size()) {\n                        return \"\";\n                    }\n                    int length = strs[0].size();\n                    int count = strs.size();\n                    for (int i = 0; i < length; ++i) {\n                        char c = strs[0][i];\n                        for (int j = 1; j < count; ++j) {\n                            if (i == strs[j].size() || strs[j][i] != c) {\n                                return strs[0].substr(0, i);\n                            }\n                        }\n                    }\n                    return strs[0];\n                }\n            };\n        ","\n        class Solution {\n            public:\n                string longestCommonPrefix(vector<string>& strs) {\n                    if (!strs.size()) {\n                        return \"\";\n                    }\n                    else {\n                        return longestCommonPrefix(strs, 0, strs.size() - 1);\n                    }\n                }\n            \n                string longestCommonPrefix(const vector<string>& strs, int start, int end) {\n                    if (start == end) {\n                        return strs[start];\n                    }\n                    else {\n                        int mid = (start + end) / 2;\n                        string lcpLeft = longestCommonPrefix(strs, start, mid);\n                        string lcpRight = longestCommonPrefix(strs, mid + 1, end);\n                        return commonPrefix(lcpLeft, lcpRight);\n                    }\n                }\n            \n                string commonPrefix(const string& lcpLeft, const string& lcpRight) {\n                    int minLength = min(lcpLeft.size(), lcpRight.size());\n                    for (int i = 0; i < minLength; ++i) {\n                        if (lcpLeft[i] != lcpRight[i]) {\n                            return lcpLeft.substr(0, i);\n                        }\n                    }\n                    return lcpLeft.substr(0, minLength);\n                }\n            };\n        ","\n        class Solution {\n            public:\n                string longestCommonPrefix(vector<string>& strs) {\n                    if (!strs.size()) {\n                        return \"\";\n                    }\n                    int minLength = min_element(strs.begin(), strs.end(), [](const string& s, const string& t) {return s.size() < t.size();})->size();\n                    int low = 0, high = minLength;\n                    while (low < high) {\n                        int mid = (high - low + 1) / 2 + low;\n                        if (isCommonPrefix(strs, mid)) {\n                            low = mid;\n                        }\n                        else {\n                            high = mid - 1;\n                        }\n                    }\n                    return strs[0].substr(0, low);\n                }\n            \n                bool isCommonPrefix(const vector<string>& strs, int length) {\n                    string str0 = strs[0].substr(0, length);\n                    int count = strs.size();\n                    for (int i = 1; i < count; ++i) {\n                        string str = strs[i];\n                        for (int j = 0; j < length; ++j) {\n                            if (str0[j] != str[j]) {\n                                return false;\n                            }\n                        }\n                    }\n                    return true;\n                }\n            };\n        "]
    },
    {
        "id":13,
        "description":"\n        Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\n\nNotice that the solution set must not contain duplicate triplets.\n\n \n\nExample 1:\n\nInput: nums = [-1,0,1,2,-1,-4]\nOutput: [[-1,-1,2],[-1,0,1]]\nExplanation: \nnums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0.\nnums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0.\nnums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0.\nThe distinct triplets are [-1,0,1] and [-1,-1,2].\nNotice that the order of the output and the order of the triplets does not matter.\nExample 2:\n\nInput: nums = [0,1,1]\nOutput: []\nExplanation: The only possible triplet does not sum up to 0.\nExample 3:\n\nInput: nums = [0,0,0]\nOutput: [[0,0,0]]\nExplanation: The only possible triplet sums up to 0.\n \n\nConstraints:\n\n3 <= nums.length <= 3000\n-10^5 <= nums[i] <= 10^5\n        ",
        "tag":["Array","Two Pointers","Sorting"],
        "answer":["\n        class Solution {\n            public:\n                vector<vector<int>> threeSum(vector<int>& nums) {\n                    int n = nums.size();\n                    sort(nums.begin(), nums.end());\n                    vector<vector<int>> ans;\n                    for (int first = 0; first < n; ++first) {\n                        if (first > 0 && nums[first] == nums[first - 1]) {\n                            continue;\n                        }\n                        int third = n - 1;\n                        int target = -nums[first];\n                        // 枚举 b\n                        for (int second = first + 1; second < n; ++second) {\n                            if (second > first + 1 && nums[second] == nums[second - 1]) {\n                                continue;\n                            }\n                            while (second < third && nums[second] + nums[third] > target) {\n                                --third;\n                            }\n                            if (second == third) {\n                                break;\n                            }\n                            if (nums[second] + nums[third] == target) {\n                                ans.push_back({nums[first], nums[second], nums[third]});\n                            }\n                        }\n                    }\n                    return ans;\n                }\n            };\n            ","\n            class Solution {\n                public:\n                    vector<vector<int>> threeSum(vector<int>& nums) {\n                        sort(nums.begin(), nums.end());\n                        vector<vector<int>> ans;\n                        int n = nums.size();\n                        for (int i = 0; i < n - 2 && nums[i] <= 0; ++i) {\n                            if (i && nums[i] == nums[i - 1]) {\n                                continue;\n                            }\n                            int j = i + 1, k = n - 1;\n                            while (j < k) {\n                                int x = nums[i] + nums[j] + nums[k];\n                                if (x < 0) {\n                                    ++j;\n                                } else if (x > 0) {\n                                    --k;\n                                } else {\n                                    ans.push_back({nums[i], nums[j++], nums[k--]});\n                                    while (j < k && nums[j] == nums[j - 1]) {\n                                        ++j;\n                                    }\n                                    while (j < k && nums[k] == nums[k + 1]) {\n                                        --k;\n                                    }\n                                }\n                            }\n                        }\n                        return ans;\n                    }\n                };\n            ","\n            class Solution {\n                public:\n                    vector<vector<int>> threeSum(vector<int>& a) {\n                        int n=a.size(),l,r;\n                        vector<vector<int>> ans;\n                        vector<int> b;\n                        sort(a.begin(),a.end());\n                        for(int i=0;i<n;i++){\n                            if(a[i]>0) break;\n                            if(i&&a[i]==a[i-1]) continue;\n                            l=i+1,r=n-1;\n                            while(l<r){\n                                if(a[i]+a[l]+a[r]==0){\n                                    b.push_back(a[i]);\n                                    b.push_back(a[l]);\n                                    b.push_back(a[r]);\n                                    ans.push_back(b);\n                                    b.clear();\n                                    l++,r--;\n                                    while(l<n&&a[l]==a[l-1]) l++;\n                                    while(r>i&&a[r]==a[r+1]) r--;\n                                }\n                                else if(a[i]+a[l]+a[r]<0) l++;\n                                else r--;\n                            }\n                \n                        }\n                        return ans;\n                    }\n                };\n            "]
    },
    {
        "id":14,
        "description":"\n        Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.\n\nReturn the sum of the three integers.\n\nYou may assume that each input would have exactly one solution.\n\n \n\nExample 1:\n\nInput: nums = [-1,2,1,-4], target = 1\nOutput: 2\nExplanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).\nExample 2:\n\nInput: nums = [0,0,0], target = 1\nOutput: 0\nExplanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0).\n \n\nConstraints:\n\n3 <= nums.length <= 500\n-1000 <= nums[i] <= 1000\n-10^4 <= target <= 10^4\n        ",
        "tag":["Array","Two Pointers","Sorting"],
        "answer":["\n        class Solution {\n            public:\n                int threeSumClosest(vector<int>& nums, int target) {\n                    sort(nums.begin(), nums.end());\n                    int n = nums.size();\n                    int best = 1e7;\n                    auto update = [&](int cur) {\n                        if (abs(cur - target) < abs(best - target)) {\n                            best = cur;\n                        }\n                    };\n            \n                    for (int i = 0; i < n; ++i) {\n                        if (i > 0 && nums[i] == nums[i - 1]) {\n                            continue;\n                        }\n                        int j = i + 1, k = n - 1;\n                        while (j < k) {\n                            int sum = nums[i] + nums[j] + nums[k];\n                            if (sum == target) {\n                                return target;\n                            }\n                            update(sum);\n                            if (sum > target) {\n                                int k0 = k - 1;\n                                while (j < k0 && nums[k0] == nums[k]) {\n                                    --k0;\n                                }\n                                k = k0;\n                            } else {\n                                int j0 = j + 1;\n                                while (j0 < k && nums[j0] == nums[j]) {\n                                    ++j0;\n                                }\n                                j = j0;\n                            }\n                        }\n                    }\n                    return best;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int threeSumClosest(vector<int> &nums, int target) {\n                    sort(nums.begin(), nums.end());\n                    int ans, n = nums.size();\n                    int min_diff = INT_MAX;\n                    for (int i = 0; i < n - 2; i++) {\n                        int x = nums[i];\n                        if (i > 0 && x == nums[i - 1]) {\n                            continue;\n                        }\n            \n                        int s = x + nums[i + 1] + nums[i + 2];\n                        if (s > target) {\n                            if (s - target < min_diff) {\n                                ans = s;\n                            }\n                            break;\n                        }\n            \n                        s = x + nums[n - 2] + nums[n - 1];\n                        if (s < target) { \n                            if (target - s < min_diff) {\n                                min_diff = target - s;\n                                ans = s;\n                            }\n                            continue;\n                        }\n            \n                        int j = i + 1, k = n - 1;\n                        while (j < k) {\n                            s = x + nums[j] + nums[k];\n                            if (s == target) {\n                                return target;\n                            }\n                            if (s > target) {\n                                if (s - target < min_diff) {\n                                    min_diff = s - target;\n                                    ans = s;\n                                }\n                                k--;\n                            } else { // s < target\n                                if (target - s < min_diff) {\n                                    min_diff = target - s;\n                                    ans = s;\n                                }\n                                j++;\n                            }\n                        }\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int threeSumClosest(vector<int>& nums, int target) {\n                    sort(nums.begin(), nums.end());\n                    int ans = 1 << 30;\n                    int n = nums.size();\n                    for (int i = 0; i < n; ++i) {\n                        int j = i + 1, k = n - 1;\n                        while (j < k) {\n                            int t = nums[i] + nums[j] + nums[k];\n                            if (t == target) return t;\n                            if (abs(t - target) < abs(ans - target)) ans = t;\n                            if (t > target)\n                                --k;\n                            else\n                                ++j;\n                        }\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int threeSumClosest(vector<int>& a, int t) {\n                    int n=a.size(),ans,l,r,s;\n                    sort(a.begin(),a.end());\n                    ans=a[0]+a[1]+a[2];\n                    for(int i=0;i<n;i++){\n                        l=i+1,r=n-1;\n                        while(l<r){\n                            s=a[i]+a[l]+a[r];\n                            if(abs(s-t)<abs(ans-t)) ans=s;  \n                            if(s==t) break;\n                            else if(s<t) l++;\n                            else r--;              \n                        }\n                    }\n                    return ans;\n                }\n            };\n        "]
    },
    {
        "id":15,
        "description":"\n        Given an array nums of n integers, return an array of all the unique quadruplets [nums[a], nums[b], nums[c], nums[d]] such that:\n\n0 <= a, b, c, d < n\na, b, c, and d are distinct.\nnums[a] + nums[b] + nums[c] + nums[d] == target\nYou may return the answer in any order.\n\n \n\nExample 1:\n\nInput: nums = [1,0,-1,0,-2,2], target = 0\nOutput: [[-2,-1,1,2],[-2,0,0,2],[-1,0,0,1]]\nExample 2:\n\nInput: nums = [2,2,2,2,2], target = 8\nOutput: [[2,2,2,2]]\n \n\nConstraints:\n\n1 <= nums.length <= 200\n-10^9 <= nums[i] <= 10^9\n-10^9 <= target <= 10^9\n        ",
        "tag":["Array","Two Pointers","Sorting"],
        "answer":["\n        class Solution {\n            public:\n                vector<vector<int>> fourSum(vector<int>& nums, int target) {\n                    vector<vector<int>> quadruplets;\n                    if (nums.size() < 4) {\n                        return quadruplets;\n                    }\n                    sort(nums.begin(), nums.end());\n                    int length = nums.size();\n                    for (int i = 0; i < length - 3; i++) {\n                        if (i > 0 && nums[i] == nums[i - 1]) {\n                            continue;\n                        }\n                        if ((long) nums[i] + nums[i + 1] + nums[i + 2] + nums[i + 3] > target) {\n                            break;\n                        }\n                        if ((long) nums[i] + nums[length - 3] + nums[length - 2] + nums[length - 1] < target) {\n                            continue;\n                        }\n                        for (int j = i + 1; j < length - 2; j++) {\n                            if (j > i + 1 && nums[j] == nums[j - 1]) {\n                                continue;\n                            }\n                            if ((long) nums[i] + nums[j] + nums[j + 1] + nums[j + 2] > target) {\n                                break;\n                            }\n                            if ((long) nums[i] + nums[j] + nums[length - 2] + nums[length - 1] < target) {\n                                continue;\n                            }\n                            int left = j + 1, right = length - 1;\n                            while (left < right) {\n                                long sum = (long) nums[i] + nums[j] + nums[left] + nums[right];\n                                if (sum == target) {\n                                    quadruplets.push_back({nums[i], nums[j], nums[left], nums[right]});\n                                    while (left < right && nums[left] == nums[left + 1]) {\n                                        left++;\n                                    }\n                                    left++;\n                                    while (left < right && nums[right] == nums[right - 1]) {\n                                        right--;\n                                    }\n                                    right--;\n                                } else if (sum < target) {\n                                    left++;\n                                } else {\n                                    right--;\n                                }\n                            }\n                        }\n                    }\n                    return quadruplets;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<vector<int>> fourSum(vector<int> &nums, int target) {\n                    sort(nums.begin(), nums.end());\n                    vector<vector<int>> ans;\n                    int n = nums.size();\n                    for (int a = 0; a < n - 3; a++) {\n                        long long x = nums[a];\n                        if (a > 0 && x == nums[a - 1]) continue;\n                        if (x + nums[a + 1] + nums[a + 2] + nums[a + 3] > target) break;\n                        if (x + nums[n - 3] + nums[n - 2] + nums[n - 1] < target) continue;\n                        for (int b = a + 1; b < n - 2; b++) {\n                            long long y = nums[b];\n                            if (b > a + 1 && y == nums[b - 1]) continue;\n                            if (x + y + nums[b + 1] + nums[b + 2] > target) break;\n                            if (x + y + nums[n - 2] + nums[n - 1] < target) continue;\n                            int c = b + 1, d = n - 1;\n                            while (c < d) { \n                                long long s = x + y + nums[c] + nums[d];\n                                if (s > target) d--;\n                                else if (s < target) c++;\n                                else { // s == target\n                                    ans.push_back({(int) x, (int) y, nums[c], nums[d]});\n                                    for (c++; c < d && nums[c] == nums[c - 1]; c++);\n                                    for (d--; d > c && nums[d] == nums[d + 1]; d--);\n                                }\n                            }\n                        }\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<vector<int>> fourSum(vector<int>& nums, int target) {\n                    int n = nums.size();\n                    vector<vector<int>> ans;\n                    if (n < 4) {\n                        return ans;\n                    }\n                    sort(nums.begin(), nums.end());\n                    for (int i = 0; i < n - 3; ++i) {\n                        if (i && nums[i] == nums[i - 1]) {\n                            continue;\n                        }\n                        for (int j = i + 1; j < n - 2; ++j) {\n                            if (j > i + 1 && nums[j] == nums[j - 1]) {\n                                continue;\n                            }\n                            int k = j + 1, l = n - 1;\n                            while (k < l) {\n                                long long x = (long long) nums[i] + nums[j] + nums[k] + nums[l];\n                                if (x < target) {\n                                    ++k;\n                                } else if (x > target) {\n                                    --l;\n                                } else {\n                                    ans.push_back({nums[i], nums[j], nums[k++], nums[l--]});\n                                    while (k < l && nums[k] == nums[k - 1]) {\n                                        ++k;\n                                    }\n                                    while (k < l && nums[l] == nums[l + 1]) {\n                                        --l;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    return ans;\n                }\n            };\n        "]
    },
    {
        "id":16,
        "description":"\n        Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\nAn input string is valid if:\n\nOpen brackets must be closed by the same type of brackets.\nOpen brackets must be closed in the correct order.\nEvery close bracket has a corresponding open bracket of the same type.\n \n\nExample 1:\n\nInput: s = \"()\"\nOutput: true\nExample 2:\n\nInput: s = \"()[]{}\"\nOutput: true\nExample 3:\n\nInput: s = \"(]\"\nOutput: false\n \n\nConstraints:\n\n1 <= s.length <= 10^4\ns consists of parentheses only '()[]{}'.\n        ",
        "tag":["Stack","String"],
        "answer":["\n        class Solution {\n            public:\n                bool isValid(string s) {\n                    int n = s.size();\n                    if (n % 2 == 1) {\n                        return false;\n                    }\n            \n                    unordered_map<char, char> pairs = {\n                        {')', '('},\n                        {']', '['},\n                        {'}', '{'}\n                    };\n                    stack<char> stk;\n                    for (char ch: s) {\n                        if (pairs.count(ch)) {\n                            if (stk.empty() || stk.top() != pairs[ch]) {\n                                return false;\n                            }\n                            stk.pop();\n                        }\n                        else {\n                            stk.push(ch);\n                        }\n                    }\n                    return stk.empty();\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool isValid(string s) {\n                    unordered_map<char,int> m{{'(',1},{'[',2},{'{',3},\n                                            {')',4},{']',5},{'}',6}};\n                    stack<char> st;\n                    bool istrue=true;\n                    for(char c:s){\n                        int flag=m[c];\n                        if(flag>=1&&flag<=3) st.push(c);\n                        else if(!st.empty()&&m[st.top()]==flag-3) st.pop();\n                        else {istrue=false;break;}\n                    }\n                    if(!st.empty()) istrue=false;\n                    return istrue;\n                }\n            };\n        ","\n        class Solution {\n            public: \n            bool isValid(string s) {\n                int n = s.length();\n                int top = -1;\n                string s1;\n                if( n % 2 != 0 || s[0] == '}' || s[0] == ')' || s[0] == ']') return false;\n                for (int i = 0; i < n; i++)\n                {\n                    if (s[i] == '{' || s[i] == '(' || s[i] == '[')\n                    {\n                        s1.push_back(s[i]);\n                        top++;\n                    }\n                    if(s1 ==\"\" &&  i < n) return false;\n                    if (s[i] == '}' || s[i] == ']')\n                    {\n                        if (s1[top] + 2 == s[i])\n                        {\n                            s1.pop_back();\n                            top--;\n                        }\n                        else \n                        return false;\n                    }\n                    \n                    if (s[i] == ')')\n                    {\n                        if (s1[top] + 1 == s[i])\n                        {\n                            s1.pop_back();\n                            top--;\n                        }\n                        else\n                        return false;\n                    }\n                    \n                }\n                return s1 == \"\";\n            }\n            };\n        ","\n        class Solution {\n            public:\n                bool isValid(string s) {\n                    stack<char>Q;\n                    for (int i = 0; i < s.size(); i++)\n                    {\n                        char ch = s[i];\n                        if(Q.empty() || ch == '(' || ch == '[' || ch == '{')\n                        {\n                            Q.push(ch);\n                        }\n                        else\n                        {\n                            char last = Q.top();\n                            int now = abs(last - ch);\n                            if(now > 2 || now == 0)\n                                return false;\n                            Q.pop();\n                        }\n                    }\n                    if(!Q.empty())\n                        return false;\n                    return true;\n                }\n            };\n        "]
    },
    {
        "id":17,
        "description":"\n        Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.\n\n \n\nExample 1:\n\nInput: n = 3\nOutput: [\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]\nExample 2:\n\nInput: n = 1\nOutput: [\"()\"]\n \n\nConstraints:\n\n1 <= n <= 8\n        ",
        "tag":["String","Dynamic Programming","Backtracking"],
        "answer":["\n        class Solution {\n            bool valid(const string& str) {\n                int balance = 0;\n                for (char c : str) {\n                    if (c == '(') {\n                        ++balance;\n                    } else {\n                        --balance;\n                    }\n                    if (balance < 0) {\n                        return false;\n                    }\n                }\n                return balance == 0;\n            }\n        \n            void generate_all(string& current, int n, vector<string>& result) {\n                if (n == current.size()) {\n                    if (valid(current)) {\n                        result.push_back(current);\n                    }\n                    return;\n                }\n                current += '(';\n                generate_all(current, n, result);\n                current.pop_back();\n                current += ')';\n                generate_all(current, n, result);\n                current.pop_back();\n            }\n        public:\n            vector<string> generateParenthesis(int n) {\n                vector<string> result;\n                string current;\n                generate_all(current, n * 2, result);\n                return result;\n            }\n        };\n        ","\n        class Solution {\n            void backtrack(vector<string>& ans, string& cur, int open, int close, int n) {\n                if (cur.size() == n * 2) {\n                    ans.push_back(cur);\n                    return;\n                }\n                if (open < n) {\n                    cur.push_back('(');\n                    backtrack(ans, cur, open + 1, close, n);\n                    cur.pop_back();\n                }\n                if (close < open) {\n                    cur.push_back(')');\n                    backtrack(ans, cur, open, close + 1, n);\n                    cur.pop_back();\n                }\n            }\n        public:\n            vector<string> generateParenthesis(int n) {\n                vector<string> result;\n                string current;\n                backtrack(result, current, 0, 0, n);\n                return result;\n            }\n        };\n        ","\n        class Solution {\n            shared_ptr<vector<string>> cache[100] = {nullptr};\n        public:\n            shared_ptr<vector<string>> generate(int n) {\n                if (cache[n] != nullptr)\n                    return cache[n];\n                if (n == 0) {\n                    cache[0] = shared_ptr<vector<string>>(new vector<string>{\"\"});\n                } else {\n                    auto result = shared_ptr<vector<string>>(new vector<string>);\n                    for (int i = 0; i != n; ++i) {\n                        auto lefts = generate(i);\n                        auto rights = generate(n - i - 1);\n                        for (const string& left : *lefts)\n                            for (const string& right : *rights)\n                                result -> push_back(\"(\" + left + \")\" + right);\n                    }\n                    cache[n] = result;\n                }\n                return cache[n];\n            }\n            vector<string> generateParenthesis(int n) {\n                return *generate(n);\n            }\n        };\n        "]
    },
    {
        "id":18,
        "description":"\n        You are given an array of k linked-lists lists, each linked-list is sorted in ascending order.\n\nMerge all the linked-lists into one sorted linked-list and return it.\n\n \n\nExample 1:\n\nInput: lists = [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]\nExplanation: The linked-lists are:\n[\n  1->4->5,\n  1->3->4,\n  2->6\n]\nmerging them into one sorted list:\n1->1->2->3->4->4->5->6\nExample 2:\n\nInput: lists = []\nOutput: []\nExample 3:\n\nInput: lists = [[]]\nOutput: []\n \n\nConstraints:\n\nk == lists.length\n0 <= k <= 10^4\n0 <= lists[i].length <= 500\n-10^4 <= lists[i][j] <= 10^4\nlists[i] is sorted in ascending order.\nThe sum of lists[i].length will not exceed 10^4.\n        ",
        "tag":["Linked List","Divide and Conquer","Heap (Priority Queue)","Merge Sort"],
        "answer":["\n        class Solution {\n            public:\n                ListNode* mergeTwoLists(ListNode *a, ListNode *b) {\n                    if ((!a) || (!b)) return a ? a : b;\n                    ListNode head, *tail = &head, *aPtr = a, *bPtr = b;\n                    while (aPtr && bPtr) {\n                        if (aPtr->val < bPtr->val) {\n                            tail->next = aPtr; aPtr = aPtr->next;\n                        } else {\n                            tail->next = bPtr; bPtr = bPtr->next;\n                        }\n                        tail = tail->next;\n                    }\n                    tail->next = (aPtr ? aPtr : bPtr);\n                    return head.next;\n                }\n            \n                ListNode* merge(vector <ListNode*> &lists, int l, int r) {\n                    if (l == r) return lists[l];\n                    if (l > r) return nullptr;\n                    int mid = (l + r) >> 1;\n                    return mergeTwoLists(merge(lists, l, mid), merge(lists, mid + 1, r));\n                }\n            \n                ListNode* mergeKLists(vector<ListNode*>& lists) {\n                    return merge(lists, 0, lists.size() - 1);\n                }\n            };\n        ","\n        class Solution {\n            public:\n                ListNode* mergeTwoLists(ListNode *a, ListNode *b) {\n                    if ((!a) || (!b)) return a ? a : b;\n                    ListNode head, *tail = &head, *aPtr = a, *bPtr = b;\n                    while (aPtr && bPtr) {\n                        if (aPtr->val < bPtr->val) {\n                            tail->next = aPtr; aPtr = aPtr->next;\n                        } else {\n                            tail->next = bPtr; bPtr = bPtr->next;\n                        }\n                        tail = tail->next;\n                    }\n                    tail->next = (aPtr ? aPtr : bPtr);\n                    return head.next;\n                }\n            \n                ListNode* mergeKLists(vector<ListNode*>& lists) {\n                    ListNode *ans = nullptr;\n                    for (size_t i = 0; i < lists.size(); ++i) {\n                        ans = mergeTwoLists(ans, lists[i]);\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                struct Status {\n                    int val;\n                    ListNode *ptr;\n                    bool operator < (const Status &rhs) const {\n                        return val > rhs.val;\n                    }\n                };\n            \n                priority_queue <Status> q;\n            \n                ListNode* mergeKLists(vector<ListNode*>& lists) {\n                    for (auto node: lists) {\n                        if (node) q.push({node->val, node});\n                    }\n                    ListNode head, *tail = &head;\n                    while (!q.empty()) {\n                        auto f = q.top(); q.pop();\n                        tail->next = f.ptr; \n                        tail = tail->next;\n                        if (f.ptr->next) q.push({f.ptr->next->val, f.ptr->next});\n                    }\n                    return head.next;\n                }\n            };\n        "]
    },
    {
        "id":19,
        "description":"\n        Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.\n\nConsider the number of unique elements of nums to be k, to get accepted, you need to do the following things:\n\nChange the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums.\nReturn k.\nCustom Judge:\n\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\nIf all assertions pass, then your solution will be accepted.\n\n \n\nExample 1:\n\nInput: nums = [1,1,2]\nOutput: 2, nums = [1,2,_]\nExplanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\nExample 2:\n\nInput: nums = [0,0,1,1,1,2,2,3,3,4]\nOutput: 5, nums = [0,1,2,3,4,_,_,_,_,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n \n\nConstraints:\n\n1 <= nums.length <= 3 * 10^4\n-100 <= nums[i] <= 100\nnums is sorted in non-decreasing order.\n        ",
        "tag":["Array","Two Pointers"],
        "answer":["\n        class Solution {\n            public:\n                int removeDuplicates(vector<int>& nums) {\n                    int n = nums.size();\n                    if (n == 0) {\n                        return 0;\n                    }\n                    int fast = 1, slow = 1;\n                    while (fast < n) {\n                        if (nums[fast] != nums[fast - 1]) {\n                            nums[slow] = nums[fast];\n                            ++slow;\n                        }\n                        ++fast;\n                    }\n                    return slow;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int removeDuplicates(vector<int>& nums) {\n                    int length = nums.size();\n                    if (length == 0) return 0;\n                    int slow = 0, fast = 1;\n                    while (fast < length) {\n                        if (nums[fast] != nums[slow]) {\n                            nums[++slow] = nums[fast];\n                        }\n                        fast++;\n                    }\n                    return slow + 1;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int removeDuplicates(vector<int>& nums) {\n                    set<int> ans;\n                    for (auto &i : nums) {\n                        ans.emplace(i);\n                    }\n                    nums.clear();\n                    vector<int> tmp(ans.begin(), ans.end());\n                    nums = tmp;\n                    return nums.size();\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int removeDuplicates(vector<int>& nums) {\n                    int left = 0;\n                    for (int right = 0; right < nums.size(); ++right) {\n                        if (nums[left] != nums[right]) {\n                            nums[left + 1] = nums[right];\n                            ++left;\n                        }\n                    }\n                    return left + 1;\n                }\n            };\n        "]
    },
    {
        "id":20,
        "description":"\n        Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.\n\nConsider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:\n\nChange the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums.\nReturn k.\nCustom Judge:\n\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint val = ...; // Value to remove\nint[] expectedNums = [...]; // The expected answer with correct length.\n                            // It is sorted with no values equaling val.\n\nint k = removeElement(nums, val); // Calls your implementation\n\nassert k == expectedNums.length;\nsort(nums, 0, k); // Sort the first k elements of nums\nfor (int i = 0; i < actualLength; i++) {\n    assert nums[i] == expectedNums[i];\n}\nIf all assertions pass, then your solution will be accepted.\n\n \n\nExample 1:\n\nInput: nums = [3,2,2,3], val = 3\nOutput: 2, nums = [2,2,_,_]\nExplanation: Your function should return k = 2, with the first two elements of nums being 2.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\nExample 2:\n\nInput: nums = [0,1,2,2,3,0,4,2], val = 2\nOutput: 5, nums = [0,1,4,0,3,_,_,_]\nExplanation: Your function should return k = 5, with the first five elements of nums containing 0, 0, 1, 3, and 4.\nNote that the five elements can be returned in any order.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n \n\nConstraints:\n\n0 <= nums.length <= 100\n0 <= nums[i] <= 50\n0 <= val <= 100\n        ",
        "tag":["Array","Two Pointers"],
        "answer":["\n        class Solution {\n            public:\n                int removeElement(vector<int>& nums, int val) {\n                    int n = nums.size();\n                    int left = 0;\n                    for (int right = 0; right < n; right++) {\n                        if (nums[right] != val) {\n                            nums[left] = nums[right];\n                            left++;\n                        }\n                    }\n                    return left;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int removeElement(vector<int>& nums, int val) {\n                    int left = 0, right = nums.size();\n                    while (left < right) {\n                        if (nums[left] == val) {\n                            nums[left] = nums[right - 1];\n                            right--;\n                        } else {\n                            left++;\n                        }\n                    }\n                    return left;\n                }\n            };\n        ","\n        \nclass Solution {\n    public:\n        int removeElement(vector<int>& nums, int val) {\n                    int left,right;\n                    left = 0;\n                    right =nums.size() - 1;\n                    while(left <= right)\n                    {\n                        if(nums[left] == val){\n                            nums[left] = nums[right];\n                            right --;\n                        }\n                        if(nums[left] != val)\n                            left ++;\n                    }\n                    return right + 1;\n    \n        }\n    };\n        "]
    },
    {
        "id":21,
        "description":"\n        Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\n\n \n\nExample 1:\n\nInput: haystack = \"sadbutsad\", needle = \"sad\"\nOutput: 0\nExplanation: \"sad\" occurs at index 0 and 6.\nThe first occurrence is at index 0, so we return 0.\nExample 2:\n\nInput: haystack = \"leetcode\", needle = \"leeto\"\nOutput: -1\nExplanation: \"leeto\" did not occur in \"leetcode\", so we return -1.\n \n\nConstraints:\n\n1 <= haystack.length, needle.length <= 10^4\nhaystack and needle consist of only lowercase English characters.\n        ",
        "tag":["Two Pointers","String","String Matching"],
        "answer":["\n        class Solution {\n            public:\n                int strStr(string haystack, string needle) {\n                    int n = haystack.size(), m = needle.size();\n                    for (int i = 0; i + m <= n; i++) {\n                        bool flag = true;\n                        for (int j = 0; j < m; j++) {\n                            if (haystack[i + j] != needle[j]) {\n                                flag = false;\n                                break;\n                            }\n                        }\n                        if (flag) {\n                            return i;\n                        }\n                    }\n                    return -1;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int strStr(string haystack, string needle) {\n                    int n = haystack.size(), m = needle.size();\n                    if (m == 0) {\n                        return 0;\n                    }\n                    vector<int> pi(m);\n                    for (int i = 1, j = 0; i < m; i++) {\n                        while (j > 0 && needle[i] != needle[j]) {\n                            j = pi[j - 1];\n                        }\n                        if (needle[i] == needle[j]) {\n                            j++;\n                        }\n                        pi[i] = j;\n                    }\n                    for (int i = 0, j = 0; i < n; i++) {\n                        while (j > 0 && haystack[i] != needle[j]) {\n                            j = pi[j - 1];\n                        }\n                        if (haystack[i] == needle[j]) {\n                            j++;\n                        }\n                        if (j == m) {\n                            return i - m + 1;\n                        }\n                    }\n                    return -1;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                void getNext(int* next, const string& s) {\n                    int j = 0;\n                    next[0] = 0;\n                    for(int i = 1; i < s.size(); i++) {\n                        while (j > 0 && s[i] != s[j]) {\n                            j = next[j - 1];\n                        }\n                        if (s[i] == s[j]) {\n                            j++;\n                        }\n                        next[i] = j;\n                    }\n                }\n                int strStr(string haystack, string needle) {\n                    if (needle.size() == 0) {\n                        return 0;\n                    }\n                    int next[needle.size()];\n                    getNext(next, needle);\n                    int j = 0;\n                    for (int i = 0; i < haystack.size(); i++) {\n                        while(j > 0 && haystack[i] != needle[j]) {\n                            j = next[j - 1];\n                        }\n                        if (haystack[i] == needle[j]) {\n                            j++;\n                        }\n                        if (j == needle.size() ) {\n                            return (i - needle.size() + 1);\n                        }\n                    }\n                    return -1;\n                }\n            };\n        "]
    },
    {
        "id":22,
        "description":"\n        Given two integers dividend and divisor, divide two integers without using multiplication, division, and mod operator.\n\nThe integer division should truncate toward zero, which means losing its fractional part. For example, 8.345 would be truncated to 8, and -2.7335 would be truncated to -2.\n\nReturn the quotient after dividing dividend by divisor.\n\nNote: Assume we are dealing with an environment that could only store integers within the 32-bit signed integer range: [−2^31, 2^31 − 1]. For this problem, if the quotient is strictly greater than 2^31 - 1, then return 2^31 - 1, and if the quotient is strictly less than -2^31, then return -2^31.\n\n \n\nExample 1:\n\nInput: dividend = 10, divisor = 3\nOutput: 3\nExplanation: 10/3 = 3.33333.. which is truncated to 3.\nExample 2:\n\nInput: dividend = 7, divisor = -3\nOutput: -2\nExplanation: 7/-3 = -2.33333.. which is truncated to -2.\n \n\nConstraints:\n\n-2^31 <= dividend, divisor <= 2^31 - 1\ndivisor != 0\n        ",
        "tag":["Bit Manipulation","Math"],
        "answer":["\n        class Solution {\n            public:\n                int divide(int dividend, int divisor) {\n                    if (dividend == INT_MIN) {\n                        if (divisor == 1) {\n                            return INT_MIN;\n                        }\n                        if (divisor == -1) {\n                            return INT_MAX;\n                        }\n                    }\n                    if (divisor == INT_MIN) {\n                        return dividend == INT_MIN ? 1 : 0;\n                    }\n                    if (dividend == 0) {\n                        return 0;\n                    }\n                    \n                    bool rev = false;\n                    if (dividend > 0) {\n                        dividend = -dividend;\n                        rev = !rev;\n                    }\n                    if (divisor > 0) {\n                        divisor = -divisor;\n                        rev = !rev;\n                    }\n            \n                    auto quickAdd = [](int y, int z, int x) {\n                        int result = 0, add = y;\n                        while (z) {\n                            if (z & 1) {\n                                if (result < x - add) {\n                                    return false;\n                                }\n                                result += add;\n                            }\n                            if (z != 1) {\n                                if (add < x - add) {\n                                    return false;\n                                }\n                                add += add;\n                            }\n                            z >>= 1;\n                        }\n                        return true;\n                    };\n                    \n                    int left = 1, right = INT_MAX, ans = 0;\n                    while (left <= right) {\n                        int mid = left + ((right - left) >> 1);\n                        bool check = quickAdd(divisor, mid, dividend);\n                        if (check) {\n                            ans = mid;\n                            if (mid == INT_MAX) {\n                                break;\n                            }\n                            left = mid + 1;\n                        }\n                        else {\n                            right = mid - 1;\n                        }\n                    }\n            \n                    return rev ? -ans : ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int divide(int dividend, int divisor) {\n                    if (dividend == INT_MIN) {\n                        if (divisor == 1) {\n                            return INT_MIN;\n                        }\n                        if (divisor == -1) {\n                            return INT_MAX;\n                        }\n                    }\n                    if (divisor == INT_MIN) {\n                        return dividend == INT_MIN ? 1 : 0;\n                    }\n                    if (dividend == 0) {\n                        return 0;\n                    }\n                    \n                    bool rev = false;\n                    if (dividend > 0) {\n                        dividend = -dividend;\n                        rev = !rev;\n                    }\n                    if (divisor > 0) {\n                        divisor = -divisor;\n                        rev = !rev;\n                    }\n            \n                    vector<int> candidates = {divisor};\n                    while (candidates.back() >= dividend - candidates.back()) {\n                        candidates.push_back(candidates.back() + candidates.back());\n                    }\n                    int ans = 0;\n                    for (int i = candidates.size() - 1; i >= 0; --i) {\n                        if (candidates[i] >= dividend) {\n                            ans += (1 << i);\n                            dividend -= candidates[i];\n                        }\n                    }\n            \n                    return rev ? -ans : ans;\n                }\n            };\n        ","\n        int divide(int a, int b) {\n            if (a == INT_MIN && b == -1) return INT_MAX;\n        \n                int sign = (a > 0) ^ (b > 0) ? -1 : 1;\n        \n                if (a > 0) a = -a;\n                if (b > 0) b = -b;\n                \n                int res = 0;\n                while (a <= b) {\n                    int value = b;\n                    int k = 1;\n                    while (value >= 0xc0000000 && a <= value + value) {\n                        value += value;\n                        if (k > INT_MAX / 2) return INT_MIN;\n                        k += k;\n                    }\n                    a -= value;\n                    res += k;\n                }\n        \n                return sign == 1 ? res : -res;\n        }\n        "]
    },
    {
        "id":23,
        "description":"\n        You are given a string s and an array of strings words. All the strings of words are of the same length.\n\nA concatenated substring in s is a substring that contains all the strings of any permutation of words concatenated.\n\nFor example, if words = [\"ab\",\"cd\",\"ef\"], then \"abcdef\", \"abefcd\", \"cdabef\", \"cdefab\", \"efabcd\", and \"efcdab\" are all concatenated strings. \"acdbef\" is not a concatenated substring because it is not the concatenation of any permutation of words.\nReturn the starting indices of all the concatenated substrings in s. You can return the answer in any order.\n\n \n\nExample 1:\n\nInput: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\nOutput: [0,9]\nExplanation: Since words.length == 2 and words[i].length == 3, the concatenated substring has to be of length 6.\nThe substring starting at 0 is \"barfoo\". It is the concatenation of [\"bar\",\"foo\"] which is a permutation of words.\nThe substring starting at 9 is \"foobar\". It is the concatenation of [\"foo\",\"bar\"] which is a permutation of words.\nThe output order does not matter. Returning [9,0] is fine too.\nExample 2:\n\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\nOutput: []\nExplanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\nThere is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\nWe return an empty array.\nExample 3:\n\nInput: s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\nOutput: [6,9,12]\nExplanation: Since words.length == 3 and words[i].length == 3, the concatenated substring has to be of length 9.\nThe substring starting at 6 is \"foobarthe\". It is the concatenation of [\"foo\",\"bar\",\"the\"] which is a permutation of words.\nThe substring starting at 9 is \"barthefoo\". It is the concatenation of [\"bar\",\"the\",\"foo\"] which is a permutation of words.\nThe substring starting at 12 is \"thefoobar\". It is the concatenation of [\"the\",\"foo\",\"bar\"] which is a permutation of words.\n \n\nConstraints:\n\n1 <= s.length <= 10^4\n1 <= words.length <= 5000\n1 <= words[i].length <= 30\ns and words[i] consist of lowercase English letters.\n        ",
        "tag":["Hash Table","String","Sliding Window"],
        "answer":["\n        class Solution {\n            public:\n                vector<int> findSubstring(string &s, vector<string> &words) {\n                    vector<int> res;\n                    int m = words.size(), n = words[0].size(), ls = s.size();\n                    for (int i = 0; i < n && i + m * n <= ls; ++i) {\n                        unordered_map<string, int> differ;\n                        for (int j = 0; j < m; ++j) {\n                            ++differ[s.substr(i + j * n, n)];\n                        }\n                        for (string &word: words) {\n                            if (--differ[word] == 0) {\n                                differ.erase(word);\n                            }\n                        }\n                        for (int start = i; start < ls - m * n + 1; start += n) {\n                            if (start != i) {\n                                string word = s.substr(start + (m - 1) * n, n);\n                                if (++differ[word] == 0) {\n                                    differ.erase(word);\n                                }\n                                word = s.substr(start - n, n);\n                                if (--differ[word] == 0) {\n                                    differ.erase(word);\n                                }\n                            }\n                            if (differ.empty()) {\n                                res.emplace_back(start);\n                            }\n                        }\n                    }\n                    return res;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<int> findSubstring(string s, vector<string>& words) {\n                    vector<int> res;\n                    int n = s.size(), m = words.size(), d = words[0].size();\n                    int len = 0;\n                    unordered_map<string, int> um;\n                    for (string w : words) {\n                        len += w.size();\n                        um[w]++;\n                    }\n            \n                    vector<unordered_map<string, int> > vu(d);\n                    for (int i = 0; i < d && i + len <= n; i++) {\n                        for (int j = i; j < i + len; j += d) {\n                            string w = s.substr(j, d);\n                            vu[i][w]++;\n                        }\n                        if (vu[i] == um) {\n                            res.emplace_back(i);\n                        }\n                    }\n            \n                    for (int i = d; i + len <= n; i++) {\n                        int r = i % d;\n                        string wa = s.substr(i - d, d), wb = s.substr(i + len - d, d);\n                        if(--vu[r][wa] == 0) vu[r].erase(wa);\n                        vu[r][wb]++;\n                        if (vu[r] == um) {\n                            res.emplace_back(i);\n                        }\n                    }\n            \n                    return res;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<int> findSubstring(string s, vector<string>& words) {\n                    vector<int> res;\n                    unordered_map<string, int> search;\n                    for (auto &word : words) ++search[word];\n                    int n = s.size(), m = words.size(), len = words[0].size();\n                    for (int i = 0, j = 0; i < n - m * len + 1; ++i) {\n                        unordered_map<string, int> sub; \n                        for (j = 0; j < m; ++j) {\n                            auto word = s.substr(i + j * len, len);\n                            if (!search.count(word)) break;\n                            if (++sub[word] > search[word]) break;\n                        }\n                        if (j == m) res.push_back(i);\n                    }\n                    return res;\n                }\n            };\n        "]
    },
    {
        "id":24,
        "description":"\n        A permutation of an array of integers is an arrangement of its members into a sequence or linear order.\n\nFor example, for arr = [1,2,3], the following are all the permutations of arr: [1,2,3], [1,3,2], [2, 1, 3], [2, 3, 1], [3,1,2], [3,2,1].\nThe next permutation of an array of integers is the next lexicographically greater permutation of its integer. More formally, if all the permutations of the array are sorted in one container according to their lexicographical order, then the next permutation of that array is the permutation that follows it in the sorted container. If such arrangement is not possible, the array must be rearranged as the lowest possible order (i.e., sorted in ascending order).\n\nFor example, the next permutation of arr = [1,2,3] is [1,3,2].\nSimilarly, the next permutation of arr = [2,3,1] is [3,1,2].\nWhile the next permutation of arr = [3,2,1] is [1,2,3] because [3,2,1] does not have a lexicographical larger rearrangement.\nGiven an array of integers nums, find the next permutation of nums.\n\nThe replacement must be in place and use only constant extra memory.\n\n \n\nExample 1:\n\nInput: nums = [1,2,3]\nOutput: [1,3,2]\nExample 2:\n\nInput: nums = [3,2,1]\nOutput: [1,2,3]\nExample 3:\n\nInput: nums = [1,1,5]\nOutput: [1,5,1]\n \n\nConstraints:\n\n1 <= nums.length <= 100\n0 <= nums[i] <= 100\n        ",
        "tag":["Array","Two Pointers"],
        "answer":["\n        class Solution {\n            public:\n                void nextPermutation(vector<int>& nums) {\n                    int i = nums.size() - 2;\n                    while (i >= 0 && nums[i] >= nums[i + 1]) {\n                        i--;\n                    }\n                    if (i >= 0) {\n                        int j = nums.size() - 1;\n                        while (j >= 0 && nums[i] >= nums[j]) {\n                            j--;\n                        }\n                        swap(nums[i], nums[j]);\n                    }\n                    reverse(nums.begin() + i + 1, nums.end());\n                }\n            };\n        ","\n        class Solution {\n            private:\n                int findp(vector<int>& nums, int left, int right, int& target){\n                    while(left <= right){\n                        int mid = left + (right - left) / 2;\n                        if(nums[mid] <= target) right = mid - 1;\n                        else  left = mid + 1;\n                    }\n                    return right;\n                }\n            public:\n                void nextPermutation(vector<int>& nums) {\n                    int n = nums.size();\n                    if(n < 2) return;\n                    int p = n - 2;\n                    while(p >= 0){\n                        if(nums[p] >= nums[p + 1]) {\n                            p--;\n                            continue;\n                        }\n                        else break;\n                    }\n                    if(p == -1){\n                        reverse(nums.begin(), nums.end());\n                        return;\n                    }\n                    int q = findp(nums, p + 1, n - 1, nums[p]);\n                    int tmp = nums[p];\n                    nums[p] = nums[q];\n                    nums[q] = tmp;\n                    reverse(nums.begin() + (p + 1), nums.end());\n                    return;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                void nextPermutation(vector<int>& nums) {\n                    int cur=nums.size()-2;\n            \n                    while(cur>=0&&nums[cur]>=nums[cur+1])\n                    {\n                        cur--;\n                    }\n            \n                    if(cur<0)\n                        sort(nums.begin(),nums.end());\n                    else\n                    {\n                        int pos=nums.size()-1;\n                        while(nums[pos]<=nums[cur])\n                        {\n                            pos--;\n                        }\n            \n                        swap(nums[cur],nums[pos]);\n                        reverse(nums.begin()+cur+1,nums.end());\n                    }\n                    \n                }\n            };\n        ","\n        class Solution {\n            public:\n                void nextPermutation(vector<int>& nums) {\n                    int n = nums.size();\n                    if(n < 2) return;\n                    for(int i = nums.size()-2; i >= 0; i--){\n                        int poi;\n                        int nowMin;\n                        bool find = false;\n                        for(int j = i+1; j < n; j++){\n                            if(nums[j] > nums[i]){\n                                if(find == false){\n                                    find = true;\n                                    poi = j;\n                                    nowMin = nums[j];\n                                }   \n                                else{\n                                    if(nowMin > nums[j]){\n                                        poi = j;\n                                        nowMin = nums[j]; \n                                    }\n                                }\n                            }\n                        }\n                        if(find == true){\n                            nums[poi] = nums[i];\n                            nums[i] = nowMin;\n                            sort(nums.begin()+i+1,nums.end());\n                            return;\n                        }\n                    }\n                    sort(nums.begin(),nums.end());\n                }\n            };\n        "]
    },
    {
        "id":25,
        "description":"\n        Given a string containing just the characters '(' and ')', return the length of the longest valid (well-formed) parentheses \nsubstring\n.\n\n \n\nExample 1:\n\nInput: s = \"(()\"\nOutput: 2\nExplanation: The longest valid parentheses substring is \"()\".\nExample 2:\n\nInput: s = \")()())\"\nOutput: 4\nExplanation: The longest valid parentheses substring is \"()()\".\nExample 3:\n\nInput: s = \"\"\nOutput: 0\n \n\nConstraints:\n\n0 <= s.length <= 3 * 10^4\ns[i] is '(', or ')'.\n        ",
        "tag":["Stack","String","Dynamic Programming"],
        "answer":["\n        class Solution {\n            public:\n                int longestValidParentheses(string s) {\n                    int maxans = 0, n = s.length();\n                    vector<int> dp(n, 0);\n                    for (int i = 1; i < n; i++) {\n                        if (s[i] == ')') {\n                            if (s[i - 1] == '(') {\n                                dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;\n                            } else if (i - dp[i - 1] > 0 && s[i - dp[i - 1] - 1] == '(') {\n                                dp[i] = dp[i - 1] + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;\n                            }\n                            maxans = max(maxans, dp[i]);\n                        }\n                    }\n                    return maxans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int longestValidParentheses(string s) {\n                    int maxans = 0;\n                    stack<int> stk;\n                    stk.push(-1);\n                    for (int i = 0; i < s.length(); i++) {\n                        if (s[i] == '(') {\n                            stk.push(i);\n                        } else {\n                            stk.pop();\n                            if (stk.empty()) {\n                                stk.push(i);\n                            } else {\n                                maxans = max(maxans, i - stk.top());\n                            }\n                        }\n                    }\n                    return maxans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int longestValidParentheses(string s) {\n                    int left = 0, right = 0, maxlength = 0;\n                    for (int i = 0; i < s.length(); i++) {\n                        if (s[i] == '(') {\n                            left++;\n                        } else {\n                            right++;\n                        }\n                        if (left == right) {\n                            maxlength = max(maxlength, 2 * right);\n                        } else if (right > left) {\n                            left = right = 0;\n                        }\n                    }\n                    left = right = 0;\n                    for (int i = (int)s.length() - 1; i >= 0; i--) {\n                        if (s[i] == '(') {\n                            left++;\n                        } else {\n                            right++;\n                        }\n                        if (left == right) {\n                            maxlength = max(maxlength, 2 * left);\n                        } else if (left > right) {\n                            left = right = 0;\n                        }\n                    }\n                    return maxlength;\n                }\n            };\n        "]
    },
    {
        "id":26,
        "description":"\n        There is an integer array nums sorted in ascending order (with distinct values).\n\nPrior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\n\nGiven the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\n\nYou must write an algorithm with O(log n) runtime complexity.\n\n \n\nExample 1:\n\nInput: nums = [4,5,6,7,0,1,2], target = 0\nOutput: 4\nExample 2:\n\nInput: nums = [4,5,6,7,0,1,2], target = 3\nOutput: -1\nExample 3:\n\nInput: nums = [1], target = 0\nOutput: -1\n \n\nConstraints:\n\n1 <= nums.length <= 5000\n-10^4 <= nums[i] <= 10^4\nAll values of nums are unique.\nnums is an ascending array that is possibly rotated.\n-10^4 <= target <= 10^4\n        ",
        "tag":["Array","Binary Search"],
        "answer":["\n        class Solution {\n            public:\n                int search(vector<int>& nums, int target) {\n                    int n = (int)nums.size();\n                    if (!n) {\n                        return -1;\n                    }\n                    if (n == 1) {\n                        return nums[0] == target ? 0 : -1;\n                    }\n                    int l = 0, r = n - 1;\n                    while (l <= r) {\n                        int mid = (l + r) / 2;\n                        if (nums[mid] == target) return mid;\n                        if (nums[0] <= nums[mid]) {\n                            if (nums[0] <= target && target < nums[mid]) {\n                                r = mid - 1;\n                            } else {\n                                l = mid + 1;\n                            }\n                        } else {\n                            if (nums[mid] < target && target <= nums[n - 1]) {\n                                l = mid + 1;\n                            } else {\n                                r = mid - 1;\n                            }\n                        }\n                    }\n                    return -1;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int search(vector<int>& nums, int target) {\n                    int lo = 0, hi = nums.size() - 1;\n                    while (lo < hi) {\n                        int mid = (lo + hi) / 2;\n                        if ((nums[0] > target) ^ (nums[0] > nums[mid]) ^ (target > nums[mid]))\n                            lo = mid + 1;\n                        else\n                            hi = mid;\n                    }\n                    return lo == hi && nums[lo] == target ? lo : -1;\n                }\n            };\n        ","\n        class Solution {\n\n            public:\n                int result = 0;\n                int mid = 0;\n                int findOrder(int m, int n, vector<int>& nums, int target){\n                    if(m == n){\n                        if(target == nums[m]) return m;\n                        else return -1;\n                    }\n                    mid = (m+n)/2;\n                    if(target<=nums[mid]){\n                        result = findOrder(m,mid,nums,target);\n                    }\n                    else{\n                        result = findOrder(mid+1,n,nums,target);\n                    }\n                    return result;\n                }\n                int findDisOrder(int m, int n, vector<int>& nums, int target){\n                    if(m == n){\n                        if(target == nums[m]) return m;\n                        else return -1;\n                    }\n                    mid = (m+n)/2;\n                    if(nums[m] <= nums[mid]){\n                        if(nums[m] <= target && target <= nums[mid]){\n                            result = findOrder(m,mid,nums,target);\n                        }\n                        else{\n                            result = findDisOrder(mid+1,n,nums,target);\n                        }\n                    }\n                    else{\n                        if(nums[mid+1] <= target && target <= nums[n]){\n                            result = findOrder(mid+1,n,nums,target);\n                        }\n                        else{\n                            result = findDisOrder(m,mid,nums,target);\n                        }   \n                    }\n                    return result;\n                }\n                int search(vector<int>& nums, int target) {\n                    int len = nums.size(), i = 0;\n                    return  findDisOrder(i,len-1,nums, target);\n                }\n            };\n        "]
    },
    {
        "id":27,
        "description":"\n        Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\n\nIf target is not found in the array, return [-1, -1].\n\nYou must write an algorithm with O(log n) runtime complexity.\n\n \n\nExample 1:\n\nInput: nums = [5,7,7,8,8,10], target = 8\nOutput: [3,4]\nExample 2:\n\nInput: nums = [5,7,7,8,8,10], target = 6\nOutput: [-1,-1]\nExample 3:\n\nInput: nums = [], target = 0\nOutput: [-1,-1]\n \n\nConstraints:\n\n0 <= nums.length <= 10^5\n-10^9 <= nums[i] <= 10^9\nnums is a non-decreasing array.\n-10^9 <= target <= 10^9\n        ",
        "tag":["Array","Binary Search"],
        "answer":["\n        class Solution { \npublic:\n    int binarySearch(vector<int>& nums, int target, bool lower) {\n        int left = 0, right = (int)nums.size() - 1, ans = (int)nums.size();\n        while (left <= right) {\n            int mid = (left + right) / 2;\n            if (nums[mid] > target || (lower && nums[mid] >= target)) {\n                right = mid - 1;\n                ans = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return ans;\n    }\n\n    vector<int> searchRange(vector<int>& nums, int target) {\n        int leftIdx = binarySearch(nums, target, true);\n        int rightIdx = binarySearch(nums, target, false) - 1;\n        if (leftIdx <= rightIdx && rightIdx < nums.size() && nums[leftIdx] == target && nums[rightIdx] == target) {\n            return vector<int>{leftIdx, rightIdx};\n        } \n        return vector<int>{-1, -1};\n    }\n};\n        ","\n        class Solution {\n            int lower_bound(vector<int> &nums, int target) {\n                int left = 0, right = (int) nums.size() - 1;\n                while (left <= right) {\n                    int mid = left + (right - left) / 2;\n                    if (nums[mid] < target)\n                        left = mid + 1;\n                    else\n                        right = mid - 1;\n                }\n                return left;\n            }\n        \n            int lower_bound2(vector<int> &nums, int target) {\n                int left = 0, right = nums.size();\n                while (left < right) {\n                    int mid = left + (right - left) / 2;\n                    if (nums[mid] < target)\n                        left = mid + 1;\n                    else\n                        right = mid;\n                }\n                return left;\n            }\n        \n            int lower_bound3(vector<int> &nums, int target) {\n                int left = -1, right = nums.size();\n                while (left + 1 < right) {\n                    int mid = left + (right - left) / 2;\n                    if (nums[mid] < target)\n                        left = mid;\n                    else\n                        right = mid;\n                }\n                return right;\n            }\n        \n        public:\n            vector<int> searchRange(vector<int> &nums, int target) {\n                int start = lower_bound(nums, target);\n                if (start == nums.size() || nums[start] != target)\n                    return {-1, -1};\n                int end = lower_bound(nums, target + 1) - 1;\n                return {start, end};\n            }\n        };\n        ","\n        class Solution {\n            public:\n                vector<int> searchRange(vector<int>& nums, int target) {\n                    if(nums.empty()) return {-1,-1};\n                \n                    int l = 0, r = nums.size() - 1;\n                    while( l < r)\n                    {\n                        int mid = (l + r )/2;\n                        if(nums[mid] >= target) r = mid;\n                        else l = mid + 1;\n                    }\n                    if( nums[r] != target) return {-1,-1};\n                    int L = r;\n                    l = 0, r = nums.size() - 1;\n                    while( l < r)\n                    {\n                        int mid = (l + r + 1)/2;\n                        if(nums[mid] <= target ) l = mid;\n                        else r = mid - 1;\n                    }\n                    return {L,r};\n                }\n            };\n        "]
    },
    {
        "id":28,
        "description":"\n        Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\n\nYou must write an algorithm with O(log n) runtime complexity.\n\n \n\nExample 1:\n\nInput: nums = [1,3,5,6], target = 5\nOutput: 2\nExample 2:\n\nInput: nums = [1,3,5,6], target = 2\nOutput: 1\nExample 3:\n\nInput: nums = [1,3,5,6], target = 7\nOutput: 4\n \n\nConstraints:\n\n1 <= nums.length <= 10^4\n-10^4 <= nums[i] <= 10^4\nnums contains distinct values sorted in ascending order.\n-10^4 <= target <= 10^4\n        ",
        "tag":["Array","Binary Search"],
        "answer":["\n        class Solution {\n            public:\n                int searchInsert(vector<int>& nums, int target) {\n                    int n = nums.size();\n                    int left = 0, right = n - 1, ans = n;\n                    while (left <= right) {\n                        int mid = ((right - left) >> 1) + left;\n                        if (target <= nums[mid]) {\n                            ans = mid;\n                            right = mid - 1;\n                        } else {\n                            left = mid + 1;\n                        }\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int searchInsert(vector<int>& nums, int target) {\n                    auto n = find(nums.begin(),nums.end(),target);\n                    if(n != nums.end())\n                    {\n                        return n - nums.begin();\n                    }\n                    else\n                    {\n                        return lower_bound(nums.begin(),nums.end(),target) - nums.begin();\n                    }\n                }\n            };\n        ","\n        \nclass Solution {\n    public:\n        int searchInsert(vector<int>& nums, int target) {\n            int n=nums.size();\n            int l=0,r=n-1,mid;\n            while(l<=r){\n                mid=(l+r)/2;\n                if (target>nums[mid]){\n                    l=mid+1;\n                    continue;\n                }\n                else if (target<nums[mid]){\n                    r=mid-1;\n                    continue;\n                }\n                else break;\n            }\n            if (l>r) return l;\n            else return mid;\n        }\n    };\n        "]
    },
    {
        "id":29,
        "description":"\n        Determine if a 9 x 9 Sudoku board is valid. Only the filled cells need to be validated according to the following rules:\n\nEach row must contain the digits 1-9 without repetition.\nEach column must contain the digits 1-9 without repetition.\nEach of the nine 3 x 3 sub-boxes of the grid must contain the digits 1-9 without repetition.\nNote:\n\nA Sudoku board (partially filled) could be valid but is not necessarily solvable.\nOnly the filled cells need to be validated according to the mentioned rules.\n \n\nExample 1:\n\n\nInput: board = \n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\nOutput: true\nExample 2:\n\nInput: board = \n[[\"8\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"]\n,[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"]\n,[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"]\n,[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"]\n,[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"]\n,[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"]\n,[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\nOutput: false\nExplanation: Same as Example 1, except with the 5 in the top left corner being modified to 8. Since there are two 8's in the top left 3x3 sub-box, it is invalid.\n \n\nConstraints:\n\nboard.length == 9\nboard[i].length == 9\nboard[i][j] is a digit 1-9 or '.'.\n        ",
        "tag":["Array","Hash Table","Matrix"],
        "answer":["\n        class Solution {\n            public:\n                bool isValidSudoku(vector<vector<char>>& board) {\n                    int rows[9][9];\n                    int columns[9][9];\n                    int subboxes[3][3][9];\n                    \n                    memset(rows,0,sizeof(rows));\n                    memset(columns,0,sizeof(columns));\n                    memset(subboxes,0,sizeof(subboxes));\n                    for (int i = 0; i < 9; i++) {\n                        for (int j = 0; j < 9; j++) {\n                            char c = board[i][j];\n                            if (c != '.') {\n                                int index = c - '0' - 1;\n                                rows[i][index]++;\n                                columns[j][index]++;\n                                subboxes[i / 3][j / 3][index]++;\n                                if (rows[i][index] > 1 || columns[j][index] > 1 || subboxes[i / 3][j / 3][index] > 1) {\n                                    return false;\n                                }\n                            }\n                        }\n                    }\n                    return true;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool isValidSudoku(vector<vector<char>>& board) {\n                    int row[9][10] = {0};\n                    int col[9][10] = {0};\n                    int box[9][10] = {0};\n                    for(int i=0; i<9; i++){\n                        for(int j = 0; j<9; j++){\n                            if(board[i][j] == '.') continue;\n                            int curNumber = board[i][j]-'0';\n                            if(row[i][curNumber]) return false; \n                            if(col[j][curNumber]) return false;\n                            if(box[j/3 + (i/3)*3][curNumber]) return false;\n            \n                            row[i][curNumber] = 1;\n                            col[j][curNumber] = 1;\n                            box[j/3 + (i/3)*3][curNumber] = 1;\n                        }\n                    }\n                    return true;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool isValidSudoku(vector<vector<char>>& board) {\n                    // check row\n                    for (int i = 0; i<9; i++) {\n                        int check[9] = {0};\n                        for (int j = 0; j<9; j++) {\n                            if (board[i][j] == '.') continue;\n                            if (check[board[i][j] - '1'] != 0) {\n                                return false;\n                            }\n                            check[board[i][j]-'1'] = 1;\n                        }\n                    }\n                    // check col\n                    for (int i = 0; i<9; i++) {\n                        int check[9] = {0};\n                        for (int j = 0; j<9; j++) {\n                            if (board[j][i] == '.') continue;\n                            if (check[board[j][i] - '1'] != 0) return false;\n                            check[board[j][i]-'1'] = 1;\n                        }\n                    }\n                    // check block\n                    for (int i = 0; i<3; i++) {\n                        for (int j = 0; j<3; j++) {\n                            int check[9] = {0};\n                            for (int ii = i*3; ii<i*3+3; ii++) {\n                                for (int jj=j*3; jj<j*3+3; jj++) {\n                                    if (board[ii][jj] == '.') continue;\n                                    if (check[board[ii][jj] - '1'] != 0) return false;\n                                    check[board[ii][jj]-'1'] = 1;\n                                }\n                            }\n                        }\n                    }\n            \n                    return true;\n                }\n            };\n        "]
    },
    {
        "id":30,
        "description":"\n        Write a program to solve a Sudoku puzzle by filling the empty cells.\n\nA sudoku solution must satisfy all of the following rules:\n\nEach of the digits 1-9 must occur exactly once in each row.\nEach of the digits 1-9 must occur exactly once in each column.\nEach of the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.\nThe '.' character indicates empty cells.\n\n \n\nExample 1:\n\n\nInput: board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]\nOutput: [[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]\nExplanation: The input board is shown above and the only valid solution is shown below:\n\n\n \n\nConstraints:\n\nboard.length == 9\nboard[i].length == 9\nboard[i][j] is a digit or '.'.\nIt is guaranteed that the input board has only one solution.\n        ",
        "tag":["Array","Hash Table","Backtracking","Matrix"],
        "answer":["\n        class Solution {\n            private:\n                bool line[9][9];\n                bool column[9][9];\n                bool block[3][3][9];\n                bool valid;\n                vector<pair<int, int>> spaces;\n            \n            public:\n                void dfs(vector<vector<char>>& board, int pos) {\n                    if (pos == spaces.size()) {\n                        valid = true;\n                        return;\n                    }\n            \n                    auto [i, j] = spaces[pos];\n                    for (int digit = 0; digit < 9 && !valid; ++digit) {\n                        if (!line[i][digit] && !column[j][digit] && !block[i / 3][j / 3][digit]) {\n                            line[i][digit] = column[j][digit] = block[i / 3][j / 3][digit] = true;\n                            board[i][j] = digit + '0' + 1;\n                            dfs(board, pos + 1);\n                            line[i][digit] = column[j][digit] = block[i / 3][j / 3][digit] = false;\n                        }\n                    }\n                }\n            \n                void solveSudoku(vector<vector<char>>& board) {\n                    memset(line, false, sizeof(line));\n                    memset(column, false, sizeof(column));\n                    memset(block, false, sizeof(block));\n                    valid = false;\n            \n                    for (int i = 0; i < 9; ++i) {\n                        for (int j = 0; j < 9; ++j) {\n                            if (board[i][j] == '.') {\n                                spaces.emplace_back(i, j);\n                            }\n                            else {\n                                int digit = board[i][j] - '0' - 1;\n                                line[i][digit] = column[j][digit] = block[i / 3][j / 3][digit] = true;\n                            }\n                        }\n                    }\n            \n                    dfs(board, 0);\n                }\n            };\n        ","\n        class Solution {\n            private:\n                int line[9];\n                int column[9];\n                int block[3][3];\n                bool valid;\n                vector<pair<int, int>> spaces;\n            \n            public:\n                void flip(int i, int j, int digit) {\n                    line[i] ^= (1 << digit);\n                    column[j] ^= (1 << digit);\n                    block[i / 3][j / 3] ^= (1 << digit);\n                }\n            \n                void dfs(vector<vector<char>>& board, int pos) {\n                    if (pos == spaces.size()) {\n                        valid = true;\n                        return;\n                    }\n            \n                    auto [i, j] = spaces[pos];\n                    int mask = ~(line[i] | column[j] | block[i / 3][j / 3]) & 0x1ff;\n                    for (; mask && !valid; mask &= (mask - 1)) {\n                        int digitMask = mask & (-mask);\n                        int digit = __builtin_ctz(digitMask);\n                        flip(i, j, digit);\n                        board[i][j] = digit + '0' + 1;\n                        dfs(board, pos + 1);\n                        flip(i, j, digit);\n                    }\n                }\n            \n                void solveSudoku(vector<vector<char>>& board) {\n                    memset(line, 0, sizeof(line));\n                    memset(column, 0, sizeof(column));\n                    memset(block, 0, sizeof(block));\n                    valid = false;\n            \n                    for (int i = 0; i < 9; ++i) {\n                        for (int j = 0; j < 9; ++j) {\n                            if (board[i][j] == '.') {\n                                spaces.emplace_back(i, j);\n                            }\n                            else {\n                                int digit = board[i][j] - '0' - 1;\n                                flip(i, j, digit);\n                            }\n                        }\n                    }\n            \n                    dfs(board, 0);\n                }\n            };\n        ","\n        class Solution {\n            private:\n                int line[9];\n                int column[9];\n                int block[3][3];\n                bool valid;\n                vector<pair<int, int>> spaces;\n            \n            public:\n                void flip(int i, int j, int digit) {\n                    line[i] ^= (1 << digit);\n                    column[j] ^= (1 << digit);\n                    block[i / 3][j / 3] ^= (1 << digit);\n                }\n            \n                void dfs(vector<vector<char>>& board, int pos) {\n                    if (pos == spaces.size()) {\n                        valid = true;\n                        return;\n                    }\n            \n                    auto [i, j] = spaces[pos];\n                    int mask = ~(line[i] | column[j] | block[i / 3][j / 3]) & 0x1ff;\n                    for (; mask && !valid; mask &= (mask - 1)) {\n                        int digitMask = mask & (-mask);\n                        int digit = __builtin_ctz(digitMask);\n                        flip(i, j, digit);\n                        board[i][j] = digit + '0' + 1;\n                        dfs(board, pos + 1);\n                        flip(i, j, digit);\n                    }\n                }\n            \n                void solveSudoku(vector<vector<char>>& board) {\n                    memset(line, 0, sizeof(line));\n                    memset(column, 0, sizeof(column));\n                    memset(block, 0, sizeof(block));\n                    valid = false;\n            \n                    for (int i = 0; i < 9; ++i) {\n                        for (int j = 0; j < 9; ++j) {\n                            if (board[i][j] != '.') {\n                                int digit = board[i][j] - '0' - 1;\n                                flip(i, j, digit);\n                            }\n                        }\n                    }\n            \n                    while (true) {\n                        int modified = false;\n                        for (int i = 0; i < 9; ++i) {\n                            for (int j = 0; j < 9; ++j) {\n                                if (board[i][j] == '.') {\n                                    int mask = ~(line[i] | column[j] | block[i / 3][j / 3]) & 0x1ff;\n                                    if (!(mask & (mask - 1))) {\n                                        int digit = __builtin_ctz(mask);\n                                        flip(i, j, digit);\n                                        board[i][j] = digit + '0' + 1;\n                                        modified = true;\n                                    }\n                                }\n                            }\n                        }\n                        if (!modified) {\n                            break;\n                        }\n                    }\n            \n                    for (int i = 0; i < 9; ++i) {\n                        for (int j = 0; j < 9; ++j) {\n                            if (board[i][j] == '.') {\n                                spaces.emplace_back(i, j);\n                            }\n                        }\n                    }\n            \n                    dfs(board, 0);\n                }\n            };\n        "]
    },
    {
        "id":31,
        "description":"\n        Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\n\nThe same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the \nfrequency\n of at least one of the chosen numbers is different.\n\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\n\n \n\nExample 1:\n\nInput: candidates = [2,3,6,7], target = 7\nOutput: [[2,2,3],[7]]\nExplanation:\n2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations.\nExample 2:\n\nInput: candidates = [2,3,5], target = 8\nOutput: [[2,2,2,2],[2,3,3],[3,5]]\nExample 3:\n\nInput: candidates = [2], target = 1\nOutput: []\n \n\nConstraints:\n\n1 <= candidates.length <= 30\n2 <= candidates[i] <= 40\nAll elements of candidates are distinct.\n1 <= target <= 40\n        ",
        "tag":["Array","Backtracking"],
        "answer":["\n        class Solution {\n            public:\n                void dfs(vector<int>& candidates, int target, vector<vector<int>>& ans, vector<int>& combine, int idx) {\n                    if (idx == candidates.size()) {\n                        return;\n                    }\n                    if (target == 0) {\n                        ans.emplace_back(combine);\n                        return;\n                    }\n                    dfs(candidates, target, ans, combine, idx + 1);\n                    if (target - candidates[idx] >= 0) {\n                        combine.emplace_back(candidates[idx]);\n                        dfs(candidates, target - candidates[idx], ans, combine, idx);\n                        combine.pop_back();\n                    }\n                }\n            \n                vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n                    vector<vector<int>> ans;\n                    vector<int> combine;\n                    dfs(candidates, target, ans, combine, 0);\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n                    vector<vector<int>> res;\n                    vector<int> temp;\n                    help(candidates, target, 0, res, temp);\n                    return res;\n                }\n            \n                void help(vector<int>& candidates, int target, int start, vector<vector<int>>& res, vector<int>& temp) {\n                    if (target == 0) {\n                        res.push_back(temp);\n                        return;\n                    }\n                    if (target < 0) {\n                        return;\n                    }\n            \n                    int candidates_len = candidates.size();\n                    for (int i = start; i < candidates_len; ++i) {\n                        if (target - candidates[i] >= 0) {\n                            temp.push_back(candidates[i]);\n                            help(candidates, target - candidates[i], i, res, temp);\n                            temp.pop_back();  \n                        }\n                    }\n            \n                }\n            };\n        ","\n        class Solution {\n            private:\n                vector<vector<int>> result;\n                vector<int> path;\n                void backtracking(vector<int>& candidates, int target, int sum, int startIndex) {\n                    if (sum == target) {\n                        result.push_back(path);\n                        return;\n                    }\n            \n                    for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) {\n                        sum += candidates[i];\n                        path.push_back(candidates[i]);\n                        backtracking(candidates, target, sum, i);\n                        sum -= candidates[i];\n                        path.pop_back();\n            \n                    }\n                }\n            public:\n                vector<vector<int>> combinationSum(vector<int>& candidates, int target) {\n                    result.clear();\n                    path.clear();\n                    sort(candidates.begin(), candidates.end());\n                    backtracking(candidates, target, 0, 0);\n                    return result;\n                }\n            };\n        "]
    },
    {
        "id":32,
        "description":"\n        Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\n\nEach number in candidates may only be used once in the combination.\n\nNote: The solution set must not contain duplicate combinations.\n\n \n\nExample 1:\n\nInput: candidates = [10,1,2,7,6,1,5], target = 8\nOutput: \n[\n[1,1,6],\n[1,2,5],\n[1,7],\n[2,6]\n]\nExample 2:\n\nInput: candidates = [2,5,2,1,2], target = 5\nOutput: \n[\n[1,2,2],\n[5]\n]\n \n\nConstraints:\n\n1 <= candidates.length <= 100\n1 <= candidates[i] <= 50\n1 <= target <= 30\n        ",
        "tag":["Array","Backtracking"],
        "answer":["\n        class Solution {\n            private:\n                vector<pair<int, int>> freq;\n                vector<vector<int>> ans;\n                vector<int> sequence;\n            \n            public:\n                void dfs(int pos, int rest) {\n                    if (rest == 0) {\n                        ans.push_back(sequence);\n                        return;\n                    }\n                    if (pos == freq.size() || rest < freq[pos].first) {\n                        return;\n                    }\n            \n                    dfs(pos + 1, rest);\n            \n                    int most = min(rest / freq[pos].first, freq[pos].second);\n                    for (int i = 1; i <= most; ++i) {\n                        sequence.push_back(freq[pos].first);\n                        dfs(pos + 1, rest - i * freq[pos].first);\n                    }\n                    for (int i = 1; i <= most; ++i) {\n                        sequence.pop_back();\n                    }\n                }\n            \n                vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n                    sort(candidates.begin(), candidates.end());\n                    for (int num: candidates) {\n                        if (freq.empty() || num != freq.back().first) {\n                            freq.emplace_back(num, 1);\n                        } else {\n                            ++freq.back().second;\n                        }\n                    }\n                    dfs(0, target);\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            private:\n                vector<vector<int>> result;\n                vector<int> path;\n                void backtracking(vector<int>& candidates, int target, int sum, int startIndex, vector<bool>& used) {\n                    if (sum == target) {\n                        result.push_back(path);\n                        return;\n                    }\n                    for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++) {\n                        if (i > 0 && candidates[i] == candidates[i - 1] && used[i - 1] == false) {\n                            continue;\n                        }\n                        sum += candidates[i];\n                        path.push_back(candidates[i]);\n                        used[i] = true;\n                        backtracking(candidates, target, sum, i + 1, used);\n                        used[i] = false;\n                        sum -= candidates[i];\n                        path.pop_back();\n                    }\n                }\n            \n            public:\n                vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n                    vector<bool> used(candidates.size(), false);\n                    path.clear();\n                    result.clear();\n                    sort(candidates.begin(), candidates.end());\n                    backtracking(candidates, target, 0, 0, used);\n                    return result;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int len=0;\n                vector<vector<int>> combinationSum2(vector<int>& candidates, int target) {\n                    vector<vector<int>> res;\n                    vector<int> ans;\n                    for(int i=0;i<candidates.size();i++){\n                        if(candidates[i]<=target){\n                            swap(candidates[len++],candidates[i]);\n                        }\n                    }\n                    sort(candidates.begin(),candidates.begin()+len);\n                    dfs(candidates,res,ans,target,0);\n                    return res;\n                }\n                void dfs(vector<int>& candidates,vector<vector<int>>& res,vector<int>& ans,int target,int first){\n                    if(target==0){\n                            res.emplace_back(ans);\n                            return;\n                        }\n                    for(int i=first;i<len&&candidates[i]<=target;i++){\n                        ans.emplace_back(candidates[i]);\n                        dfs(candidates,res,ans,target-candidates[i],i+1);\n                        ans.pop_back();\n                        while(i+1<len&&candidates[i+1]==candidates[i])i++;\n                    }\n                }\n            };\n        "]
    },
    {
        "id":33,
        "description":"\n        Given an unsorted integer array nums, return the smallest missing positive integer.\n\nYou must implement an algorithm that runs in O(n) time and uses O(1) auxiliary space.\n\n \n\nExample 1:\n\nInput: nums = [1,2,0]\nOutput: 3\nExplanation: The numbers in the range [1,2] are all in the array.\nExample 2:\n\nInput: nums = [3,4,-1,1]\nOutput: 2\nExplanation: 1 is in the array but 2 is missing.\nExample 3:\n\nInput: nums = [7,8,9,11,12]\nOutput: 1\nExplanation: The smallest positive integer 1 is missing.\n \n\nConstraints:\n\n1 <= nums.length <= 10^5\n-2^31 <= nums[i] <= 2^31 - 1\n        ",
        "tag":["Array","Hash Table"],
        "answer":["\n        class Solution {\n            public:\n                int firstMissingPositive(vector<int>& nums) {\n                    int n = nums.size();\n                    for (int& num: nums) {\n                        if (num <= 0) {\n                            num = n + 1;\n                        }\n                    }\n                    for (int i = 0; i < n; ++i) {\n                        int num = abs(nums[i]);\n                        if (num <= n) {\n                            nums[num - 1] = -abs(nums[num - 1]);\n                        }\n                    }\n                    for (int i = 0; i < n; ++i) {\n                        if (nums[i] > 0) {\n                            return i + 1;\n                        }\n                    }\n                    return n + 1;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int firstMissingPositive(vector<int>& nums) {\n                    int n = nums.size();\n                    for (int i = 0; i < n; ++i) {\n                        while (nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {\n                            swap(nums[nums[i] - 1], nums[i]);\n                        }\n                    }\n                    for (int i = 0; i < n; ++i) {\n                        if (nums[i] != i + 1) {\n                            return i + 1;\n                        }\n                    }\n                    return n + 1;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int firstMissingPositive(vector<int>& nums) {\n                    int n = nums.size();\n                    for(int i = 0; i < n; i++){\n                        while(nums[i] >= 1 && nums[i] <= n && nums[i] != nums[nums[i] - 1]){\n                            swap(nums[i], nums[nums[i] - 1]);\n                        }\n                    }\n                    for(int i = 0; i < n; i++){\n                        if(nums[i] != i + 1)\n                            return i + 1;\n                    }\n                    return n + 1;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int firstMissingPositive(vector<int>& nums) {\n                    int n = nums.size();\n                    for (int i = 0; i < n; i++) {\n                      while (nums[i] > 0 && nums[i] <= n && nums[i] != nums[nums[i] - 1])\n                        swap(nums[i], nums[nums[i] - 1]);\n                    }\n            \n                    for (int i = 0; i < n; i++)\n                        if (nums[i] != i + 1)\n                            return i + 1;\n            \n                    return n + 1;\n                }\n            };\n            \n        ","\n        \nclass Solution {\n    public:\n        int firstMissingPositive(vector<int>& nums) {\n        int n = nums.size();\n        bool yss = true;\n        for(int i=0;i<n;i++) if(nums[i]==1){ yss=false ; break; };\n        if(yss) return 1;\n        for(int i=0;i<n;i++) if(nums[i]<=0||nums[i]>=n+1) nums[i]=1;\n        for(int i=0;i<n;i++){\n            int x = abs(nums[i]);\n            nums[x-1] = -abs(nums[x-1]);\n        }\n        int i;\n        for(i=0;i<n;i++) if(nums[i]>0)    return i+1;\n        return i+1;\n        }\n    };\n        "]
    },
    {
        "id":34,
        "description":"\n        Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\n\nNote: You must not use any built-in BigInteger library or convert the inputs to integer directly.\n\n \n\nExample 1:\n\nInput: num1 = \"2\", num2 = \"3\"\nOutput: \"6\"\nExample 2:\n\nInput: num1 = \"123\", num2 = \"456\"\nOutput: \"56088\"\n \n\nConstraints:\n\n1 <= num1.length, num2.length <= 200\nnum1 and num2 consist of digits only.\nBoth num1 and num2 do not contain any leading zero, except the number 0 itself.\n        ",
        "tag":["Math","String","Simulation"],
        "answer":["\n        class Solution {\n            public:\n                string multiply(string num1, string num2) {\n                    if (num1 == \"0\" || num2 == \"0\") {\n                        return \"0\";\n                    }\n                    string ans = \"0\";\n                    int m = num1.size(), n = num2.size();\n                    for (int i = n - 1; i >= 0; i--) {\n                        string curr;\n                        int add = 0;\n                        for (int j = n - 1; j > i; j--) {\n                            curr.push_back(0);\n                        }\n                        int y = num2.at(i) - '0';\n                        for (int j = m - 1; j >= 0; j--) {\n                            int x = num1.at(j) - '0';\n                            int product = x * y + add;\n                            curr.push_back(product % 10);\n                            add = product / 10;\n                        }\n                        while (add != 0) {\n                            curr.push_back(add % 10);\n                            add /= 10;\n                        }\n                        reverse(curr.begin(), curr.end());\n                        for (auto &c : curr) {\n                            c += '0';\n                        }\n                        ans = addStrings(ans, curr);\n                    }\n                    return ans;\n                }\n            \n                string addStrings(string &num1, string &num2) {\n                    int i = num1.size() - 1, j = num2.size() - 1, add = 0;\n                    string ans;\n                    while (i >= 0 || j >= 0 || add != 0) {\n                        int x = i >= 0 ? num1.at(i) - '0' : 0;\n                        int y = j >= 0 ? num2.at(j) - '0' : 0;\n                        int result = x + y + add;\n                        ans.push_back(result % 10);\n                        add = result / 10;\n                        i--;\n                        j--;\n                    }\n                    reverse(ans.begin(), ans.end());\n                    for (auto &c: ans) {\n                        c += '0';\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                string multiply(string num1, string num2) {\n                    if (num1 == \"0\" || num2 == \"0\") {\n                        return \"0\";\n                    }\n                    int m = num1.size(), n = num2.size();\n                    auto ansArr = vector<int>(m + n);\n                    for (int i = m - 1; i >= 0; i--) {\n                        int x = num1.at(i) - '0';\n                        for (int j = n - 1; j >= 0; j--) {\n                            int y = num2.at(j) - '0';\n                            ansArr[i + j + 1] += x * y;\n                        }\n                    }\n                    for (int i = m + n - 1; i > 0; i--) {\n                        ansArr[i - 1] += ansArr[i] / 10;\n                        ansArr[i] %= 10;\n                    }\n                    int index = ansArr[0] == 0 ? 1 : 0;\n                    string ans;\n                    while (index < m + n) {\n                        ans.push_back(ansArr[index]);\n                        index++;\n                    }\n                    for (auto &c: ans) {\n                        c += '0';\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                string multiply(string num1, string num2) {\n                    vector<int> A, B;\n                    int n = num1.size(), m = num2.size();\n                    for (int i = n - 1; i >= 0; i -- ) A.push_back(num1[i] - '0'); //反向存贮\n                    for (int i = m - 1; i >= 0; i -- ) B.push_back(num2[i] - '0');\n                    vector<int> C(n + m);\n                    for (int i = 0; i < n; i ++ )\n                        for (int j = 0; j < m; j ++ )\n                            C[i + j] += A[i] * B[j];\n                    int t = 0;  //存贮进位\n                    for (int i = 0; i < C.size(); i ++ ) {\n                        t += C[i];\n                        C[i] = t % 10;\n                        t /= 10;\n                    }\n                    int k = C.size() - 1;\n                    while (k > 0 && !C[k]) k -- ;  //去除前导0\n                    string res;\n                    while (k >= 0) res += C[k -- ] + '0';  //反转\n                    return res;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                string multiply(string num1, string num2) {\n                    int n1=num1.size();\n                    int n2=num2.size();\n                    string res(n1+n2,'0');\n                    for(int i=n2-1;i>=0;i--){\n                        for(int j=n1-1;j>=0;j--){\n                            int temp=(res[i+j+1]-'0')+(num1[j]-'0')*(num2[i]-'0');\n                            res[i+j+1]=temp%10+'0';//当前位\n                            res[i+j]+=temp/10; //前一位加上进位，res[i+j]已经初始化为'0'，加上int类型自动转化为char，所以此处不加'0'\n                        }\n                    }\n                    \n            //去除首位'0'\n                    for(int i=0;i<n1+n2;i++){\n                        if(res[i]!='0')\n                            return res.substr(i);\n                    }\n                    return \"0\";\n                   \n                    \n                }\n            };\n        "]
    },
    {
        "id":35,
        "description":"\n        Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*' where:\n\n'?' Matches any single character.\n'*' Matches any sequence of characters (including the empty sequence).\nThe matching should cover the entire input string (not partial).\n\n \n\nExample 1:\n\nInput: s = \"aa\", p = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\nExample 2:\n\nInput: s = \"aa\", p = \"*\"\nOutput: true\nExplanation: '*' matches any sequence.\nExample 3:\n\nInput: s = \"cb\", p = \"?a\"\nOutput: false\nExplanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.\n \n\nConstraints:\n\n0 <= s.length, p.length <= 2000\ns contains only lowercase English letters.\np contains only lowercase English letters, '?' or '*'.\n        ",
        "tag":["Greedy","Recursion","String","Dynamic Programming"],
        "answer":["\n        class Solution {\n            public:\n                bool isMatch(string s, string p) {\n                    int m = s.size();\n                    int n = p.size();\n                    vector<vector<int>> dp(m + 1, vector<int>(n + 1));\n                    dp[0][0] = true;\n                    for (int i = 1; i <= n; ++i) {\n                        if (p[i - 1] == '*') {\n                            dp[0][i] = true;\n                        }\n                        else {\n                            break;\n                        }\n                    }\n                    for (int i = 1; i <= m; ++i) {\n                        for (int j = 1; j <= n; ++j) {\n                            if (p[j - 1] == '*') {\n                                dp[i][j] = dp[i][j - 1] | dp[i - 1][j];\n                            }\n                            else if (p[j - 1] == '?' || s[i - 1] == p[j - 1]) {\n                                dp[i][j] = dp[i - 1][j - 1];\n                            }\n                        }\n                    }\n                    return dp[m][n];\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool isMatch(string s, string p) {\n                    auto allStars = [](const string& str, int left, int right) {\n                        for (int i = left; i < right; ++i) {\n                            if (str[i] != '*') {\n                                return false;\n                            }\n                        }\n                        return true;\n                    };\n                    auto charMatch = [](char u, char v) {\n                        return u == v || v == '?';\n                    };\n            \n                    while (s.size() && p.size() && p.back() != '*') {\n                        if (charMatch(s.back(), p.back())) {\n                            s.pop_back();\n                            p.pop_back();\n                        }\n                        else {\n                            return false;\n                        }\n                    }\n                    if (p.empty()) {\n                        return s.empty();\n                    }\n            \n                    int sIndex = 0, pIndex = 0;\n                    int sRecord = -1, pRecord = -1;\n                    while (sIndex < s.size() && pIndex < p.size()) {\n                        if (p[pIndex] == '*') {\n                            ++pIndex;\n                            sRecord = sIndex;\n                            pRecord = pIndex;\n                        }\n                        else if (charMatch(s[sIndex], p[pIndex])) {\n                            ++sIndex;\n                            ++pIndex;\n                        }\n                        else if (sRecord != -1 && sRecord + 1 < s.size()) {\n                            ++sRecord;\n                            sIndex = sRecord;\n                            pIndex = pRecord;\n                        }\n                        else {\n                            return false;\n                        }\n                    }\n                    return allStars(p, pIndex, p.size());\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool isMatch(string s, string p) {\n                    int m = s.length(), n = p.length();\n            \n                    // 状态定义：dp[i][j] 表示 s 的前 i 个字符和 p 的前 j 个字符是否匹配\n                    vector<vector<bool>> dp(m + 1, vector<bool>(n + 1, false));\n            \n                    // 状态初始化\n                    // 1. 空字符串和空字符串是匹配的\n                    dp[0][0] = true;\n                    for (int i = 1; i <= n; i++) {\n                        // 3. 空字符串和 * 是匹配的\n                        if (dp[0][i - 1] && p[i - 1] == '*') {\n                            dp[0][i] = true;\n                        }\n                    }\n            \n                    for (int i = 1; i <= m; i++) {\n                        for (int j = 1; j <= n; j++) {\n                            if (s[i - 1] == p[j - 1]\n                                    || p[j - 1] == '?') {\n                                dp[i][j] = dp[i - 1][j - 1];\n                            } else if(p[j - 1] == '*') {\n                                dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\n                            }\n                        }\n                    }\n            \n                    return dp[m][n];\n                }\n            };\n        "]
    },
    {
        "id":36,
        "description":"\n        You are given a 0-indexed array of integers nums of length n. You are initially positioned at nums[0].\n\nEach element nums[i] represents the maximum length of a forward jump from index i. In other words, if you are at nums[i], you can jump to any nums[i + j] where:\n\n0 <= j <= nums[i] and\ni + j < n\nReturn the minimum number of jumps to reach nums[n - 1]. The test cases are generated such that you can reach nums[n - 1].\n\n \n\nExample 1:\n\nInput: nums = [2,3,1,1,4]\nOutput: 2\nExplanation: The minimum number of jumps to reach the last index is 2. Jump 1 step from index 0 to 1, then 3 steps to the last index.\nExample 2:\n\nInput: nums = [2,3,0,1,4]\nOutput: 2\n \n\nConstraints:\n\n1 <= nums.length <= 10^4\n0 <= nums[i] <= 1000\nIt's guaranteed that you can reach nums[n - 1].\n        ",
        "tag":["Greedy","Array","Dynamic Programming"],
        "answer":["\n        class Solution {\n            public:\n                int jump(vector<int>& nums) {\n                    int maxPos = 0, n = nums.size(), end = 0, step = 0;\n                    for (int i = 0; i < n - 1; ++i) {\n                        if (maxPos >= i) {\n                            maxPos = max(maxPos, i + nums[i]);\n                            if (i == end) {\n                                end = maxPos;\n                                ++step;\n                            }\n                        }\n                    }\n                    return step;\n                }\n            };\n        ","\n        int jump(vector<int>& nums)\n{\n    int ans = 0;\n    int end = 0;\n    int maxPos = 0;\n    for (int i = 0; i < nums.size() - 1; i++)\n    {\n        maxPos = max(nums[i] + i, maxPos);\n        if (i == end)\n        {\n            end = maxPos;\n            ans++;\n        }\n    }\n    return ans;\n}\n        ","\n        class Solution {\n            public:\n                bool canJump(vector<int>& nums) {\n                    int cover = 0;\n                    if (nums.size() == 1) return true;\n                    for (int i = 0; i <= cover; i++) {\n                        cover = max(i + nums[i], cover);\n                        if (cover >= nums.size() - 1) return true;\n                    }\n                    return false;\n                }\n            };\n        ","\n        class Solution {\n            public:\n            \n                int jump(vector<int>& nums) {\n                    int n = nums.size();\n                    int dp[n];\n                    memset(dp,0x3f,sizeof(dp));\n                    dp[0] = 0;\n                    for(int i = 1;i < n;i++){\n                        for(int j = 0;j < i;j++){\n                            if (nums[j] + j >= i)\n                            {\n                                dp[i] = min(dp[i],dp[j]+1); \n                            }\n                        }\n                    }\n                    return dp[n-1];\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int jump(vector<int>& nums) {\n                    int n = nums.size();\n                    vector<int> dp(n); //dp[i]: 到达i的最小跳跃次数\n                    set<pair<int, int>> st;\n                    for (int i = 0; i < n; ++i) {\n                        while (!st.empty()) {\n                            auto [d, j] = *st.begin();\n                            if (j + nums[j] < i) { //从j跳不到i及i后面的位置\n                                st.erase(st.begin());\n                            } else {\n                                dp[i] = 1 + d;\n                                break;\n                            }\n                        }\n                        st.insert({dp[i], i});\n                    }\n                    return dp[n - 1];\n                }\n            };\n        "]
    },
    {
        "id":37,
        "description":"\n        Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\n\n \n\nExample 1:\n\nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\nExample 2:\n\nInput: nums = [0,1]\nOutput: [[0,1],[1,0]]\nExample 3:\n\nInput: nums = [1]\nOutput: [[1]]\n \n\nConstraints:\n\n1 <= nums.length <= 6\n-10 <= nums[i] <= 10\nAll the integers of nums are unique.\n        ",
        "tag":["Array","Backtracking"],
        "answer":["\n        class Solution {\n            public:\n                void backtrack(vector<vector<int>>& res, vector<int>& output, int first, int len){\n                    // 所有数都填完了\n                    if (first == len) {\n                        res.emplace_back(output);\n                        return;\n                    }\n                    for (int i = first; i < len; ++i) {\n                        // 动态维护数组\n                        swap(output[i], output[first]);\n                        // 继续递归填下一个数\n                        backtrack(res, output, first + 1, len);\n                        // 撤销操作\n                        swap(output[i], output[first]);\n                    }\n                }\n                vector<vector<int>> permute(vector<int>& nums) {\n                    vector<vector<int> > res;\n                    backtrack(res, nums, 0, (int)nums.size());\n                    return res;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<vector<int>> permute(vector<int> &nums) {\n                    int n = nums.size();\n                    vector<vector<int>> ans;\n                    vector<int> path(n), on_path(n);\n                    function<void(int)> dfs = [&](int i) {\n                        if (i == n) {\n                            ans.emplace_back(path);\n                            return;\n                        }\n                        for (int j = 0; j < n; ++j) {\n                            if (!on_path[j]) {\n                                path[i] = nums[j];\n                                on_path[j] = true;\n                                dfs(i + 1);\n                                on_path[j] = false; // 恢复现场\n                            }\n                        }\n                    };\n                    dfs(0);\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<int> path;\n                vector<vector<int>> res;\n                void backTracking(vector<int>& nums, vector<bool>& used)\n                {\n                    \n                    int len = nums.size();\n            \n                    if(path.size() == len)\n                    {\n                        res.push_back(path);\n                        return;\n                    }\n                    //每次从第一个元素开始枚举\n                    for(int i = 0; i < len; i++)\n                    {\n                        //如果path中有这个元素就跳过\n                        if(used[i] == true)\n                        {\n                            continue;\n                        }\n                        path.push_back(nums[i]);\n                        used[i] = true;\n                        backTracking(nums, used);\n                        path.pop_back();\n                        used[i] = false;\n                    }\n                }\n                vector<vector<int>> permute(vector<int>& nums) \n                {\n                    path.clear();\n                    res.clear();\n                    //记录当前元素是否使用过\n                    vector<bool> used(nums.size(), false);\n                    backTracking(nums, used);\n                    return res;\n                }\n            };\n        "]
    },
    {
        "id":38,
        "description":"\n        Given a collection of numbers, nums, that might contain duplicates, return all possible unique permutations in any order.\n\n \n\nExample 1:\n\nInput: nums = [1,1,2]\nOutput:\n[[1,1,2],\n [1,2,1],\n [2,1,1]]\nExample 2:\n\nInput: nums = [1,2,3]\nOutput: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]\n \n\nConstraints:\n\n1 <= nums.length <= 8\n-10 <= nums[i] <= 10\n        ",
        "tag":["Array","Backtracking"],
        "answer":["\n        class Solution {\n            vector<int> vis;\n        \n        public:\n            void backtrack(vector<int>& nums, vector<vector<int>>& ans, int idx, vector<int>& perm) {\n                if (idx == nums.size()) {\n                    ans.emplace_back(perm);\n                    return;\n                }\n                for (int i = 0; i < (int)nums.size(); ++i) {\n                    if (vis[i] || (i > 0 && nums[i] == nums[i - 1] && !vis[i - 1])) {\n                        continue;\n                    }\n                    perm.emplace_back(nums[i]);\n                    vis[i] = 1;\n                    backtrack(nums, ans, idx + 1, perm);\n                    vis[i] = 0;\n                    perm.pop_back();\n                }\n            }\n        \n            vector<vector<int>> permuteUnique(vector<int>& nums) {\n                vector<vector<int>> ans;\n                vector<int> perm;\n                vis.resize(nums.size());\n                sort(nums.begin(), nums.end());\n                backtrack(nums, ans, 0, perm);\n                return ans;\n            }\n        };\n        ","\n        class Solution {\n            public:\n                vector<vector<int>> permuteUnique(vector<int>& nums) {\n                    vector<vector<int>> ans;\n                    sort(nums.begin(),nums.end());\n                    do\n                    {\n                        ans.push_back(nums);\n                    }while(next_permutation(nums.begin(),nums.end()));\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            private:\n                vector<vector<int>> result;\n                vector<int> path;\n                void backtracking (vector<int>& nums, vector<bool>& used) {\n                    // 此时说明找到了一组\n                    if (path.size() == nums.size()) {\n                        result.push_back(path);\n                        return;\n                    }\n                    for (int i = 0; i < nums.size(); i++) {\n                        // used[i - 1] == true，说明同一树枝nums[i - 1]使用过\n                        // used[i - 1] == false，说明同一树层nums[i - 1]使用过 \n                        // 如果同一树层nums[i - 1]使用过则直接跳过\n                        if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {\n                            continue;\n                        }\n                        if (used[i] == false) {\n                            used[i] = true;\n                            path.push_back(nums[i]);\n                            backtracking(nums, used);\n                            path.pop_back();\n                            used[i] = false;\n                        }\n                    }\n                }\n            public:\n                vector<vector<int>> permuteUnique(vector<int>& nums) {\n                    result.clear();\n                    path.clear();\n                    sort(nums.begin(), nums.end()); // 排序\n                    vector<bool> used(nums.size(), false);\n                    backtracking(nums, used);\n                    return result;\n                }\n            };\n        "]
    },
    {
        "id":39,
        "description":"\n        Given an array of strings strs, group the anagrams together. You can return the answer in any order.\n\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\n \n\nExample 1:\n\nInput: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\nOutput: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\nExample 2:\n\nInput: strs = [\"\"]\nOutput: [[\"\"]]\nExample 3:\n\nInput: strs = [\"a\"]\nOutput: [[\"a\"]]\n \n\nConstraints:\n\n1 <= strs.length <= 10^4\n0 <= strs[i].length <= 100\nstrs[i] consists of lowercase English letters.",
        "tag":["Array","Hash Table","String","Sorting"],
        "answer":["\n        class Solution {\n            public:\n                vector<vector<string>> groupAnagrams(vector<string>& strs) {\n                    unordered_map<string, vector<string>> mp;\n                    for (string& str: strs) {\n                        string key = str;\n                        sort(key.begin(), key.end());\n                        mp[key].emplace_back(str);\n                    }\n                    vector<vector<string>> ans;\n                    for (auto it = mp.begin(); it != mp.end(); ++it) {\n                        ans.emplace_back(it->second);\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<vector<string>> groupAnagrams(vector<string>& strs) {\n                    // 自定义对 array<int, 26> 类型的哈希函数\n                    auto arrayHash = [fn = hash<int>{}] (const array<int, 26>& arr) -> size_t {\n                        return accumulate(arr.begin(), arr.end(), 0u, [&](size_t acc, int num) {\n                            return (acc << 1) ^ fn(num);\n                        });\n                    };\n            \n                    unordered_map<array<int, 26>, vector<string>, decltype(arrayHash)> mp(0, arrayHash);\n                    for (string& str: strs) {\n                        array<int, 26> counts{};\n                        int length = str.length();\n                        for (int i = 0; i < length; ++i) {\n                            counts[str[i] - 'a'] ++;\n                        }\n                        mp[counts].emplace_back(str);\n                    }\n                    vector<vector<string>> ans;\n                    for (auto it = mp.begin(); it != mp.end(); ++it) {\n                        ans.emplace_back(it->second);\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<vector<string>> groupAnagrams(vector<string>& strs) {\n                    int i=0;\n                    string s;\n                    vector<vector<string>>v;\n                    vector<string>vv;\n                    unordered_map<string,int>m;\n                    for(int j=0;j<strs.size();j++){\n                        s=strs[j];\n                        sort(s.begin(),s.end());\n                        if(m.count(s)==0){\n                            m.insert({s,i});\n                            i++;\n                            vv.push_back(strs[j]);\n                            v.push_back(vv);\n                            vv.clear();\n                        }\n                        else{\n                            v[m[s]].push_back(strs[j]);\n                        }\n                    }\n                    return v;\n                }\n            };\n        "]
    },
    {
        "id":40,
        "description":"\n        Implement pow(x, n), which calculates x raised to the power n (i.e., x^n).\n\n \n\nExample 1:\n\nInput: x = 2.00000, n = 10\nOutput: 1024.00000\nExample 2:\n\nInput: x = 2.10000, n = 3\nOutput: 9.26100\nExample 3:\n\nInput: x = 2.00000, n = -2\nOutput: 0.25000\nExplanation: 2^-2 = 1/2^2 = 1/4 = 0.25\n \n\nConstraints:\n\n-100.0 < x < 100.0\n-2^31 <= n <= 2^31-1\nn is an integer.\nEither x is not zero or n > 0.\n-10^4 <= x^n <= 10^4\n        ",
        "tag":["Recursion","Math"],
        "answer":["\n        class Solution {\n            public:\n                double quickMul(double x, long long N) {\n                    if (N == 0) {\n                        return 1.0;\n                    }\n                    double y = quickMul(x, N / 2);\n                    return N % 2 == 0 ? y * y : y * y * x;\n                }\n            \n                double myPow(double x, int n) {\n                    long long N = n;\n                    return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);\n                }\n            };\n        ","\n        class Solution {\n            public:\n                double quickMul(double x, long long N) {\n                    double ans = 1.0;\n                    // 贡献的初始值为 x\n                    double x_contribute = x;\n                    // 在对 N 进行二进制拆分的同时计算答案\n                    while (N > 0) {\n                        if (N % 2 == 1) {\n                            // 如果 N 二进制表示的最低位为 1，那么需要计入贡献\n                            ans *= x_contribute;\n                        }\n                        // 将贡献不断地平方\n                        x_contribute *= x_contribute;\n                        // 舍弃 N 二进制表示的最低位，这样我们每次只要判断最低位即可\n                        N /= 2;\n                    }\n                    return ans;\n                }\n            \n                double myPow(double x, int n) {\n                    long long N = n;\n                    return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);\n                }\n            };\n            ","\n            class Solution {\n                public:\n                    double myPow(double x, int n) {\n                        if (n == 0) { return 1; }\n                        if (n == 1) { return x; }\n                        if (n == -1) { return 1 / x; }\n                        double half = myPow(x, n / 2);\n                        double rest = myPow(x, n % 2);\n                        return rest * half * half;\n                    }\n                };\n            "]
    },
    {
        "id":41,
        "description":"\n        Given an integer array nums, find the \nsubarray\n with the largest sum, and return its sum.\n\n \n\nExample 1:\n\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4]\nOutput: 6\nExplanation: The subarray [4,-1,2,1] has the largest sum 6.\nExample 2:\n\nInput: nums = [1]\nOutput: 1\nExplanation: The subarray [1] has the largest sum 1.\nExample 3:\n\nInput: nums = [5,4,-1,7,8]\nOutput: 23\nExplanation: The subarray [5,4,-1,7,8] has the largest sum 23.\n \n\nConstraints:\n\n1 <= nums.length <= 10^5\n-10^4 <= nums[i] <= 10^4\n        ",
        "tag":["Array","Divide and Conquer","Dynamic Programming"],
        "answer":["\n        class Solution {\n            public:\n                int maxSubArray(vector<int>& nums) {\n                    int pre = 0, maxAns = nums[0];\n                    for (const auto &x: nums) {\n                        pre = max(pre + x, x);\n                        maxAns = max(maxAns, pre);\n                    }\n                    return maxAns;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                struct Status {\n                    int lSum, rSum, mSum, iSum;\n                };\n            \n                Status pushUp(Status l, Status r) {\n                    int iSum = l.iSum + r.iSum;\n                    int lSum = max(l.lSum, l.iSum + r.lSum);\n                    int rSum = max(r.rSum, r.iSum + l.rSum);\n                    int mSum = max(max(l.mSum, r.mSum), l.rSum + r.lSum);\n                    return (Status) {lSum, rSum, mSum, iSum};\n                };\n            \n                Status get(vector<int> &a, int l, int r) {\n                    if (l == r) {\n                        return (Status) {a[l], a[l], a[l], a[l]};\n                    }\n                    int m = (l + r) >> 1;\n                    Status lSub = get(a, l, m);\n                    Status rSub = get(a, m + 1, r);\n                    return pushUp(lSub, rSub);\n                }\n            \n                int maxSubArray(vector<int>& nums) {\n                    return get(nums, 0, nums.size() - 1).mSum;\n                }\n            };\n        ","\n        class Solution\n{\npublic:\n    int maxSubArray(vector<int> &nums)\n    {\n        //类似寻找最大最小值的题目，初始值一定要定义成理论上的最小最大值\n        int max = INT_MIN;\n        int numsSize = int(nums.size());\n        for (int i = 0; i < numsSize; i++)\n        {\n            int sum = 0;\n            for (int j = i; j < numsSize; j++)\n            {\n                sum += nums[j];\n                if (sum > max)\n                {\n                    max = sum;\n                }\n            }\n        }\n\n        return max;\n    }\n};\n        ","\n        class Solution\n{\npublic:\n    int maxSubArray(vector<int> &nums)\n    {\n        //类似寻找最大最小值的题目，初始值一定要定义成理论上的最小最大值\n        int result = INT_MIN;\n        int numsSize = int(nums.size());\n        //dp[i]表示nums中以nums[i]结尾的最大子序和\n        vector<int> dp(numsSize);\n        dp[0] = nums[0];\n        result = dp[0];\n        for (int i = 1; i < numsSize; i++)\n        {\n            dp[i] = max(dp[i - 1] + nums[i], nums[i]);\n            result = max(result, dp[i]);\n        }\n\n        return result;\n    }\n};\n        ","\n        class Solution\n{\npublic:\n    int maxSubArray(vector<int> &nums)\n    {\n        //类似寻找最大最小值的题目，初始值一定要定义成理论上的最小最大值\n        int result = INT_MIN;\n        int numsSize = int(nums.size());\n        int sum = 0;\n        for (int i = 0; i < numsSize; i++)\n        {\n            sum += nums[i];\n            result = max(result, sum);\n            //如果sum < 0，重新开始找子序串\n            if (sum < 0)\n            {\n                sum = 0;\n            }\n        }\n\n        return result;\n    }\n};\n        "]
    },
    {
        "id":42,
        "description":"\n        You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.\n\nReturn true if you can reach the last index, or false otherwise.\n\n \n\nExample 1:\n\nInput: nums = [2,3,1,1,4]\nOutput: true\nExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.\nExample 2:\n\nInput: nums = [3,2,1,0,4]\nOutput: false\nExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.\n \n\nConstraints:\n\n1 <= nums.length <= 10^4\n0 <= nums[i] <= 10^5\n        ",
        "tag":["Greedy","Array","Dynamic Programming"],
        "answer":["\n        class Solution {\n            public:\n                bool canJump(vector<int>& nums) {\n                    int n = nums.size();\n                    int rightmost = 0;\n                    for (int i = 0; i < n; ++i) {\n                        if (i <= rightmost) {\n                            rightmost = max(rightmost, i + nums[i]);\n                            if (rightmost >= n - 1) {\n                                return true;\n                            }\n                        }\n                    }\n                    return false;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool canJump(vector<int>& nums) {\n                    int k = 0;\n                    for (int i = 0; i < nums.size(); i++) {\n                        if (i > k) return false;\n                        k = max(k, i + nums[i]);\n                    }\n                    return true;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool canJump(vector<int>& nums) {\n                    int nums_len = nums.size();\n                    //初始化目标值\n                    int target = nums_len - 1;\n                    for (int i = nums_len - 1; i >=0; --i) {\n                        //当前目标可达，更新目标\n                        if (i + nums[i] >= target) {\n                            target = i;\n                        }\n                    }\n            \n                    if (target == 0) {\n                        return true;\n                    }\n                    return false;\n                }\n            };\n        "]
    },
    {
        "id":43,
        "description":"\n        Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\n\n \n\nExample 1:\n\nInput: intervals = [[1,3],[2,6],[8,10],[15,18]]\nOutput: [[1,6],[8,10],[15,18]]\nExplanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6].\nExample 2:\n\nInput: intervals = [[1,4],[4,5]]\nOutput: [[1,5]]\nExplanation: Intervals [1,4] and [4,5] are considered overlapping.\n \n\nConstraints:\n\n1 <= intervals.length <= 10^4\nintervals[i].length == 2\n0 <= starti <= endi <= 10^4\n        ",
        "tag":["Array","Sorting"],
        "answer":["\n        class Solution {\n            public:\n                vector<vector<int>> merge(vector<vector<int>>& intervals) {\n                    if (intervals.size() == 0) {\n                        return {};\n                    }\n                    sort(intervals.begin(), intervals.end());\n                    vector<vector<int>> merged;\n                    for (int i = 0; i < intervals.size(); ++i) {\n                        int L = intervals[i][0], R = intervals[i][1];\n                        if (!merged.size() || merged.back()[1] < L) {\n                            merged.push_back({L, R});\n                        }\n                        else {\n                            merged.back()[1] = max(merged.back()[1], R);\n                        }\n                    }\n                    return merged;\n                }\n            };\n        ","\n        vector<vector<int>> merge(vector<vector<int>>& intervals) {\n            sort(intervals.begin(), intervals.end());\n            vector<vector<int>> ans;\n            for (int i = 0; i < intervals.size();) {\n                int t = intervals[i][1];\n                int j = i + 1;\n                while (j < intervals.size() && intervals[j][0] <= t) {\n                    t = max(t, intervals[j][1]);\n                    j++;\n                }\n                ans.push_back({ intervals[i][0], t });\n                i = j;\n            }\n            return ans;\n        }\n        ","\n        class Solution {\n            public:\n                static bool cmp(const vector<int>& a, const vector<int>& b){\n                    // if(a[0] == b[0]) return a[1] < b[1];\n                    return a[0] < b[0];\n                }\n            \n                vector<vector<int>> merge(vector<vector<int>>& intervals) {\n                    vector<vector<int>> result;\n                    // 按照左边界排序\n                    sort(intervals.begin(), intervals.end(), cmp);\n                    for(int i = 1; i < intervals.size(); i++){\n                        // 边界重合则更新左右边界\n                        if(intervals[i - 1][1] >= intervals[i][0]){\n                            intervals[i][0] = min(intervals[i - 1][0], intervals[i][0]);\n                            intervals[i][1] = max(intervals[i - 1][1], intervals[i][1]);\n                        }\n                        // 边界不重合则把前一个区间添加到结果中\n                        else{\n                            result.push_back(intervals[i - 1]);\n                        }\n                    }\n                    // 在循环中，最后一个区间始终没放进去，需要在循环外添加\n                    result.push_back(intervals[intervals.size() - 1]);\n                    return result;\n                }\n            };\n        "]
    },
    {
        "id":44,
        "description":"\n        You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.\n\nInsert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\n\nReturn intervals after the insertion.\n\n \n\nExample 1:\n\nInput: intervals = [[1,3],[6,9]], newInterval = [2,5]\nOutput: [[1,5],[6,9]]\nExample 2:\n\nInput: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\nOutput: [[1,2],[3,10],[12,16]]\nExplanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\n \n\nConstraints:\n\n0 <= intervals.length <= 10^4\nintervals[i].length == 2\n0 <= starti <= endi <= 10^5\nintervals is sorted by starti in ascending order.\nnewInterval.length == 2\n0 <= start <= end <= 10^5\n        ",
        "tag":["Array"],
        "answer":["\n        class Solution {\n            public:\n                vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n                    int left = newInterval[0];\n                    int right = newInterval[1];\n                    bool placed = false;\n                    vector<vector<int>> ans;\n                    for (const auto& interval: intervals) {\n                        if (interval[0] > right) {\n                            // 在插入区间的右侧且无交集\n                            if (!placed) {\n                                ans.push_back({left, right});\n                                placed = true;                    \n                            }\n                            ans.push_back(interval);\n                        }\n                        else if (interval[1] < left) {\n                            // 在插入区间的左侧且无交集\n                            ans.push_back(interval);\n                        }\n                        else {\n                            // 与插入区间有交集，计算它们的并集\n                            left = min(left, interval[0]);\n                            right = max(right, interval[1]);\n                        }\n                    }\n                    if (!placed) {\n                        ans.push_back({left, right});\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<vector<int>> insert(vector<vector<int>>& intervals, vector<int>& newInterval) {\n                    vector<vector<int>> result;\n                    int index = 0; // intervals的索引\n                    // 步骤一：找到需要合并的区间\n                    while (index < intervals.size() && intervals[index][1] < newInterval[0]) {\n                        result.push_back(intervals[index++]);\n                    }\n                    // 步骤二：合并区间\n                    while (index < intervals.size() && intervals[index][0] <= newInterval[1]) {\n                        newInterval[0] = min(intervals[index][0], newInterval[0]);\n                        newInterval[1] = max(intervals[index][1], newInterval[1]);\n                        index++;\n                    }\n                    result.push_back(newInterval);\n                    // 步骤三：处理合并区间之后的区间\n                    while (index < intervals.size()) {\n                        result.push_back(intervals[index++]);\n                    }\n                    return result;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<vector<int>> insert(vector<vector<int>>& a, vector<int>& b) {\n                    vector<vector<int>> ans;\n                    int i = 0;\n                    while(i<a.size()&&a[i][1]<b[0]) ans.push_back(a[i++]);\n                    if(i<a.size()){\n                        b[0] = min(b[0],a[i][0]);\n                        while(i<a.size()&&a[i][0]<=b[1]) b[1] = max(b[1],a[i++][1]);\n                    }\n                    ans.push_back(b);\n                    while(i<a.size()) ans.push_back(a[i++]);\n                    return ans;\n                }\n            };\n        "]
    },
    {
        "id":45,
        "description":"\n        Given a string s consisting of words and spaces, return the length of the last word in the string.\n\nA word is a maximal \nsubstring\n consisting of non-space characters only.\n\n \n\nExample 1:\n\nInput: s = \"Hello World\"\nOutput: 5\nExplanation: The last word is \"World\" with length 5.\nExample 2:\n\nInput: s = \"   fly me   to   the moon  \"\nOutput: 4\nExplanation: The last word is \"moon\" with length 4.\nExample 3:\n\nInput: s = \"luffy is still joyboy\"\nOutput: 6\nExplanation: The last word is \"joyboy\" with length 6.\n \n\nConstraints:\n\n1 <= s.length <= 10^4\ns consists of only English letters and spaces ' '.\nThere will be at least one word in s.\n        ",
        "tag":["String"],
        "answer":["\n        class Solution {\n            public:\n                int lengthOfLastWord(string s) {\n                    int index = s.size() - 1;\n            \n                    while (s[index] == ' ') {\n                        index--;\n                    }\n                    int wordLength = 0;\n                    while (index >= 0 && s[index] != ' ') {\n                        wordLength++;\n                        index--;\n                    }\n            \n                    return wordLength;\n                }\n            };\n        ","\n#include <vector>\nvector<string> split(const string &str, const string &delim) {\n    vector<string> res;\n    if (str.empty()) return res;\n    char *strs = new char[str.size() + 1];\n    strcpy(strs, str.c_str());\n    char *d = new char[delim.size() + 1];\n    strcpy(d, delim.c_str());\n    char *p = strtok(strs, d);\n    while (p) {\n        string s = p;\n        res.push_back(s);\n        p = strtok(NULL, d);\n    }\n    return res;\n} //split()函数分析见附件\nclass Solution {\npublic:\n    int lengthOfLastWord(string s) {\n        vector<string> strs = split(s, \" \");\n        return strs.back().size(); //利用vector的方法，快速完成任务！\n    }\n};\n        ","\n        class Solution {\n            public:\n                int lengthOfLastWord(string s) {\n                    int ans = 0;\n                    for(int i = s.size() - 1;i >= 0;i--)\n                    {\n                        if(s[i] == ' ')\n                        {\n                            s.erase(i,1);\n                        }\n                        else\n                        {\n                            break;\n                        }\n                    }\n                    for(int i = s.size() - 1;i >= 0;i--)\n                    {\n                        if(s[i] == ' ') break;\n                        ans++;\n                    }\n                    return ans;\n                }\n            };\n        "]
    },
    {
        "id":46,
        "description":"\n        The set [1, 2, 3, ..., n] contains a total of n! unique permutations.\n\nBy listing and labeling all of the permutations in order, we get the following sequence for n = 3:\n\n\"123\"\n\"132\"\n\"213\"\n\"231\"\n\"312\"\n\"321\"\nGiven n and k, return the kth permutation sequence.\n\n \n\nExample 1:\n\nInput: n = 3, k = 3\nOutput: \"213\"\nExample 2:\n\nInput: n = 4, k = 9\nOutput: \"2314\"\nExample 3:\n\nInput: n = 3, k = 1\nOutput: \"123\"\n \n\nConstraints:\n\n1 <= n <= 9\n1 <= k <= n!\n        ",
        "tag":["Recursion","Math"],
        "answer":["\n        class Solution {\n            public:\n                string getPermutation(int n, int k) {\n                    vector<int> factorial(n);\n                    factorial[0] = 1;\n                    for (int i = 1; i < n; ++i) {\n                        factorial[i] = factorial[i - 1] * i;\n                    }\n            \n                    --k;\n                    string ans;\n                    vector<int> valid(n + 1, 1);\n                    for (int i = 1; i <= n; ++i) {\n                        int order = k / factorial[n - i] + 1;\n                        for (int j = 1; j <= n; ++j) {\n                            order -= valid[j];\n                            if (!order) {\n                                ans += (j + '0');\n                                valid[j] = 0;\n                                break;\n                            }\n                        }\n                        k %= factorial[n - i];\n                    }   \n                    return ans;     \n                }\n            };\n        ","\n        class Solution {\n            public:\n                string getPermutation(int n, int k) {\n                  vector<char> digits;\n                  int x = 1;\n                  for (int i = 1; i <=n; ++i) {\n                    digits.push_back('0' + i);\n                    x *= i;\n                  }\n                  --k;\n                  string ans;\n                  for (int i = n; i > 0 && k > 0; --i) {\n                    x /= i;\n                    int m = k/x;\n                    printf(\"k=%i, x=%i, m=%i\n\", k, x, m);\n                    k %= x;\n                    auto it = digits.begin() + m;\n                    ans.push_back(*it);\n                    digits.erase(it);\n                  }\n                  for (auto c : digits) {\n                    ans.push_back(c);\n                  }\n                  return ans;\n                }\n            };\n        "]
    },
    {
        "id":47,
        "description":"\n        A valid number can be split up into these components (in order):\n\nA decimal number or an integer.\n(Optional) An 'e' or 'E', followed by an integer.\nA decimal number can be split up into these components (in order):\n\n(Optional) A sign character (either '+' or '-').\nOne of the following formats:\nOne or more digits, followed by a dot '.'.\nOne or more digits, followed by a dot '.', followed by one or more digits.\nA dot '.', followed by one or more digits.\nAn integer can be split up into these components (in order):\n\n(Optional) A sign character (either '+' or '-').\nOne or more digits.\nFor example, all the following are valid numbers: [\"2\", \"0089\", \"-0.1\", \"+3.14\", \"4.\", \"-.9\", \"2e10\", \"-90E3\", \"3e+7\", \"+6e-1\", \"53.5e93\", \"-123.456e789\"], while the following are not valid numbers: [\"abc\", \"1a\", \"1e\", \"e3\", \"99e2.5\", \"--6\", \"-+3\", \"95a54e53\"].\n\nGiven a string s, return true if s is a valid number.\n\n \n\nExample 1:\n\nInput: s = \"0\"\nOutput: true\nExample 2:\n\nInput: s = \"e\"\nOutput: false\nExample 3:\n\nInput: s = \".\"\nOutput: false\n \n\nConstraints:\n\n1 <= s.length <= 20\ns consists of only English letters (both uppercase and lowercase), digits (0-9), plus '+', minus '-', or dot '.'.\n        ",
        "tag":["String"],
        "answer":["\n        class Solution {\n            public:\n                enum State {\n                    STATE_INITIAL,\n                    STATE_INT_SIGN,\n                    STATE_INTEGER,\n                    STATE_POINT,\n                    STATE_POINT_WITHOUT_INT,\n                    STATE_FRACTION,\n                    STATE_EXP,\n                    STATE_EXP_SIGN,\n                    STATE_EXP_NUMBER,\n                    STATE_END\n                };\n            \n                enum CharType {\n                    CHAR_NUMBER,\n                    CHAR_EXP,\n                    CHAR_POINT,\n                    CHAR_SIGN,\n                    CHAR_ILLEGAL\n                };\n            \n                CharType toCharType(char ch) {\n                    if (ch >= '0' && ch <= '9') {\n                        return CHAR_NUMBER;\n                    } else if (ch == 'e' || ch == 'E') {\n                        return CHAR_EXP;\n                    } else if (ch == '.') {\n                        return CHAR_POINT;\n                    } else if (ch == '+' || ch == '-') {\n                        return CHAR_SIGN;\n                    } else {\n                        return CHAR_ILLEGAL;\n                    }\n                }\n            \n                bool isNumber(string s) {\n                    unordered_map<State, unordered_map<CharType, State>> transfer{\n                        {\n                            STATE_INITIAL, {\n                                {CHAR_NUMBER, STATE_INTEGER},\n                                {CHAR_POINT, STATE_POINT_WITHOUT_INT},\n                                {CHAR_SIGN, STATE_INT_SIGN}\n                            }\n                        }, {\n                            STATE_INT_SIGN, {\n                                {CHAR_NUMBER, STATE_INTEGER},\n                                {CHAR_POINT, STATE_POINT_WITHOUT_INT}\n                            }\n                        }, {\n                            STATE_INTEGER, {\n                                {CHAR_NUMBER, STATE_INTEGER},\n                                {CHAR_EXP, STATE_EXP},\n                                {CHAR_POINT, STATE_POINT}\n                            }\n                        }, {\n                            STATE_POINT, {\n                                {CHAR_NUMBER, STATE_FRACTION},\n                                {CHAR_EXP, STATE_EXP}\n                            }\n                        }, {\n                            STATE_POINT_WITHOUT_INT, {\n                                {CHAR_NUMBER, STATE_FRACTION}\n                            }\n                        }, {\n                            STATE_FRACTION,\n                            {\n                                {CHAR_NUMBER, STATE_FRACTION},\n                                {CHAR_EXP, STATE_EXP}\n                            }\n                        }, {\n                            STATE_EXP,\n                            {\n                                {CHAR_NUMBER, STATE_EXP_NUMBER},\n                                {CHAR_SIGN, STATE_EXP_SIGN}\n                            }\n                        }, {\n                            STATE_EXP_SIGN, {\n                                {CHAR_NUMBER, STATE_EXP_NUMBER}\n                            }\n                        }, {\n                            STATE_EXP_NUMBER, {\n                                {CHAR_NUMBER, STATE_EXP_NUMBER}\n                            }\n                        }\n                    };\n            \n                    int len = s.length();\n                    State st = STATE_INITIAL;\n            \n                    for (int i = 0; i < len; i++) {\n                        CharType typ = toCharType(s[i]);\n                        if (transfer[st].find(typ) == transfer[st].end()) {\n                            return false;\n                        } else {\n                            st = transfer[st][typ];\n                        }\n                    }\n                    return st == STATE_INTEGER || st == STATE_POINT || st == STATE_FRACTION || st == STATE_EXP_NUMBER || st == STATE_END;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool isNumber(string s) {\n                    int n = s.size();\n                    int ePos = n;\n                    for(int i = 0;i < n;i++){            // 扫一遍s，记录e的出现次数和出现位置\n                        if(s[i] == 'e' || s[i] == 'E'){\n                            if(ePos == n) ePos = i;\n                            else return false;\n                        }\n                    }\n                    if(ePos == n) return checkFloat(s) || checkInt(s);  // e没出现过，验证原字符串是否是小数/整数\n                    string left = s.substr(0, ePos);     // e出现了一次，把原字符串按e分成左右两个字符串\n                    string right = s.substr(ePos + 1);\n                    return (checkInt(left) || checkFloat(left)) && checkInt(right);\n                }\n            \n                bool checkInt(string& s){\n                    if(s.size() == 0) return false;\n                    int cnt = 0;                         // 数字的个数\n                    int i = 0;\n                    if(s[i] == '+' || s[i] == '-') i++;  // 正负号只能出现在最开头，且只能有一个\n                    while(i < s.size()){\n                        if(!isdigit(s[i])) return false;\n                        cnt++;\n                        i++;\n                    }\n                    return cnt > 0;\n                }\n            \n                bool checkFloat(string& s){\n                    if(s.size() == 0) return false;\n                    bool dot = 0;                       // 是否遇见过小数点\n                    int cnt1 = 0, cnt2 = 0;             // 小数点左边以及右边数字的个数\n                    int i = 0;\n                    if(s[i] == '+' || s[i] == '-') i++;\n                    while(i < s.size()){\n                        if(isdigit(s[i])){\n                            if(dot) cnt2++;\n                            else cnt1++;\n                        }\n                        else if(s[i] == '.'){\n                            if(dot) return false;\n                            else dot = 1;\n                        }\n                        else return false;\n                        i++;\n                    }\n                    return dot && (cnt1 > 0 || cnt2 > 0);    // 小数的三个格式总结成：dot为1，且cnt1、cnt2不全为0\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool isNumber(string s) {\n                    int n = s.size();\n            \n                    // 先检测是否有 e\n                    int e = n;\n                    for (int i = 0; i < n; ++i) {\n                        if (s[i] == 'e' || s[i] == 'E') {\n                            if (e != n)    // 两个 e 不合法\n                                return false;\n                            else\n                                e = i;\n                        }\n                    }\n            \n                    // e 前面没东西，不合法\n                    if (e == 0)\n                        return false;\n            \n                    // 然后检查 e 前面 是否有小数点\n                    int dot = e;\n                    for (int i = 0; i < e; ++i) {\n                        if (s[i] == '.') {\n                            if (dot != e)    // 两个小数点 不合法\n                                return false;\n                            else\n                                dot = i;\n                        }\n                    }\n            \n                    int c = 0;\n                    // 没有小数点，那就是整数\n                    if (dot == e) {\n                        // 整数第一位可能是符号位\n                        if (s[c] == '+' || s[c] == '-') {\n                            ++c;\n                            // 只有一个符号位也是不行的\n                            if (c == dot)\n                                return false;\n                        }\n                        // 剩下部分应该全是数字\n                        while (c < dot) {\n                            int tmp = s[c++] - '0';\n                            if (tmp < 0 || tmp > 9)\n                                return false;\n                        }\n                    }\n                    // 有小数点那就是小数了，范围是 [c,e)\n                    else {\n                        // 小数第一位可能是符号位\n                        if (s[c] == '+' || s[c] == '-')\n                            ++c;\n                        // 先考虑第三种情况：一个点 '.' ，后面跟着至少一位数字\n                        if (c == dot) {\n                            // 小数点后面没有数字，不合法！\n                            if ((c++) + 1 == e)\n                                return false;\n                            while (c < e) {\n                                int ttt = s[c++] - '0';\n                                if (ttt < 0 || ttt > 9)\n                                    return false;\n                            }\n                        }\n                        // 情况2：至少一位数字，后面跟着一个点 '.'\n                        // 情况3：至少一位数字，后面跟着一个点 '.' ，后面再跟着至少一位数字\n                        else {\n                            // [c, dot) 应该都是数字\n                            while (c < dot) {\n                                int ttt = s[c++] - '0';\n                                if (ttt < 0 || ttt > 9)\n                                    return false;\n                            }\n                            // (dot,e) 也应该是数字\n                            c = dot + 1;\n                            while (c < e) {\n                                int ttt = s[c++] - '0';\n                                if (ttt < 0 || ttt > 9)\n                                    return false;\n                            }\n                        }\n                    }\n            \n                    // e 后面肯定是整数\n                    // e 是字符串最后一位，不行!\n                    if (++e == n)\n                        return false;\n                    // 整数可能有一位符号位\n                    if (e < n && (s[e] == '+' || s[e] == '-')) {\n                        // 只有一个符号位也是不行的\n                        if (++e == n)\n                            return false;\n                    }\n                    // 剩下的应该全部是数字\n                    while (e < n) {\n                        int sts = s[e++] - '0';\n                        if (sts < 0 || sts > 9)\n                            return false;\n                    }\n            \n                    return true;\n                }\n            };\n        ","\nclass DFA {\npublic:\n    int state = 0;    // 初始状态\n    unordered_set<int> end{2, 4, 5, 8};\n\n    bool get_char(char s) {\n        int num = s - '0';\n        if (s == '+' || s == '-') {\n            if (state == 0)\n                state = 1;    // 符号\n            else if (state == 6)\n                state = 7;    // 指数符号\n            else\n                return false;    // 错误态\n        }\n        else if (num >= 0 && num <= 9) {\n            if (state < 3)\n                state = 2;    // 整数数字\n            else if (state < 6)\n                state = 5;    // 小数数字\n            else if (state < 9)\n                state = 8;    // 指数数字\n            else\n                return false;    // 错误态\n        }\n        else if (s == 'e' || s == 'E') {\n            if (state == 2 || state == 4 || state == 5)\n                state = 6;\n            else\n                return false;\n        }\n        else if (s == '.') {\n            if (state < 2)\n                state = 3;    // 前面无数字的小数点\n            else if (state == 2)\n                state = 4;    // 前面有数字的小数点\n            else\n                return false;\n        }\n        else\n            return false;\n        return true;\n    }\n};\n\nclass Solution {\npublic:\n    bool isNumber(string s) {\n        DFA dfa;\n        for (char ss : s) {\n            if (!dfa.get_char(ss))\n                return false;\n        }\n        return dfa.end.find(dfa.state) != dfa.end.end();\n    }\n};\n        "]
    },
    {
        "id":48,
        "description":"\n        You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0's.\n\nIncrement the large integer by one and return the resulting array of digits.\n\n \n\nExample 1:\n\nInput: digits = [1,2,3]\nOutput: [1,2,4]\nExplanation: The array represents the integer 123.\nIncrementing by one gives 123 + 1 = 124.\nThus, the result should be [1,2,4].\nExample 2:\n\nInput: digits = [4,3,2,1]\nOutput: [4,3,2,2]\nExplanation: The array represents the integer 4321.\nIncrementing by one gives 4321 + 1 = 4322.\nThus, the result should be [4,3,2,2].\nExample 3:\n\nInput: digits = [9]\nOutput: [1,0]\nExplanation: The array represents the integer 9.\nIncrementing by one gives 9 + 1 = 10.\nThus, the result should be [1,0].\n \n\nConstraints:\n\n1 <= digits.length <= 100\n0 <= digits[i] <= 9\ndigits does not contain any leading 0's.\n        ",
        "tag":["Array","Math"],
        "answer":["\n        class Solution {\n            public:\n                vector<int> plusOne(vector<int>& digits) {\n                    int n = digits.size();\n                    for (int i = n - 1; i >= 0; --i) {\n                        if (digits[i] != 9) {\n                            ++digits[i];\n                            for (int j = i + 1; j < n; ++j) {\n                                digits[j] = 0;\n                            }\n                            return digits;\n                        }\n                    }\n            \n                    // digits 中所有的元素均为 9\n                    vector<int> ans(n + 1);\n                    ans[0] = 1;\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<int> plusOne(vector<int>& digits) {\n                    digits[digits.size() - 1]++;\n                    int cur = digits.size() - 1;\n                    while(digits[cur] == 10 && cur != 0)\n                    {\n                        digits[cur] = 0;\n                        digits[--cur]++;\n                    }\n                    if(digits[cur] == 10)\n                    {\n                        digits.insert(digits.begin(),1);\n                        digits[cur + 1] = 0;\n                    }\n                    return digits;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<int> plusOne(vector<int>& digits) {\n                    int n = digits.size();\n                    for (int i = n - 1; i >= 0; --i) {\n                        digits[i]++;\n                        digits[i] %= 10;\n                        if (digits[i] != 0) {\n                            return digits;\n                        }\n                    }\n                    vector<int> res(n + 1);\n                    res[0] = 1;\n                    return res;\n                }\n            };\n        "]
    },
    {
        "id":49,
        "description":"\n        Given two binary strings a and b, return their sum as a binary string.\n\n \n\nExample 1:\n\nInput: a = \"11\", b = \"1\"\nOutput: \"100\"\nExample 2:\n\nInput: a = \"1010\", b = \"1011\"\nOutput: \"10101\"\n \n\nConstraints:\n\n1 <= a.length, b.length <= 10^4\na and b consist only of '0' or '1' characters.\nEach string does not contain leading zeros except for the zero itself.\n        ",
        "tag":["Bit Manipulation","Math","String","Simulation"],
        "answer":["\n        class Solution {\n            public:\n                string addBinary(string a, string b) {\n                    string ans;\n                    reverse(a.begin(), a.end());\n                    reverse(b.begin(), b.end());\n            \n                    int n = max(a.size(), b.size()), carry = 0;\n                    for (size_t i = 0; i < n; ++i) {\n                        carry += i < a.size() ? (a.at(i) == '1') : 0;\n                        carry += i < b.size() ? (b.at(i) == '1') : 0;\n                        ans.push_back((carry % 2) ? '1' : '0');\n                        carry /= 2;\n                    }\n            \n                    if (carry) {\n                        ans.push_back('1');\n                    }\n                    reverse(ans.begin(), ans.end());\n            \n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                string addBinary(string a, string b) {\n                    int al = a.size();\n                    int bl = b.size();\n                    while(al < bl) //让两个字符串等长，若不等长，在短的字符串前补零，否则之后的操作会超出索引\n                    {\n                        a = '0' + a;\n                        ++ al;\n                    }\n                    while(al > bl)\n                    {\n                        b = '0' + b;\n                        ++ bl;\n                    }\n                    for(int j = a.size() - 1; j > 0; -- j) //从后到前遍历所有的位数，同位相加\n                    {\n                        a[j] = a[j] - '0' + b[j];\n                        if(a[j] >=  '2') //若大于等于字符‘2’，需要进一\n                        {\n                            a[j] = (a[j] - '0') % 2 + '0';\n                            a[j-1] = a[j-1] + 1;\n                        }\n                    }\n                    a[0] = a[0] - '0' + b[0]; //将ab的第0位相加\n                    if(a[0] >= '2') //若大于等于2，需要进一\n                    {\n                        a[0] = (a[0] - '0') % 2 + '0';\n                        a = '1' + a;\n                    }\n                    return a;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<int> add(vector<int>& A, vector<int>& B) {\n                    int t = 0;\n                    vector<int> tmp;\n            \n                    for (int i = 0; i < A.size(); ++i) {\n                        t += A[i];\n                        if (i < B.size()) t += B[i];\n                        tmp.push_back(t % 2);\n                        t /= 2;\n                    } \n                    \n                    if (t) tmp.push_back(t);\n                    return tmp;\n                }\n            \n                string addBinary(string a, string b) {\n                    vector<int> A, B, C;\n                    string tmp;\n            \n                    for (int i = a.size() - 1; i >= 0; --i) A.push_back(a[i] - '0');\n                    for (int i = b.size() - 1; i >= 0; --i) B.push_back(b[i] - '0');\n            \n                    if (a.size() < b.size()) C = add(B, A);\n                    else C = add(A, B);\n            \n                    for (int i = C.size() - 1; i >= 0; --i) {\n                        if (C[i] == 1) tmp += '1';\n                        else tmp += '0';\n                    }\n                    return tmp;\n                }\n            };\n        "]
    },
    {
        "id":50,
        "description":"\n        Given an array of strings words and a width maxWidth, format the text such that each line has exactly maxWidth characters and is fully (left and right) justified.\n\nYou should pack your words in a greedy approach; that is, pack as many words as you can in each line. Pad extra spaces ' ' when necessary so that each line has exactly maxWidth characters.\n\nExtra spaces between words should be distributed as evenly as possible. If the number of spaces on a line does not divide evenly between words, the empty slots on the left will be assigned more spaces than the slots on the right.\n\nFor the last line of text, it should be left-justified, and no extra space is inserted between words.\n\nNote:\n\nA word is defined as a character sequence consisting of non-space characters only.\nEach word's length is guaranteed to be greater than 0 and not exceed maxWidth.\nThe input array words contains at least one word.\n \n\nExample 1:\n\nInput: words = [\"This\", \"is\", \"an\", \"example\", \"of\", \"text\", \"justification.\"], maxWidth = 16\nOutput:\n[\n   \"This    is    an\",\n   \"example  of text\",\n   \"justification.  \"\n]\nExample 2:\n\nInput: words = [\"What\",\"must\",\"be\",\"acknowledgment\",\"shall\",\"be\"], maxWidth = 16\nOutput:\n[\n  \"What   must   be\",\n  \"acknowledgment  \",\n  \"shall be        \"\n]\nExplanation: Note that the last line is \"shall be    \" instead of \"shall     be\", because the last line must be left-justified instead of fully-justified.\nNote that the second line is also left-justified because it contains only one word.\nExample 3:\n\nInput: words = [\"Science\",\"is\",\"what\",\"we\",\"understand\",\"well\",\"enough\",\"to\",\"explain\",\"to\",\"a\",\"computer.\",\"Art\",\"is\",\"everything\",\"else\",\"we\",\"do\"], maxWidth = 20\nOutput:\n[\n  \"Science  is  what we\",\n  \"understand      well\",\n  \"enough to explain to\",\n  \"a  computer.  Art is\",\n  \"everything  else  we\",\n  \"do                  \"\n]\n \n\nConstraints:\n\n1 <= words.length <= 300\n1 <= words[i].length <= 20\nwords[i] consists of only English letters and symbols.\n1 <= maxWidth <= 100\nwords[i].length <= maxWidth\n        ",
        "tag":["Array","String","Simulation"],
        "answer":["\n        class Solution {\n            // blank 返回长度为 n 的由空格组成的字符串\n            string blank(int n) {\n                return string(n, ' ');\n            }\n        \n            // join 返回用 sep 拼接 [left, right) 范围内的 words 组成的字符串\n            string join(vector<string> &words, int left, int right, string sep) {\n                string s = words[left];\n                for (int i = left + 1; i < right; ++i) {\n                    s += sep + words[i];\n                }\n                return s;\n            }\n        \n        public:\n            vector<string> fullJustify(vector<string> &words, int maxWidth) {\n                vector<string> ans;\n                int right = 0, n = words.size();\n                while (true) {\n                    int left = right; // 当前行的第一个单词在 words 的位置\n                    int sumLen = 0; // 统计这一行单词长度之和\n                    // 循环确定当前行可以放多少单词，注意单词之间应至少有一个空格\n                    while (right < n && sumLen + words[right].length() + right - left <= maxWidth) {\n                        sumLen += words[right++].length();\n                    }\n        \n                    // 当前行是最后一行：单词左对齐，且单词之间应只有一个空格，在行末填充剩余空格\n                    if (right == n) {\n                        string s = join(words, left, n, \" \");\n                        ans.emplace_back(s + blank(maxWidth - s.length()));\n                        return ans;\n                    }\n        \n                    int numWords = right - left;\n                    int numSpaces = maxWidth - sumLen;\n        \n                    // 当前行只有一个单词：该单词左对齐，在行末填充剩余空格\n                    if (numWords == 1) {\n                        ans.emplace_back(words[left] + blank(numSpaces));\n                        continue;\n                    }\n        \n                    // 当前行不只一个单词\n                    int avgSpaces = numSpaces / (numWords - 1);\n                    int extraSpaces = numSpaces % (numWords - 1);\n                    string s1 = join(words, left, left + extraSpaces + 1, blank(avgSpaces + 1)); // 拼接额外加一个空格的单词\n                    string s2 = join(words, left + extraSpaces + 1, right, blank(avgSpaces)); // 拼接其余单词\n                    ans.emplace_back(s1 + blank(avgSpaces) + s2);\n                }\n            }\n        };\n        ","\n        class Solution {\n            public:\n                vector<string> fullJustify(vector<string>& words, int maxWidth) {\n                    int text,space;\n                    vector<string>v;\n                    string temp;\n                    int wordc=0;\n                    int s,ss;\n                    while(1){\n                        text=0;\n                        space=0;\n                        temp=\"\";\n                        while(1){\n                            if(wordc>=words.size()){\n                                break;\n                            }\n                            if(text==0){\n                                text+=words[wordc].length();\n                                temp+=words[wordc];\n                                wordc++;\n                                continue;\n                            }\n                            else{\n                                if(text+space+words[wordc].length()+1<=maxWidth){\n                                    text+=words[wordc].length();\n                                    space++;\n                                    temp+=' ';\n                                    temp+=words[wordc];\n                                    wordc++;\n                                    continue;\n                                }\n                                else{\n                                    if(space==0){\n                                        while(temp.length()<maxWidth){\n                                            temp+=' ';\n                                        }\n                                        v.push_back(temp); \n                                        break;\n                                    }\n                                    s=(maxWidth-text-space)/space;\n                                    ss=(maxWidth-text-space)%space;\n                                    for(int j=0;j<temp.length();j++){\n                                        if(temp[j]!=' '){\n                                            continue;\n                                        }\n                                        if(ss>0){\n                                            temp.insert(j,s+1,' ');\n                                            ss--;\n                                            space--;\n                                        }\n                                        else{\n                                            temp.insert(j,s,' ');\n                                            space--;\n                                        }\n                                        if(space==0){\n                                            break;\n                                        }\n                                        while(temp[j+1]==' '){\n                                            j++;\n                                        }\n                                    }\n                                    v.push_back(temp);\n                                    break;\n                                }\n                            }\n                        }\n                        if(wordc>=words.size()){\n                                break;\n                        }\n                    }\n                    if(temp!=\"\"){\n                        while(temp.length()<maxWidth){\n                            temp+=' ';\n                        }\n                        v.push_back(temp);\n                    }\n                    return v;\n                }\n            };\n        ","\n        \nclass Solution {\n    public:\n        void resPush(int maxWidth) {\n            //调用该函数将seq装入res中，并清空seq，将res置为0\n            int wordNums = seq.size();              //获取单词数\n            int allWordLen = nums - wordNums;       //获取单词总长度(nums为计数器长度)\n            int blanknums = maxWidth - allWordLen;  //获取填充空白的数量\n            //开始装入，如果单词数只有1，则全部填充空白\n            if (wordNums == 1) {\n                string blank = string(blanknums, ' ');\n                res.push_back(seq[0] + blank);\n            }\n            else {\n                //如果单词数>=2,则需要分配wordNums-1个格子的空格\n                int n = wordNums - 1;   //表示要分配空格的位置数\n                //如果空格刚好可以均分,则每个格子分blanknums/n个空格，除去最后一个单词，其余单词都附带上空格\n                if (blanknums % n == 0) {\n                    string blank = string(blanknums / n, ' ');\n                    string thisLine;\n                    for (int i = 0; i < wordNums - 1; i++) thisLine += seq[i] + blank;\n                    res.push_back(thisLine + seq[wordNums - 1]);\n                }\n                else {\n                    //如果不够均分空格，就先平分，再给前面的多发\n                    int avaBlankNums = blanknums / n;                   //平分后必有剩余\n                    int remainBlank = blanknums - n * avaBlankNums;     //先给前面的部后面的不补\n                    string preBlank = string(avaBlankNums + 1, ' '); \n                    string lastBlank = string(avaBlankNums, ' ');\n                    string thisLine;\n                    for (int i = 0; i < remainBlank; i++) thisLine += seq[i] + preBlank;\n                    for(int i = remainBlank; i < wordNums-1; i++) thisLine += seq[i] + lastBlank;\n                    thisLine += seq[wordNums - 1];\n                    res.push_back(thisLine);\n                }\n            }\n            seq.clear();\n            nums = 0;\n        }\n    \n        vector<string> fullJustify(vector<string>& words, int maxWidth) {\n            nums = 0;\n            //每个单词跟一个空格\n            for (auto &word : words) {\n                int woLen = word.size();\n                if (nums + woLen > maxWidth) resPush(maxWidth);  //如果队列装不下了，就将seq装入res，清空seq\n                seq.push_back(word);                    //将word装入seq，修改nums\n                nums += woLen + 1;                        //因为每个单词要预留至少一个空格，所以额外+1\n            }\n            //使最后一行每个单词只有1个空格,并装入\n            if (nums > maxWidth && seq.size() == 1) res.push_back(seq[0]); //如果最后一个单词的长度为maxWidth，则直接装入\n            else {\n                string last;\n                int n = seq.size();         //读取最后一行单词数\n                for (int i = 0; i < n - 1; i++) last += seq[i] + ' ';\n                last += seq[n - 1];\n                //给最后一行补充空格\n                int blankNums = maxWidth - last.size();\n                res.push_back(last + string(blankNums,' '));\n            }\n            return res;\n        }\n    \n    private:\n        vector<string> res;     //存储答案\n        vector<string> seq;     //存储已经装入的单词\n        int nums;               //记录长度\n    };\n        "]
    },
    {
        "id":51,
        "description":"\n        Given a non-negative integer x, return the square root of x rounded down to the nearest integer. The returned integer should be non-negative as well.\n\nYou must not use any built-in exponent function or operator.\n\nFor example, do not use pow(x, 0.5) in c++ or x ** 0.5 in python.\n \n\nExample 1:\n\nInput: x = 4\nOutput: 2\nExplanation: The square root of 4 is 2, so we return 2.\nExample 2:\n\nInput: x = 8\nOutput: 2\nExplanation: The square root of 8 is 2.82842..., and since we round it down to the nearest integer, 2 is returned.\n \n\nConstraints:\n\n0 <= x <= 2^31 - 1\n        ",
        "tag":["Math","Binary Search"],
        "answer":["\n        class Solution {\n            public:\n                int mySqrt(int x) {\n                    if (x == 0) {\n                        return 0;\n                    }\n                    int ans = exp(0.5 * log(x));\n                    return ((long long)(ans + 1) * (ans + 1) <= x ? ans + 1 : ans);\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int mySqrt(int x) {\n                    int l = 0, r = x, ans = -1;\n                    while (l <= r) {\n                        int mid = l + (r - l) / 2;\n                        if ((long long)mid * mid <= x) {\n                            ans = mid;\n                            l = mid + 1;\n                        } else {\n                            r = mid - 1;\n                        }\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int mySqrt(int x) {\n                    if (x == 0) {\n                        return 0;\n                    }\n            \n                    double C = x, x0 = x;\n                    while (true) {\n                        double xi = 0.5 * (x0 + C / x0);\n                        if (fabs(x0 - xi) < 1e-7) {\n                            break;\n                        }\n                        x0 = xi;\n                    }\n                    return int(x0);\n                }\n            };\n        "]
    },
    {
        "id":52,
        "description":"\n        You are climbing a staircase. It takes n steps to reach the top.\n\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\n\n \n\nExample 1:\n\nInput: n = 2\nOutput: 2\nExplanation: There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps\nExample 2:\n\nInput: n = 3\nOutput: 3\nExplanation: There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step\n \n\nConstraints:\n\n1 <= n <= 45\n        ",
        "tag":["Memoization","Math","Dynamic Programming"],
        "answer":["\n        class Solution {\n            public:\n                int climbStairs(int n) {\n                    int p = 0, q = 0, r = 1;\n                    for (int i = 1; i <= n; ++i) {\n                        p = q; \n                        q = r; \n                        r = p + q;\n                    }\n                    return r;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<vector<long long>> multiply(vector<vector<long long>> &a, vector<vector<long long>> &b) {\n                    vector<vector<long long>> c(2, vector<long long>(2));\n                    for (int i = 0; i < 2; i++) {\n                        for (int j = 0; j < 2; j++) {\n                            c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];\n                        }\n                    }\n                    return c;\n                }\n            \n                vector<vector<long long>> matrixPow(vector<vector<long long>> a, int n) {\n                    vector<vector<long long>> ret = {{1, 0}, {0, 1}};\n                    while (n > 0) {\n                        if ((n & 1) == 1) {\n                            ret = multiply(ret, a);\n                        }\n                        n >>= 1;\n                        a = multiply(a, a);\n                    }\n                    return ret;\n                }\n            \n                int climbStairs(int n) {\n                    vector<vector<long long>> ret = {{1, 1}, {1, 0}};\n                    vector<vector<long long>> res = matrixPow(ret, n);\n                    return res[0][0];\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int climbStairs(int n) {\n                    double sqrt5 = sqrt(5);\n                    double fibn = pow((1 + sqrt5) / 2, n + 1) - pow((1 - sqrt5) / 2, n + 1);\n                    return (int)round(fibn / sqrt5);\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int climbStairs(int n) {\n                    double f = pow((1 + sqrt(5)) / 2, n + 1) - pow((1 - sqrt(5)) / 2, n + 1); \n                    return int(f / sqrt(5));\n                }\n            };\n        "]
    },
    {
        "id":53,
        "description":"\n        Given a string path, which is an absolute path (starting with a slash '/') to a file or directory in a Unix-style file system, convert it to the simplified canonical path.\n\nIn a Unix-style file system, a period '.' refers to the current directory, a double period '..' refers to the directory up a level, and any multiple consecutive slashes (i.e. '//') are treated as a single slash '/'. For this problem, any other format of periods such as '...' are treated as file/directory names.\n\nThe canonical path should have the following format:\n\nThe path starts with a single slash '/'.\nAny two directories are separated by a single slash '/'.\nThe path does not end with a trailing '/'.\nThe path only contains the directories on the path from the root directory to the target file or directory (i.e., no period '.' or double period '..')\nReturn the simplified canonical path.\n\n \n\nExample 1:\n\nInput: path = \"/home/\"\nOutput: \"/home\"\nExplanation: Note that there is no trailing slash after the last directory name.\nExample 2:\n\nInput: path = \"/../\"\nOutput: \"/\"\nExplanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go.\nExample 3:\n\nInput: path = \"/home//foo/\"\nOutput: \"/home/foo\"\nExplanation: In the canonical path, multiple consecutive slashes are replaced by a single one.\n \n\nConstraints:\n\n1 <= path.length <= 3000\npath consists of English letters, digits, period '.', slash '/' or '_'.\npath is a valid absolute Unix path.\n        ",
        "tag":["Stack","String"],
        "answer":["\n        class Solution {\n            public:\n                string simplifyPath(string path) {\n                    auto split = [](const string& s, char delim) -> vector<string> {\n                        vector<string> ans;\n                        string cur;\n                        for (char ch: s) {\n                            if (ch == delim) {\n                                ans.push_back(move(cur));\n                                cur.clear();\n                            }\n                            else {\n                                cur += ch;\n                            }\n                        }\n                        ans.push_back(move(cur));\n                        return ans;\n                    };\n            \n                    vector<string> names = split(path, '/');\n                    vector<string> stack;\n                    for (string& name: names) {\n                        if (name == \"..\") {\n                            if (!stack.empty()) {\n                                stack.pop_back();\n                            }\n                        }\n                        else if (!name.empty() && name != \".\") {\n                            stack.push_back(move(name));\n                        }\n                    }\n                    string ans;\n                    if (stack.empty()) {\n                        ans = \"/\";\n                    }\n                    else {\n                        for (string& name: stack) {\n                            ans += \"/\" + move(name);\n                        }\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                string simplifyPath(string path) {\n                    vector<string> name;\n                    string buf;\n                    for(int i = 0;i < path.length();i++)\n                    {\n                        if(path[i] == '/') path[i] = ' ';\n                    }\n                    stringstream ss(path);\n                    while(ss >> buf)\n                    {\n                        name.push_back(buf);\n                    }\n            \n                    vector<string> result;\n            \n                    for(vector<string>::iterator it = name.begin(); it != name.end(); it++)\n                    {\n                        if(*it == \"..\") \n                        {\n                            if(!result.empty()) \n                            {\n                                result.pop_back();\n                            }\n                        }\n                        else if(*it == \".\") {}\n                        else result.push_back(*it);\n                    }\n                    if(result.empty()) return \"/\";\n                    else\n                    {\n                            string s;\n                            for(vector<string>::iterator it = result.begin(); it != result.end(); it++)\n                            {\n                                s += '/';\n                                s += *it;\n                            }\n                            return s;\n                    }\n                }\n            };\n        ","\n        class Solution {\n            public:\n                string simplifyPath(string path) \n                {\n                    deque<string> d;\n                    int size = path.size();\n                    for (int i = 0; i < size; ++i)\n                    {\n                        if (path[i] == '/')\n                            continue;\n                        string temp;\n                        while (i < size && path[i] != '/')\n                            temp += path[i++];\n                        if (temp == \".\")\n                            continue;\n                        else if (temp == \"..\")\n                        {\n                            if (d.size() == 0);\n                            else\n                                d.pop_back();\n                        }\n                        else\n                            d.push_back(temp);\n                    }\n                    string s;\n                    int n = d.size();\n                    for (int i = 0; i < n; ++i)\n                    {\n                        s += d[i];\n                        s += '/';\n                    }\n                    s = '/' + s;\n                    if (s.size() != 1)\n                        s.pop_back();\n                    return s;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                std::string simplifyPath(std::string path) {\n                    std::string res = \"\";\n                    std::deque<std::string> q;\n                    int n = path.size();\n                    for(int i = 0; i < n; i++)\n                    {\n                        if(path[i] == '/') continue;  //遇到\"/\"跳过\n                        std::string temp = \"\";\n                        while (i < n && path[i] != '/')\n                        {\n                            temp.push_back(path[i++]);\n                        }\n                        //本级\n                        if(temp == \".\") continue;\n                        //返回上一级\n                        else if(temp == \"..\")\n                        {\n                            if(!q.empty()) q.pop_back();\n                        }\n                        //有效目录\n                        else q.push_back(temp);\n                    }\n                    while (!q.empty())\n                    {\n                        res += \"/\" + q.front();\n                        q.pop_front();\n                    }\n                    if(res.size() == 0) res += \"/\";\n                    return res;\n                }\n            };\n        "]
    },
    {
        "id":54,
        "description":"\n        Given two strings word1 and word2, return the minimum number of operations required to convert word1 to word2.\n\nYou have the following three operations permitted on a word:\n\nInsert a character\nDelete a character\nReplace a character\n \n\nExample 1:\n\nInput: word1 = \"horse\", word2 = \"ros\"\nOutput: 3\nExplanation: \nhorse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')\nExample 2:\n\nInput: word1 = \"intention\", word2 = \"execution\"\nOutput: 5\nExplanation: \nintention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')\n \n\nConstraints:\n\n0 <= word1.length, word2.length <= 500\nword1 and word2 consist of lowercase English letters.\n        ",
        "tag":["String","Dynamic Programming"],
        "answer":["\n        class Solution {\n            public:\n                int minDistance(string word1, string word2) {\n                    int n = word1.length();\n                    int m = word2.length();\n            \n                    // 有一个字符串为空串\n                    if (n * m == 0) return n + m;\n            \n                    // DP 数组\n                    vector<vector<int>> D(n + 1, vector<int>(m + 1));\n            \n                    // 边界状态初始化\n                    for (int i = 0; i < n + 1; i++) {\n                        D[i][0] = i;\n                    }\n                    for (int j = 0; j < m + 1; j++) {\n                        D[0][j] = j;\n                    }\n            \n                    // 计算所有 DP 值\n                    for (int i = 1; i < n + 1; i++) {\n                        for (int j = 1; j < m + 1; j++) {\n                            int left = D[i - 1][j] + 1;\n                            int down = D[i][j - 1] + 1;\n                            int left_down = D[i - 1][j - 1];\n                            if (word1[i - 1] != word2[j - 1]) left_down += 1;\n                            D[i][j] = min(left, min(down, left_down));\n            \n                        }\n                    }\n                    return D[n][m];\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int minDistance(string word1, string word2) {\n                    vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1, 0));\n            \n                    for (int i = 0; i < dp.size(); i++) {\n                        dp[i][0] = i;\n                    }\n                    for (int j = 0; j < dp[0].size(); j++) {\n                        dp[0][j] = j;\n                    }\n            \n                    for (int i = 1; i < dp.size(); i++) {\n                        for (int j = 1; j < dp[i].size(); j++) {\n                            dp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1;\n                            if (word1[i - 1] == word2[j - 1]) {\n                                dp[i][j] = min(dp[i][j], dp[i - 1][j - 1]);\n                            }\n                        }\n                    }\n                    return dp.back().back();\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int minDistance(string s, string t) {\n                    int n = s.length(), m = t.length(), memo[n + 1][m + 1];\n                    memset(memo, -1, sizeof(memo)); // -1 表示还没有计算过\n                    function<int(int, int)> dfs = [&](int i, int j) -> int {\n                        if (i < 0) return j + 1;\n                        if (j < 0) return i + 1;\n                        int &res = memo[i][j];\n                        if (res != -1) return res;\n                        if (s[i] == t[j]) return res = dfs(i - 1, j - 1);\n                        return res = min(min(dfs(i - 1, j), dfs(i, j - 1)), dfs(i - 1, j - 1)) + 1;\n                    };\n                    return dfs(n - 1, m - 1);\n                }\n            };\n        "]
    },
    {
        "id":55,
        "description":"\n        Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\n\nWe will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\n\nYou must solve this problem without using the library's sort function.\n\n \n\nExample 1:\n\nInput: nums = [2,0,2,1,1,0]\nOutput: [0,0,1,1,2,2]\nExample 2:\n\nInput: nums = [2,0,1]\nOutput: [0,1,2]\n \n\nConstraints:\n\nn == nums.length\n1 <= n <= 300\nnums[i] is either 0, 1, or 2.\n        ",
        "tag":["Array","Two Pointers","Sorting"],
        "answer":["\n        class Solution {\n            public:\n                void sortColors(vector<int>& nums) {\n                    int n = nums.size();\n                    int ptr = 0;\n                    for (int i = 0; i < n; ++i) {\n                        if (nums[i] == 0) {\n                            swap(nums[i], nums[ptr]);\n                            ++ptr;\n                        }\n                    }\n                    for (int i = ptr; i < n; ++i) {\n                        if (nums[i] == 1) {\n                            swap(nums[i], nums[ptr]);\n                            ++ptr;\n                        }\n                    }\n                }\n            };\n        ","\n        class Solution {\n            public:\n                void sortColors(vector<int>& nums) {\n                    int n = nums.size();\n                    int p0 = 0, p1 = 0;\n                    for (int i = 0; i < n; ++i) {\n                        if (nums[i] == 1) {\n                            swap(nums[i], nums[p1]);\n                            ++p1;\n                        } else if (nums[i] == 0) {\n                            swap(nums[i], nums[p0]);\n                            if (p0 < p1) {\n                                swap(nums[i], nums[p1]);\n                            }\n                            ++p0;\n                            ++p1;\n                        }\n                    }\n                }\n            };\n        ","\n        class Solution {\n            public:\n                void sortColors(vector<int>& nums) {\n                    int n = nums.size();\n                    int p0 = 0, p2 = n - 1;\n                    for (int i = 0; i <= p2; ++i) {\n                        while (i <= p2 && nums[i] == 2) {\n                            swap(nums[i], nums[p2]);\n                            --p2;\n                        }\n                        if (nums[i] == 0) {\n                            swap(nums[i], nums[p0]);\n                            ++p0;\n                        }\n                    }\n                }\n            };\n        "]
    },
    {
        "id":56,
        "description":"\n        Given two strings s and t of lengths m and n respectively, return the minimum window \nsubstring\n of s such that every character in t (including duplicates) is included in the window. If there is no such substring, return the empty string \"\".\n\nThe testcases will be generated such that the answer is unique.\n\n \n\nExample 1:\n\nInput: s = \"ADOBECODEBANC\", t = \"ABC\"\nOutput: \"BANC\"\nExplanation: The minimum window substring \"BANC\" includes 'A', 'B', and 'C' from string t.\nExample 2:\n\nInput: s = \"a\", t = \"a\"\nOutput: \"a\"\nExplanation: The entire string s is the minimum window.\nExample 3:\n\nInput: s = \"a\", t = \"aa\"\nOutput: \"\"\nExplanation: Both 'a's from t must be included in the window.\nSince the largest window of s only has one 'a', return empty string.\n \n\nConstraints:\n\nm == s.length\nn == t.length\n1 <= m, n <= 10^5\ns and t consist of uppercase and lowercase English letters.\n        ",
        "tag":["Hash Table","String","Sliding Window"],
        "answer":["\n        class Solution {\n            public:\n                unordered_map <char, int> ori, cnt;\n            \n                bool check() {\n                    for (const auto &p: ori) {\n                        if (cnt[p.first] < p.second) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n            \n                string minWindow(string s, string t) {\n                    for (const auto &c: t) {\n                        ++ori[c];\n                    }\n            \n                    int l = 0, r = -1;\n                    int len = INT_MAX, ansL = -1, ansR = -1;\n            \n                    while (r < int(s.size())) {\n                        if (ori.find(s[++r]) != ori.end()) {\n                            ++cnt[s[r]];\n                        }\n                        while (check() && l <= r) {\n                            if (r - l + 1 < len) {\n                                len = r - l + 1;\n                                ansL = l;\n                            }\n                            if (ori.find(s[l]) != ori.end()) {\n                                --cnt[s[l]];\n                            }\n                            ++l;\n                        }\n                    }\n            \n                    return ansL == -1 ? string() : s.substr(ansL, len);\n                }\n            };\n        ","\n        class Solution {\n            public:\n                string minWindow(string s, string t) {\n                    unordered_map<char, int> hs, ht;\n                    for (auto c: t) ht[c] ++ ;\n                    string res;\n                    int cnt = 0;\n                    for (int i = 0, j = 0; i < s.size(); i ++ ) {\n                        hs[s[i]] ++ ;\n                        if (hs[s[i]] <= ht[s[i]]) cnt ++ ;\n            \n                        while (hs[s[j]] > ht[s[j]]) hs[s[j ++ ]] -- ;\n                        if (cnt == t.size()) {\n                            if (res.empty() || i - j + 1 < res.size())\n                                res = s.substr(j, i - j + 1);\n                        }\n                    }\n                    return res;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                string minWindow(string s, string t) {\n                    //设置哈希表用来存放窗口值以及进行比较的值\n                    unordered_map<char, int> need, win;\n                    //将我们所需要的值加入到哈希表（需要进行比较的值）\n                    for (auto &i : t) ++need[i];\n                    int left = 0, right = 0, count = 0, len = INT_MAX, start = 0;\n                    //开始对窗口进行处理\n                    while (right < s.size()) {\n                        //如果我们此时字符串中的元素在我们的需要窗口中的话\n                        //我们就需要扩充窗口\n                        if (need.find(s[right]) != need.end()) {\n                            //此时进行扩充窗口\n                            ++win[s[right]];\n                            //运用count来进行确保我们此时的窗口值完全覆盖了我们需要的子串\n                            if (win[s[right]] == need[s[right]]) {\n                                ++count;\n                            }\n                        }\n                        //如果此时的窗口值完全覆盖了我们需要的子串，就要进行缩小窗口的操作\n                        while (count == need.size()) {\n                            //这里是进行更新我们的最小子串\n                            if (len > right - left + 1) {\n                                start = left;\n                                len = right - left + 1;\n                            }\n                            //这里开始对窗口进行处理\n                            //如果此时的窗口左侧的值在我们的哈希表中的话\n                            //就要进行判断是否要对count进行处理\n                            if (need.find(s[left]) != need.end()) {\n                                //如果此时的窗口左侧的值在哈希表中且数量和哈希表中的数量一致\n                                //就对count计数位进行减一操作\n                                if (need[s[left]] == win[s[left]]) {\n                                    --count;\n                                }\n                                //将窗口左侧的值进行减一，缩小窗口\n                                --win[s[left]];\n                            }\n                            ++left;\n                        }\n                        ++right;\n                    }\n                    return len == INT_MAX ? \"\" : s.substr(start, len);\n                }\n            };\n        "]
    },
    {
        "id":57,
        "description":"\n        Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].\n\nYou may return the answer in any order.\n\n \n\nExample 1:\n\nInput: n = 4, k = 2\nOutput: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]\nExplanation: There are 4 choose 2 = 6 total combinations.\nNote that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination.\nExample 2:\n\nInput: n = 1, k = 1\nOutput: [[1]]\nExplanation: There is 1 choose 1 = 1 total combination.\n \n\nConstraints:\n\n1 <= n <= 20\n1 <= k <= n\n        ",
        "tag":["Backtracking"],
        "answer":["\n        class Solution {\n            public:\n                vector<int> temp;\n                vector<vector<int>> ans;\n            \n                void dfs(int cur, int n, int k) {\n                    // 剪枝：temp 长度加上区间 [cur, n] 的长度小于 k，不可能构造出长度为 k 的 temp\n                    if (temp.size() + (n - cur + 1) < k) {\n                        return;\n                    }\n                    // 记录合法的答案\n                    if (temp.size() == k) {\n                        ans.push_back(temp);\n                        return;\n                    }\n                    // 考虑选择当前位置\n                    temp.push_back(cur);\n                    dfs(cur + 1, n, k);\n                    temp.pop_back();\n                    // 考虑不选择当前位置\n                    dfs(cur + 1, n, k);\n                }\n            \n                vector<vector<int>> combine(int n, int k) {\n                    dfs(1, n, k);\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<int> temp;\n                vector<vector<int>> ans;\n            \n                vector<vector<int>> combine(int n, int k) {\n                    // 初始化\n                    // 将 temp 中 [0, k - 1] 每个位置 i 设置为 i + 1，即 [0, k - 1] 存 [1, k]\n                    // 末尾加一位 n + 1 作为哨兵\n                    for (int i = 1; i <= k; ++i) {\n                        temp.push_back(i);\n                    }\n                    temp.push_back(n + 1);\n                    \n                    int j = 0;\n                    while (j < k) {\n                        ans.emplace_back(temp.begin(), temp.begin() + k);\n                        j = 0;\n                        // 寻找第一个 temp[j] + 1 != temp[j + 1] 的位置 t\n                        // 我们需要把 [0, t - 1] 区间内的每个位置重置成 [1, t]\n                        while (j < k && temp[j] + 1 == temp[j + 1]) {\n                            temp[j] = j + 1;\n                            ++j;\n                        }\n                        // j 是第一个 temp[j] + 1 != temp[j + 1] 的位置\n                        ++temp[j];\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<vector<int>> combine(int n, int k) {\n                    vector<vector<int>> ans;\n                    vector<int> path;\n                    function<void(int)> dfs = [&](int i) {\n                        int d = k - path.size(); // 还要选 d 个数\n                        if (d == 0) {\n                            ans.emplace_back(path);\n                            return;\n                        }\n                        for (int j = i; j >= d; --j) {\n                            path.push_back(j);\n                            dfs(j - 1);\n                            path.pop_back();\n                        }\n                    };\n                    dfs(n);\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<vector<int>> combine(int n, int k) {\n                    vector<vector<int>> ans;\n                    vector<int> path;\n                    function<void(int)> dfs = [&](int i) {\n                        int d = k - path.size(); // 还要选 d 个数\n                        if (d == 0) {\n                            ans.emplace_back(path);\n                            return;\n                        }\n                        // 不选 i\n                        if (i > d) dfs(i - 1);\n                        // 选 i\n                        path.push_back(i);\n                        dfs(i - 1);\n                        path.pop_back();\n                    };\n                    dfs(n);\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            private:\n                vector<vector<int>> result; // 存放符合条件结果的集合\n                vector<int> path; // 用来存放符合条件结果\n                void backtracking(int n, int k, int startIndex) {\n                    if (path.size() == k) {\n                        result.push_back(path);\n                        return;\n                    }\n                    for (int i = startIndex; i <= n; i++) {\n                        path.push_back(i); // 处理节点 \n                        backtracking(n, k, i + 1); // 递归\n                        path.pop_back(); // 回溯，撤销处理的节点\n                    }\n                }\n            public:\n                vector<vector<int>> combine(int n, int k) {\n                    result.clear(); // 可以不写\n                    path.clear();   // 可以不写\n                    backtracking(n, k, 1);\n                    return result;\n                }\n            };\n        "]
    },
    {
        "id":58,
        "description":"\n        Given an integer array nums of unique elements, return all possible \nsubsets\n (the power set).\n\nThe solution set must not contain duplicate subsets. Return the solution in any order.\n\n \n\nExample 1:\n\nInput: nums = [1,2,3]\nOutput: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\nExample 2:\n\nInput: nums = [0]\nOutput: [[],[0]]\n \n\nConstraints:\n\n1 <= nums.length <= 10\n-10 <= nums[i] <= 10\nAll the numbers of nums are unique.\n        ",
        "tag":["Bit Manipulation","Array","Backtracking"],
        "answer":["\n        class Solution {\n            public:\n                vector<int> t;\n                vector<vector<int>> ans;\n            \n                vector<vector<int>> subsets(vector<int>& nums) {\n                    int n = nums.size();\n                    for (int mask = 0; mask < (1 << n); ++mask) {\n                        t.clear();\n                        for (int i = 0; i < n; ++i) {\n                            if (mask & (1 << i)) {\n                                t.push_back(nums[i]);\n                            }\n                        }\n                        ans.push_back(t);\n                    }\n                    return ans;\n                }\n            };\n            ","\n            class Solution {\n                public:\n                    vector<int> t;\n                    vector<vector<int>> ans;\n                \n                    void dfs(int cur, vector<int>& nums) {\n                        if (cur == nums.size()) {\n                            ans.push_back(t);\n                            return;\n                        }\n                        t.push_back(nums[cur]);\n                        dfs(cur + 1, nums);\n                        t.pop_back();\n                        dfs(cur + 1, nums);\n                    }\n                \n                    vector<vector<int>> subsets(vector<int>& nums) {\n                        dfs(0, nums);\n                        return ans;\n                    }\n                };\n            ","\n            class Solution {\n                public:\n                    vector<vector<int>> subsets(vector<int> &nums) {\n                        vector<vector<int>> ans;\n                        vector<int> path;\n                        int n = nums.size();\n                        function<void(int)> dfs = [&](int i) {\n                            if (i == n) {\n                                ans.emplace_back(path);\n                                return;\n                            }\n                            // 不选 nums[i]\n                            dfs(i + 1);\n                            // 选 nums[i]\n                            path.push_back(nums[i]);\n                            dfs(i + 1);\n                            path.pop_back(); // 恢复现场\n                        };\n                        dfs(0);\n                        return ans;\n                    }\n                };\n            ","\n            class Solution {\n                public:\n                    vector<vector<int>> subsets(vector<int> &nums) {\n                        vector<vector<int>> ans;\n                        vector<int> path;\n                        int n = nums.size();\n                        function<void(int)> dfs = [&](int i) {\n                            ans.emplace_back(path);\n                            if (i == n) return;\n                            for (int j = i; j < n; ++j) { // 枚举选择的数字\n                                path.push_back(nums[j]);\n                                dfs(j + 1);\n                                path.pop_back(); // 恢复现场\n                            }\n                        };\n                        dfs(0);\n                        return ans;\n                    }\n                };\n            "]
    },
    {
        "id":59,
        "description":"\n        Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\n\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\n\nReturn k after placing the final result in the first k slots of nums.\n\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\n\nCustom Judge:\n\nThe judge will test your solution with the following code:\n\nint[] nums = [...]; // Input array\nint[] expectedNums = [...]; // The expected answer with correct length\n\nint k = removeDuplicates(nums); // Calls your implementation\n\nassert k == expectedNums.length;\nfor (int i = 0; i < k; i++) {\n    assert nums[i] == expectedNums[i];\n}\nIf all assertions pass, then your solution will be accepted.\n\n \n\nExample 1:\n\nInput: nums = [1,1,1,2,2,3]\nOutput: 5, nums = [1,1,2,2,3,_]\nExplanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\nExample 2:\n\nInput: nums = [0,0,1,1,1,1,2,3,3]\nOutput: 7, nums = [0,0,1,1,2,3,3,_,_]\nExplanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively.\nIt does not matter what you leave beyond the returned k (hence they are underscores).\n \n\nConstraints:\n\n1 <= nums.length <= 3 * 10^4\n-10^4 <= nums[i] <= 10^4\nnums is sorted in non-decreasing order.\n        ",
        "tag":["Array","Two Pointers"],
        "answer":["\n        class Solution {\n            public:\n                int removeDuplicates(vector<int>& nums) {\n                    int n = nums.size();\n                    if (n <= 2) {\n                        return n;\n                    }\n                    int slow = 2, fast = 2;\n                    while (fast < n) {\n                        if (nums[slow - 2] != nums[fast]) {\n                            nums[slow] = nums[fast];\n                            ++slow;\n                        }\n                        ++fast;\n                    }\n                    return slow;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int work(vector<int>& nums, int k) {\n                    int len = 0;\n                    for(auto num : nums)\n                        if(len < k || nums[len-k] != num)\n                            nums[len++] = num;\n                    return len;\n                }\n                int removeDuplicates(vector<int>& nums) {\n                    return work(nums, 2);\n                }\n            };\n        ","\n        int removeDuplicates(vector<int>& nums) {\n            int slow=0,fast=0;\n            while(fast<nums.size()) {\n                if(fast<2||nums[fast]!=nums[slow-2]) {// 此时fast所指的元素就是需要保留的元素\n                    nums[slow]=nums[fast];\n                    slow++;// 由于已经维护的无重复数组新加入了一个元素，因此slow指针需要后移\n                }\n                fast++;\n            }\n            return slow;// 返回删除后数组的长度\n        }\n        "]
    },
    {
        "id":60,
        "description":"\n        There is an integer array nums sorted in non-decreasing order (not necessarily with distinct values).\n\nBefore being passed to your function, nums is rotated at an unknown pivot index k (0 <= k < nums.length) such that the resulting array is [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]] (0-indexed). For example, [0,1,2,4,4,4,5,6,6,7] might be rotated at pivot index 5 and become [4,5,6,6,7,0,1,2,4,4].\n\nGiven the array nums after the rotation and an integer target, return true if target is in nums, or false if it is not in nums.\n\nYou must decrease the overall operation steps as much as possible.\n\n \n\nExample 1:\n\nInput: nums = [2,5,6,0,0,1,2], target = 0\nOutput: true\nExample 2:\n\nInput: nums = [2,5,6,0,0,1,2], target = 3\nOutput: false\n \n\nConstraints:\n\n1 <= nums.length <= 5000\n-10^4 <= nums[i] <= 10^4\nnums is guaranteed to be rotated at some pivot.\n-10^4 <= target <= 10^4\n        ",
        "tag":["Array","Binary Search"],
        "answer":["\n        class Solution {\n            public:\n                bool search(vector<int> &nums, int target) {\n                    int n = nums.size();\n                    if (n == 0) {\n                        return false;\n                    }\n                    if (n == 1) {\n                        return nums[0] == target;\n                    }\n                    int l = 0, r = n - 1;\n                    while (l <= r) {\n                        int mid = (l + r) / 2;\n                        if (nums[mid] == target) {\n                            return true;\n                        }\n                        if (nums[l] == nums[mid] && nums[mid] == nums[r]) {\n                            ++l;\n                            --r;\n                        } else if (nums[l] <= nums[mid]) {\n                            if (nums[l] <= target && target < nums[mid]) {\n                                r = mid - 1;\n                            } else {\n                                l = mid + 1;\n                            }\n                        } else {\n                            if (nums[mid] < target && target <= nums[n - 1]) {\n                                l = mid + 1;\n                            } else {\n                                r = mid - 1;\n                            }\n                        }\n                    }\n                    return false;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool search(vector<int>& nums, int t) {\n                    int n = nums.size();\n                    int l = 0, r = n - 1;\n                    // 恢复二段性\n                    while (l < r && nums[0] == nums[r]) r--;\n            \n                    // 第一次二分，找旋转点\n                    while (l < r) {\n                        int mid = (l + r + 1) >> 1;\n                        if (nums[mid] >= nums[0]) {\n                            l = mid;\n                        } else {\n                            r = mid - 1;\n                        }\n                    }\n                    \n                    int idx = n;\n                    if (nums[r] >= nums[0] && r + 1 < n) idx = r + 1;\n            \n                    // 第二次二分，找目标值\n                    int ans = find(nums, 0, idx - 1, t);\n                    if (ans != -1) return true;\n                    ans = find(nums, idx, n - 1, t);\n                    return ans != -1;\n                }\n            \n                int find(vector<int>& nums, int l, int r, int t) {\n                    while (l < r) {\n                        int mid = l + r >> 1;\n                        if (nums[mid] >= t) {\n                            r = mid;\n                        } else {\n                            l = mid + 1;\n                        }\n                    }\n                    return nums[r] == t ? r : -1;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool search(vector<int>& nums, int target) {\n                    //恢复二段性\n                    int l=0;\n                    int n=nums.size();\n                    int r=nums.size()-1;\n                    int nn;\n                    while(r>0&&nums[r]==nums[0]){\n                        r--;\n                    }\n                    //找分段点\n                    while(l<r){\n                        int mid=(l+r+1)/2;\n                        if(nums[mid]>=nums[0]){\n                            l=mid;\n                        }else{\n                            r=mid-1;\n                        }\n                    }\n                    int idx=n;\n                    if(nums[r]>=nums[0]&&r+1<n){\n                        idx=r+1;\n                    }\n                    //此时将原始数组划分为了两个区间\n                    //左：[l,idx-1]\n                    //右：[idx,r]\n                    l=0;\n                    r=idx-1;\n                    if(nums[r]==target){\n                        return true;\n                    }\n                    while(l<r){\n                        int mid=(l+r)/2;\n                        if(nums[mid]==target){\n                            return true;\n                        }else if(nums[mid]>target){\n                            r=mid;\n                        }else{\n                            l=mid+1;\n                        }\n                    }\n                    l=idx;\n                    r=n-1;\n                    if(nums[r]==target){\n                        return true;\n                    }\n                    while(l<r){\n                        int mid=(l+r)/2;\n                        if(nums[mid]==target){\n                            return true;\n                        }else if(nums[mid]>target){\n                            r=mid;\n                        }else{\n                            l=mid+1;\n                        }\n                    }\n                    return false;\n                }\n            };\n        "]
    },
    {
        "id":61,
        "description":"\n        We can scramble a string s to get a string t using the following algorithm:\n\nIf the length of the string is 1, stop.\nIf the length of the string is > 1, do the following:\nSplit the string into two non-empty substrings at a random index, i.e., if the string is s, divide it to x and y where s = x + y.\nRandomly decide to swap the two substrings or to keep them in the same order. i.e., after this step, s may become s = x + y or s = y + x.\nApply step 1 recursively on each of the two substrings x and y.\nGiven two strings s1 and s2 of the same length, return true if s2 is a scrambled string of s1, otherwise, return false.\n\n \n\nExample 1:\n\nInput: s1 = \"great\", s2 = \"rgeat\"\nOutput: true\nExplanation: One possible scenario applied on s1 is:\n\"great\" --> \"gr/eat\" // divide at random index.\n\"gr/eat\" --> \"gr/eat\" // random decision is not to swap the two substrings and keep them in order.\n\"gr/eat\" --> \"g/r / e/at\" // apply the same algorithm recursively on both substrings. divide at random index each of them.\n\"g/r / e/at\" --> \"r/g / e/at\" // random decision was to swap the first substring and to keep the second substring in the same order.\n\"r/g / e/at\" --> \"r/g / e/ a/t\" // again apply the algorithm recursively, divide \"at\" to \"a/t\".\n\"r/g / e/ a/t\" --> \"r/g / e/ a/t\" // random decision is to keep both substrings in the same order.\nThe algorithm stops now, and the result string is \"rgeat\" which is s2.\nAs one possible scenario led s1 to be scrambled to s2, we return true.\nExample 2:\n\nInput: s1 = \"abcde\", s2 = \"caebd\"\nOutput: false\nExample 3:\n\nInput: s1 = \"a\", s2 = \"a\"\nOutput: true\n \n\nConstraints:\n\ns1.length == s2.length\n1 <= s1.length <= 30\ns1 and s2 consist of lowercase English letters.\n        ",
        "tag":["String","Dynamic Programming"],
        "answer":["\n        class Solution {\n            private:\n                // 记忆化搜索存储状态的数组\n                // -1 表示 false，1 表示 true，0 表示未计算\n                int memo[30][30][31];\n                string s1, s2;\n            \n            public:\n                bool checkIfSimilar(int i1, int i2, int length) {\n                    unordered_map<int, int> freq;\n                    for (int i = i1; i < i1 + length; ++i) {\n                        ++freq[s1[i]];\n                    }\n                    for (int i = i2; i < i2 + length; ++i) {\n                        --freq[s2[i]];\n                    }\n                    if (any_of(freq.begin(), freq.end(), [](const auto& entry) {return entry.second != 0;})) {\n                        return false;\n                    }\n                    return true;\n                }\n            \n                // 第一个字符串从 i1 开始，第二个字符串从 i2 开始，子串的长度为 length，是否和谐\n                bool dfs(int i1, int i2, int length) {\n                    if (memo[i1][i2][length]) {\n                        return memo[i1][i2][length] == 1;\n                    }\n            \n                    // 判断两个子串是否相等\n                    if (s1.substr(i1, length) == s2.substr(i2, length)) {\n                        memo[i1][i2][length] = 1;\n                        return true;\n                    }\n            \n                    // 判断是否存在字符 c 在两个子串中出现的次数不同\n                    if (!checkIfSimilar(i1, i2, length)) {\n                        memo[i1][i2][length] = -1;\n                        return false;\n                    }\n                    \n                    // 枚举分割位置\n                    for (int i = 1; i < length; ++i) {\n                        // 不交换的情况\n                        if (dfs(i1, i2, i) && dfs(i1 + i, i2 + i, length - i)) {\n                            memo[i1][i2][length] = 1;\n                            return true;\n                        }\n                        // 交换的情况\n                        if (dfs(i1, i2 + length - i, i) && dfs(i1 + i, i2, length - i)) {\n                            memo[i1][i2][length] = 1;\n                            return true;\n                        }\n                    }\n            \n                    memo[i1][i2][length] = -1;\n                    return false;\n                }\n            \n                bool isScramble(string s1, string s2) {\n                    memset(memo, 0, sizeof(memo));\n                    this->s1 = s1;\n                    this->s2 = s2;\n                    return dfs(0, 0, s1.size());\n                }\n            };\n        ","\nclass Solution {\npublic:\n    bool isScramble(string s, string t) {\n        if (s.length() != t.length()) return false;\n\n        int n = s.length();\n        vt<vt<vt<int>>> dp(n, vt<vt<int>>(n, vt<int>(n + 1, 0)));\n\n        for (int i = 0; i < n; ++ i)\n            for (int j = 0; j < n; ++ j)\n                dp[i][j][1] = s[i] == t[j];\n\n        for (int k = 2; k <= n; ++ k){\n            for (int i = 0; i + k <= n; ++ i){\n                for (int j = 0; j + k <= n; ++ j){\n                    for (int ck = 1; ck < k; ++ ck){\n                        dp[i][j][k] |= (\n                            (dp[i][j][ck] && dp[i + ck][j + ck][k - ck]) ||\n                            (dp[i][j + k - ck][ck] && dp[i + ck][j][k - ck])\n                        );\n                    }\n                }\n            }\n        }\n\n        return dp[0][0][n];\n    }\n};\n        ","\n        class Solution {\n            public:\n                int n;\n                int _s1;\n                int _s2;\n                int cnter1[26];\n                int cnter2[26];\n                vector<vector<vector<int>>> memo;  // -1为空，0为false，1为true\n            \n                // s1下标i，s2下标j，截取长度len\n                int dfs(int i, int j, int len) {\n                    if (memo[i][j][len] != -1) return memo[i][j][len];\n            \n                    string a = _s1.substr(i, len);\n                    string b = _s2.substr(j, len);\n                    if (a == b) {\n                        memo[i][j][len] = 1;\n                        return true;\n                    }\n                    if (!check(a, b)) {  // 剪枝\n                        memo[i][j][len] = 0;\n                        return false;\n                    }\n                    for (int k = 1; k < len; k++) {\n                        // s1 前后两端起点：i,i+k，长度分别为：k,len-k\n                        // s2 前后两段起点（不交换）：j,j+k，长度分别为：k,len-k\n                        // s2 前后两端起点（交换）：j+len-k,j，长度分别为：k,len-k\n                        if (dfs(i, j, k) && dfs(i + k, j + k, len - k)) {\n                            memo[i][j][len] = 1;\n                            return true;\n                        }\n                        if (dfs(i, j + len - k, k) && dfs(i + k, j, len - k)) {\n                            memo[i][j][len] = 1;\n                            return true;\n                        }\n                    }\n                    memo[i][j][len] = 0;\n                    return false;\n                }\n            \n                // 词频检查\n                bool check(string &s1, string &s2) {\n                    if (s1.size() != s2.size()) return false;\n                    for (int i = 0; i < 26; i++) {\n                        cnter1[i] = 0;\n                        cnter2[i] = 0;\n                    }\n                    for (char c1 : s1) cnter1[c1 - 97]++;\n                    for (char c2 : s2) cnter2[c2 - 97]++;\n                    for (int i = 0; i < 26; i++) {\n                        if (cnter1[i] != cnter2[i]) return false;\n                    }\n                    return true;\n                }\n            \n                bool isScramble(string s1, string s2) {\n                    n = s1.size();\n                    _s1 = s1;\n                    _s2 = s2;\n                    memo.resize(n, vector<vector<int>>(n, vector<int>(n + 1, -1)));\n                    return dfs(0, 0, n);\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool isScramble(string s1, string s2) {\n                    int n = s1.size();\n                    vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>(n + 1, 0)));\n                    for (int i = 0; i < n; i++) {\n                        for (int j = 0; j < n; j++) {\n                            if (s1[i] == s2[j]) {\n                                dp[i][j][1] = 1;\n                            }\n                        }\n                    }\n            \n                    for (int len = 2; len <= n; len++) {\n                        for (int i = 0; i + len - 1 < n; i++) {\n                            for (int j = 0; j + len - 1 < n; j++) {\n                                for (int k = 1; k < len; k++) {\n                                    bool res1 = dp[i][j][k] && dp[i + k][j + k][len - k];\n                                    bool res2 = dp[i][j + len - k][k] && dp[i + k][j][len - k];\n                                    if (res1 || res2) {\n                                        dp[i][j][len] = true;\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    return dp[0][0][n];\n                }\n            };\n        "]
    },
    {
        "id":62,
        "description":"\n        You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\n\nMerge nums1 and nums2 into a single array sorted in non-decreasing order.\n\nThe final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.\n\n \n\nExample 1:\n\nInput: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3\nOutput: [1,2,2,3,5,6]\nExplanation: The arrays we are merging are [1,2,3] and [2,5,6].\nThe result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1.\nExample 2:\n\nInput: nums1 = [1], m = 1, nums2 = [], n = 0\nOutput: [1]\nExplanation: The arrays we are merging are [1] and [].\nThe result of the merge is [1].\nExample 3:\n\nInput: nums1 = [0], m = 0, nums2 = [1], n = 1\nOutput: [1]\nExplanation: The arrays we are merging are [] and [1].\nThe result of the merge is [1].\nNote that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1.\n \n\nConstraints:\n\nnums1.length == m + n\nnums2.length == n\n0 <= m, n <= 200\n1 <= m + n <= 200\n-10^9 <= nums1[i], nums2[j] <= 10^9\n        ",
        "tag":["Array","Two Pointers","Sorting"],
        "answer":["\n        class Solution {\n            public:\n                void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n                    for (int i = 0; i != n; ++i) {\n                        nums1[m + i] = nums2[i];\n                    }\n                    sort(nums1.begin(), nums1.end());\n                }\n            };\n        ","\n        class Solution {\n            public:\n                void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n                    int p1 = m - 1, p2 = n - 1;\n                    int tail = m + n - 1;\n                    int cur;\n                    while (p1 >= 0 || p2 >= 0) {\n                        if (p1 == -1) {\n                            cur = nums2[p2--];\n                        } else if (p2 == -1) {\n                            cur = nums1[p1--];\n                        } else if (nums1[p1] > nums2[p2]) {\n                            cur = nums1[p1--];\n                        } else {\n                            cur = nums2[p2--];\n                        }\n                        nums1[tail--] = cur;\n                    }\n                }\n            };\n        ","\n        void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {\n            int i = nums1.size() - 1;\n            m--;\n            n--;\n            while (n >= 0) {\n                while (m >= 0 && nums1[m] > nums2[n]) {\n                    swap(nums1[i--], nums1[m--]);\n                }\n                swap(nums1[i--], nums2[n--]);\n            }\n        }\n        "]
    },
    {
        "id":63,
        "description":"\n        An n-bit gray code sequence is a sequence of 2n integers where:\n\nEvery integer is in the inclusive range [0, 2n - 1],\nThe first integer is 0,\nAn integer appears no more than once in the sequence,\nThe binary representation of every pair of adjacent integers differs by exactly one bit, and\nThe binary representation of the first and last integers differs by exactly one bit.\nGiven an integer n, return any valid n-bit gray code sequence.\n\n \n\nExample 1:\n\nInput: n = 2\nOutput: [0,1,3,2]\nExplanation:\nThe binary representation of [0,1,3,2] is [00,01,11,10].\n- 00 and 01 differ by one bit\n- 01 and 11 differ by one bit\n- 11 and 10 differ by one bit\n- 10 and 00 differ by one bit\n[0,2,3,1] is also a valid gray code sequence, whose binary representation is [00,10,11,01].\n- 00 and 10 differ by one bit\n- 10 and 11 differ by one bit\n- 11 and 01 differ by one bit\n- 01 and 00 differ by one bit\nExample 2:\n\nInput: n = 1\nOutput: [0,1]\n \n\nConstraints:\n\n1 <= n <= 16\n        ",
        "tag":["Bit Manipulation","Math","Backtracking"],
        "answer":["\n        class Solution {\n            public:\n                vector<int> grayCode(int n) {\n                    vector<int> ret;\n                    ret.reserve(1 << n);\n                    ret.push_back(0);\n                    for (int i = 1; i <= n; i++) {\n                        int m = ret.size();\n                        for (int j = m - 1; j >= 0; j--) {\n                            ret.push_back(ret[j] | (1 << (i - 1)));\n                        }\n                    }\n                    return ret;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<int> grayCode(int n) {\n                    vector<int> ret(1 << n);\n                    for (int i = 0; i < ret.size(); i++) {\n                        ret[i] = (i >> 1) ^ i;\n                    }\n                    return ret;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<int> grayCode(int n) {\n                    vector<int> result;\n                    result.push_back(0);\n                    if(n == 0) {\n                        return result;\n                    }\n                    int first = 1;\n                    for(int i = 0; i < n; i++){\n                        for(int j = result.size() - 1; j >= 0; j--){\n                            result.push_back(first + result[j]);\n                        }\n                        first = first << 1;\n                    }\n                    return result;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<int> result;\n                vector<int> grayCode(int n) {\n                    dfs(n,\"\", {'0','1'});\n                    return result;\n                }\n                \n                void dfs(int n, string s, vector<char> nums){\n                    if(s.size() == n){\n                      //C 库函数 long int strtol(const char *str, char **endptr, int base) 把参数 str 所指向的字符串根据给定的 base 转换为一个长整数（类型为 long int 型），base 必须介于 2 和 36（包含）之间，或者是特殊值 0。  \n                        result.push_back(strtol(s.c_str(), nullptr, 2));\n                        return;\n                    }\n                    s.push_back(nums[0]);\n                    dfs(n,s,{'0','1'});\n                    s.pop_back();\n                    s.push_back(nums[1]);\n                    dfs(n,s,{'1','0'});\n                    s.pop_back();\n                }\n            };\n        "]
    },
    {
        "id":64,
        "description":"\n        Given an integer array nums that may contain duplicates, return all possible \nsubsets\n (the power set).\n\nThe solution set must not contain duplicate subsets. Return the solution in any order.\n\n \n\nExample 1:\n\nInput: nums = [1,2,2]\nOutput: [[],[1],[1,2],[1,2,2],[2],[2,2]]\nExample 2:\n\nInput: nums = [0]\nOutput: [[],[0]]\n \n\nConstraints:\n\n1 <= nums.length <= 10\n-10 <= nums[i] <= 10\n        ",
        "tag":["Bit Manipulation","Array","Backtracking"],
        "answer":["\n        class Solution {\n            public:\n                vector<int> t;\n                vector<vector<int>> ans;\n            \n                vector<vector<int>> subsetsWithDup(vector<int> &nums) {\n                    sort(nums.begin(), nums.end());\n                    int n = nums.size();\n                    for (int mask = 0; mask < (1 << n); ++mask) {\n                        t.clear();\n                        bool flag = true;\n                        for (int i = 0; i < n; ++i) {\n                            if (mask & (1 << i)) {\n                                if (i > 0 && (mask >> (i - 1) & 1) == 0 && nums[i] == nums[i - 1]) {\n                                    flag = false;\n                                    break;\n                                }\n                                t.push_back(nums[i]);\n                            }\n                        }\n                        if (flag) {\n                            ans.push_back(t);\n                        }\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<int> t;\n                vector<vector<int>> ans;\n            \n                void dfs(bool choosePre, int cur, vector<int> &nums) {\n                    if (cur == nums.size()) {\n                        ans.push_back(t);\n                        return;\n                    }\n                    dfs(false, cur + 1, nums);\n                    if (!choosePre && cur > 0 && nums[cur - 1] == nums[cur]) {\n                        return;\n                    }\n                    t.push_back(nums[cur]);\n                    dfs(true, cur + 1, nums);\n                    t.pop_back();\n                }\n            \n                vector<vector<int>> subsetsWithDup(vector<int> &nums) {\n                    sort(nums.begin(), nums.end());\n                    dfs(false, 0, nums);\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            private:\n                vector<vector<int>> result;\n                vector<int> path;\n                void backtracking(vector<int>& nums, int startIndex, vector<bool>& used) {\n                    result.push_back(path);\n                    for (int i = startIndex; i < nums.size(); i++) {\n                        // used[i - 1] == true，说明同一树枝candidates[i - 1]使用过\n                        // used[i - 1] == false，说明同一树层candidates[i - 1]使用过\n                        // 而我们要对同一树层使用过的元素进行跳过\n                        if (i > 0 && nums[i] == nums[i - 1] && used[i - 1] == false) {\n                            continue;\n                        }\n                        path.push_back(nums[i]);\n                        used[i] = true;\n                        backtracking(nums, i + 1, used);\n                        used[i] = false;\n                        path.pop_back();\n                    }\n                }\n            \n            public:\n                vector<vector<int>> subsetsWithDup(vector<int>& nums) {\n                    result.clear();\n                    path.clear();\n                    vector<bool> used(nums.size(), false);\n                    sort(nums.begin(), nums.end()); // 去重需要排序\n                    backtracking(nums, 0, used);\n                    return result;\n                }\n            };\n        "]
    },
    {
        "id":65,
        "description":"\n        A message containing letters from A-Z can be encoded into numbers using the following mapping:\n\n'A' -> \"1\"\n'B' -> \"2\"\n...\n'Z' -> \"26\"\nTo decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, \"11106\" can be mapped into:\n\n\"AAJF\" with the grouping (1 1 10 6)\n\"KJF\" with the grouping (11 10 6)\nNote that the grouping (1 11 06) is invalid because \"06\" cannot be mapped into 'F' since \"6\" is different from \"06\".\n\nGiven a string s containing only digits, return the number of ways to decode it.\n\nThe test cases are generated so that the answer fits in a 32-bit integer.\n\n \n\nExample 1:\n\nInput: s = \"12\"\nOutput: 2\nExplanation: \"12\" could be decoded as \"AB\" (1 2) or \"L\" (12).\nExample 2:\n\nInput: s = \"226\"\nOutput: 3\nExplanation: \"226\" could be decoded as \"BZ\" (2 26), \"VF\" (22 6), or \"BBF\" (2 2 6).\nExample 3:\n\nInput: s = \"06\"\nOutput: 0\nExplanation: \"06\" cannot be mapped to \"F\" because of the leading zero (\"6\" is different from \"06\").\n \n\nConstraints:\n\n1 <= s.length <= 100\ns contains only digits and may contain leading zero(s).\n        ",
        "tag":["String","Dynamic Programming"],
        "answer":["\n        class Solution {\n            public:\n                int numDecodings(string s) {\n                    int n = s.size();\n                    vector<int> f(n + 1);\n                    f[0] = 1;\n                    for (int i = 1; i <= n; ++i) {\n                        if (s[i - 1] != '0') {\n                            f[i] += f[i - 1];\n                        }\n                        if (i > 1 && s[i - 2] != '0' && ((s[i - 2] - '0') * 10 + (s[i - 1] - '0') <= 26)) {\n                            f[i] += f[i - 2];\n                        }\n                    }\n                    return f[n];\n                }\n            };\n        ","\n        int numDecodings(string s) {\n            if (s[0] == '0') return 0;\n            int pre = 1, curr = 1;//dp[-1] = dp[0] = 1\n            for (int i = 1; i < s.size(); i++) {\n                int tmp = curr;\n                if (s[i] == '0')\n                    if (s[i - 1] == '1' || s[i - 1] == '2') curr = pre;\n                    else return 0;\n                else if (s[i - 1] == '1' || (s[i - 1] == '2' && s[i] >= '1' && s[i] <= '6'))\n                    curr = curr + pre;\n                pre = tmp;\n            }\n            return curr;\n        }\n        ","\n        class Solution {\n            public:\n                int numDecodings(string s) {\n                    int n = s.size();\n                    vector<int> f(n + 1);\n                    f[0] = 1;  // 边界条件\n                    for(int i = 1; i <= n; i++){\n                        if(s[i - 1] != '0') f[i] = f[i - 1];         //单独解码s[i - 1]\n                        if(i >= 2){\n                            int t = (s[i - 2] - '0') * 10 + s[i - 1] - '0';\n                            if(t >= 10 && t <= 26) f[i] += f[i - 2]; //将s[i - 2] 和 s[i - 1]组合解码\n                        }\n                    }\n                    return f[n];\n                }\n            };\n        "]
    },
    {
        "id":66,
        "description":"\n        A valid IP address consists of exactly four integers separated by single dots. Each integer is between 0 and 255 (inclusive) and cannot have leading zeros.\n\nFor example, \"0.1.2.201\" and \"192.168.1.1\" are valid IP addresses, but \"0.011.255.245\", \"192.168.1.312\" and \"192.168@1.1\" are invalid IP addresses.\nGiven a string s containing only digits, return all possible valid IP addresses that can be formed by inserting dots into s. You are not allowed to reorder or remove any digits in s. You may return the valid IP addresses in any order.\n\n \n\nExample 1:\n\nInput: s = \"25525511135\"\nOutput: [\"255.255.11.135\",\"255.255.111.35\"]\nExample 2:\n\nInput: s = \"0000\"\nOutput: [\"0.0.0.0\"]\nExample 3:\n\nInput: s = \"101023\"\nOutput: [\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]\n \n\nConstraints:\n\n1 <= s.length <= 20\ns consists of digits only.\n        ",
        "tag":["String","Backtracking"],
        "answer":["\n        class Solution {\n            private:\n                static constexpr int SEG_COUNT = 4;\n            \n            private:\n                vector<string> ans;\n                vector<int> segments;\n            \n            public:\n                void dfs(const string& s, int segId, int segStart) {\n                    // 如果找到了 4 段 IP 地址并且遍历完了字符串，那么就是一种答案\n                    if (segId == SEG_COUNT) {\n                        if (segStart == s.size()) {\n                            string ipAddr;\n                            for (int i = 0; i < SEG_COUNT; ++i) {\n                                ipAddr += to_string(segments[i]);\n                                if (i != SEG_COUNT - 1) {\n                                    ipAddr += \".\";\n                                }\n                            }\n                            ans.push_back(move(ipAddr));\n                        }\n                        return;\n                    }\n            \n                    // 如果还没有找到 4 段 IP 地址就已经遍历完了字符串，那么提前回溯\n                    if (segStart == s.size()) {\n                        return;\n                    }\n            \n                    // 由于不能有前导零，如果当前数字为 0，那么这一段 IP 地址只能为 0\n                    if (s[segStart] == '0') {\n                        segments[segId] = 0;\n                        dfs(s, segId + 1, segStart + 1);\n                    }\n            \n                    // 一般情况，枚举每一种可能性并递归\n                    int addr = 0;\n                    for (int segEnd = segStart; segEnd < s.size(); ++segEnd) {\n                        addr = addr * 10 + (s[segEnd] - '0');\n                        if (addr > 0 && addr <= 0xFF) {\n                            segments[segId] = addr;\n                            dfs(s, segId + 1, segEnd + 1);\n                        } else {\n                            break;\n                        }\n                    }\n                }\n            \n                vector<string> restoreIpAddresses(string s) {\n                    segments.resize(SEG_COUNT);\n                    dfs(s, 0, 0);\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<string> restoreIpAddresses(string s) {\n                    // IP地址结果集\n                    vector<string> ret;\n                    // 单个IP地址\n                    string ans;\n                    \n                    // 我用了四重循环，你骂我吧\n                    for (int a=1; a<=3; a++)\n                    for (int b=1; b<=3; b++)\n                    for (int c=1; c<=3; c++)\n                    for (int d=1; d<=3; d++)\n                        // A、B、C、D 四段所占字符总数 一定是需要等于len(s)的\n                        if (a+b+c+d == s.length()) {\n                            // 转换成数字，我们接下来需要用来判断\n                            int A = stoi(s.substr(0, a));\n                            int B = stoi(s.substr(a, b));\n                            int C = stoi(s.substr(a+b, c));\n                            int D = stoi(s.substr(a+b+c, d));\n                            \n                            // 都 <= 255就可以了\n                            if (A<=255 && B<=255 && C<=255 && D<=255) {\n            \n                                ans = to_string(A) + \".\" + to_string(B) + \".\" + to_string(C) + \".\" + to_string(D);\n            \n                                // 这里应该知道吧，一个IP地址长度 = 原s长度 + 3(3个点字符) \n                                if (ans.length() == s.length()+3)\n                                    // 这里为什么要判断呢：\n                                    // 比如s=101023, 拆分成1，0，1，023\n                                    // 023会被我们 字符串 转数字抹去0，已经缺少 s中的字符了，所以我们这里需要额外判断\n                                    ret.push_back(ans);\n                            }\n                        }    \n                    \n                    return ret;\n                }\n            };\n        ","\n        class Solution {\n            private:\n                vector<string> result;// 记录结果\n                // startIndex: 搜索的起始位置，pointNum:添加逗点的数量\n                void backtracking(string& s, int startIndex, int pointNum) {\n                    if (pointNum == 3) { // 逗点数量为3时，分隔结束\n                        // 判断第四段子字符串是否合法，如果合法就放进result中\n                        if (isValid(s, startIndex, s.size() - 1)) {\n                            result.push_back(s);\n                        }\n                        return;\n                    }\n                    for (int i = startIndex; i < s.size(); i++) {\n                        if (isValid(s, startIndex, i)) { // 判断 [startIndex,i] 这个区间的子串是否合法\n                            s.insert(s.begin() + i + 1 , '.');  // 在i的后面插入一个逗点\n                            pointNum++;\n                            backtracking(s, i + 2, pointNum);   // 插入逗点之后下一个子串的起始位置为i+2\n                            pointNum--;                         // 回溯\n                            s.erase(s.begin() + i + 1);         // 回溯删掉逗点\n                        } else break; // 不合法，直接结束本层循环\n                    }\n                }\n                // 判断字符串s在左闭又闭区间[start, end]所组成的数字是否合法\n                bool isValid(const string& s, int start, int end) {\n                    if (start > end) {\n                        return false;\n                    }\n                    if (s[start] == '0' && start != end) { // 0开头的数字不合法\n                            return false;\n                    }\n                    int num = 0;\n                    for (int i = start; i <= end; i++) {\n                        if (s[i] > '9' || s[i] < '0') { // 遇到非数字字符不合法\n                            return false;\n                        }\n                        num = num * 10 + (s[i] - '0');\n                        if (num > 255) { // 如果大于255了不合法\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n            public:\n                vector<string> restoreIpAddresses(string s) {\n                    result.clear();\n                    if (s.size() < 4 || s.size() > 12) return result; // 算是剪枝了\n                    backtracking(s, 0, 0);\n                    return result;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<string> result;\n                //判断区间字符串是否合法\n                bool isValid(string s, int start, int end) {\n                    if (start > end) return false;\n                    if (s[start] == '0' && start != end) return false;\n                    //进行判断字符串中的数字是否合法\n                    int num = 0;\n                    for(int i = start; i <= end; ++i) {\n                        if (s[i] > '9' && s[i] < '0') return false;\n                        num = num * 10 + (s[i] - '0');\n                        if (num > 255) return false;\n                    }\n                    return true;\n                }\n                //回溯\n                void backTracking(string &s, int startIndex, int pointNum) {\n                    if (pointNum == 3) {\n                        if (isValid(s, startIndex, s.size() - 1)) result.emplace_back(s);\n                        return;\n                    }\n                    for (int i = startIndex; i < s.size(); ++i) {\n                        if (isValid(s, startIndex, i)) {\n                            s.insert(s.begin() + i + 1, '.');\n                            ++pointNum;\n                            backTracking(s, i + 2, pointNum);\n                            --pointNum;\n                            //把.号进行移除\n                            s.erase(s.begin() + i + 1);\n                        } else break;//否则的话，不用进行循环，因为到这里已经不符合要求了\n                    }\n                }\n                vector<string> restoreIpAddresses(string s) {\n                    //剪枝操作\n                    if (s.size() < 4 || s.size() > 12) return result;\n                    backTracking(s, 0, 0);\n                    return result;\n                } \n            };\n        "]
    },
    {
        "id":67,
        "description":"\n        Given two strings s and t, return the number of distinct \nsubsequences\n of s which equals t.\n\nThe test cases are generated so that the answer fits on a 32-bit signed integer.\n\n \n\nExample 1:\n\nInput: s = \"rabbbit\", t = \"rabbit\"\nOutput: 3\nExplanation:\nAs shown below, there are 3 ways you can generate \"rabbit\" from s.\nrabbbit\nrabbbit\nrabbbit\nExample 2:\n\nInput: s = \"babgbag\", t = \"bag\"\nOutput: 5\nExplanation:\nAs shown below, there are 5 ways you can generate \"bag\" from s.\nbabgbag\nbabgbag\nbabgbag\nbabgbag\nbabgbag\n \n\nConstraints:\n\n1 <= s.length, t.length <= 1000\ns and t consist of English letters.\n        ",
        "tag":["String","Dynamic Programming"],
        "answer":["\n        class Solution {\n            public:\n                int numDistinct(string s, string t) {\n                    int m = s.length(), n = t.length();\n                    if (m < n) {\n                        return 0;\n                    }\n                    vector<vector<unsigned long long>> dp(m + 1, vector<unsigned long long>(n + 1));\n                    for (int i = 0; i <= m; i++) {\n                        dp[i][n] = 1;\n                    }\n                    for (int i = m - 1; i >= 0; i--) {\n                        char sChar = s.at(i);\n                        for (int j = n - 1; j >= 0; j--) {\n                            char tChar = t.at(j);\n                            if (sChar == tChar) {\n                                dp[i][j] = dp[i + 1][j + 1] + dp[i + 1][j];\n                            } else {\n                                dp[i][j] = dp[i + 1][j];\n                            }\n                        }\n                    }\n                    return dp[0][0];\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<vector<int>> dp;\n                int numDistinct(string s, string t) {\n                    int lenS = s.size();\n                    int lenT = t.size();\n                    // 存储计算过的子问题的结果\n                    dp = vector<vector<int>>(lenS, vector<int>(lenT, -1));\n                    return dfs(s, t, lenS - 1, lenT - 1);\n                }\n            \n                int dfs(string& s, string& t, int i, int j) {\n                    if (j < 0) { // base case 当j指针越界，此时t为空串，s不管是不是空串，匹配方式数都是1\n                        return 1;\n                    }\n                    if (i < 0) { // base case i指针越界，此时s为空串，t不是，s怎么也匹配不了t，方式数0\n                        return 0;\n                    }\n                        \n                    if (dp[i][j] != -1) { // dp数组中有当前遇到的子问题的解，直接返回\n                        return dp[i][j];\n                    } \n                    if (s[i] == t[j]) { // t[j]被匹配掉，对应dfs(i-1, j-1)，不被匹配掉对应dfs(i-1, j)\n                        dp[i][j] = dfs(s, t, i - 1, j) + dfs(s, t, i - 1, j - 1);\n                    } else {\n                        dp[i][j] = dfs(s, t, i - 1, j);\n                    }\n                    return dp[i][j]; // 返回当前递归子问题的解\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int numDistinct(string s, string t) {\n                    int n = s.size(), m = t.size();\n                    s = \" \" + s;\n                    t = \" \" + t;\n                    vector<vector<int>> dp(n + 1,vector<int>(m + 1,0));\n                    for(int i = 0; i < n; i++) dp[i][0] = 1;\n                    for(int i = 1; i <= n; i++){\n                        for(int j = 1; j <= m; j++){\n                            dp[i][j] = dp[i - 1][j];\n                            if(s[i] == t[j]) dp[i][j] = (0LL + dp[i][j] + dp[i - 1][j - 1]) % INT_MAX;\n                        }\n                    }\n                    return dp[n][m];\n                }\n            };\n        "]
    },
    {
        "id":68,
        "description":"\n        Given an integer numRows, return the first numRows of Pascal's triangle.\n\nIn Pascal's triangle, each number is the sum of the two numbers directly above it as shown:\n\n\n \n\nExample 1:\n\nInput: numRows = 5\nOutput: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\nExample 2:\n\nInput: numRows = 1\nOutput: [[1]]\n \n\nConstraints:\n\n1 <= numRows <= 30\n        ",
        "tag":["Array","Dynamic Programming"],
        "answer":["\n        class Solution {\n            public:\n                vector<vector<int>> generate(int numRows) {\n                    vector<vector<int>> ret(numRows);\n                    for (int i = 0; i < numRows; ++i) {\n                        ret[i].resize(i + 1);\n                        ret[i][0] = ret[i][i] = 1;\n                        for (int j = 1; j < i; ++j) {\n                            ret[i][j] = ret[i - 1][j] + ret[i - 1][j - 1];\n                        }\n                    }\n                    return ret;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<vector<int>> generate(int numRows) {\n                    vector<vector<int>> vec;\n                    vec.reserve(numRows);\n                    vector<int> v1(1,1);\n                    vec.push_back(v1);\n                    if(numRows==1) return vec;\n                    for(int i=1;i<numRows;i++){\n                        vector<int> v(i+1,0);\n                        v[0]=1;\n                        v[v.size()-1]=1;\n                        for(int j=1;j<v.size()-1;j++){\n                            v[j]=vec[i-1][j-1]+vec[i-1][j];\n                        }\n                        vec.push_back(v);\n                    }\n                    return vec;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<vector<int>> generate(int numRows) {\n                    vector<vector<int>> dp(numRows);\n                    if (numRows >= 1) dp[0].emplace_back(1);\n                    if (numRows >= 2) {\n                        dp[1].emplace_back(1);\n                        dp[1].emplace_back(1);\n                    }\n                    for (int i = 2; i < numRows; ++i) {\n                        dp[i].emplace_back(1);\n                        for (int j = 1; j <= i - 1; ++j) {\n                            dp[i].emplace_back(dp[i - 1][j] + dp[i - 1][j - 1]);\n                        }\n                        dp[i].emplace_back(1);\n                    }\n                    return dp;\n                }\n            };\n        "]
    },
    {
        "id":69,
        "description":"\n        Given an integer rowIndex, return the rowIndexth (0-indexed) row of the Pascal's triangle.\n\nIn Pascal's triangle, each number is the sum of the two numbers directly above it as shown:\n\n\n \n\nExample 1:\n\nInput: rowIndex = 3\nOutput: [1,3,3,1]\nExample 2:\n\nInput: rowIndex = 0\nOutput: [1]\nExample 3:\n\nInput: rowIndex = 1\nOutput: [1,1]\n \n\nConstraints:\n\n0 <= rowIndex <= 33\n        ",
        "tag":["Array","Dynamic Programming"],
        "answer":["\n        class Solution {\n            public:\n                vector<int> getRow(int rowIndex) {\n                    vector<vector<int>> C(rowIndex + 1);\n                    for (int i = 0; i <= rowIndex; ++i) {\n                        C[i].resize(i + 1);\n                        C[i][0] = C[i][i] = 1;\n                        for (int j = 1; j < i; ++j) {\n                            C[i][j] = C[i - 1][j - 1] + C[i - 1][j];\n                        }\n                    }\n                    return C[rowIndex];\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<int> getRow(int rowIndex) {\n                    vector<int> row(rowIndex + 1);\n                    row[0] = 1;\n                    for (int i = 1; i <= rowIndex; ++i) {\n                        row[i] = 1LL * row[i - 1] * (rowIndex - i + 1) / i;\n                    }\n                    return row;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<int> getRow(int rowIndex) {\n                    vector<int> res;\n                    res.push_back(1);\n                    if(rowIndex == 0)\n                        return res;\n                    vector<int> preRes = getRow(rowIndex-1);\n                    for(int i=0;i<preRes.size()-1;i++){\n                        res.push_back(preRes[i]+preRes[i+1]);\n                    }\n                    res.push_back(1);\n                    return res;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<int> getRow(int rowIndex) {\n                    vector<int> res;\n                    res.push_back(1);\n                    for(int i = 0; i < rowIndex; i++){\n                        res.push_back((long)res[i]*(rowIndex-i)/(i+1));  \n                    }\n                    return res;\n                }\n            };\n        "]
    },
    {
        "id":70,
        "description":"\n        Given a triangle array, return the minimum path sum from top to bottom.\n\nFor each step, you may move to an adjacent number of the row below. More formally, if you are on index i on the current row, you may move to either index i or index i + 1 on the next row.\n\n \n\nExample 1:\n\nInput: triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]\nOutput: 11\nExplanation: The triangle looks like:\n   2\n  3 4\n 6 5 7\n4 1 8 3\nThe minimum path sum from top to bottom is 2 + 3 + 5 + 1 = 11 (underlined above).\nExample 2:\n\nInput: triangle = [[-10]]\nOutput: -10\n \n\nConstraints:\n\n1 <= triangle.length <= 200\ntriangle[0].length == 1\ntriangle[i].length == triangle[i - 1].length + 1\n-10^4 <= triangle[i][j] <= 10^4\n        ",
        "tag":["Array","Dynamic Programming"],
        "answer":["\n        class Solution {\n            public:\n                int minimumTotal(vector<vector<int>>& triangle) {\n                    int n = triangle.size();\n                    vector<vector<int>> f(n, vector<int>(n));\n                    f[0][0] = triangle[0][0];\n                    for (int i = 1; i < n; ++i) {\n                        f[i][0] = f[i - 1][0] + triangle[i][0];\n                        for (int j = 1; j < i; ++j) {\n                            f[i][j] = min(f[i - 1][j - 1], f[i - 1][j]) + triangle[i][j];\n                        }\n                        f[i][i] = f[i - 1][i - 1] + triangle[i][i];\n                    }\n                    return *min_element(f[n - 1].begin(), f[n - 1].end());\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int minimumTotal(vector<vector<int>>& triangle) {\n                    int n = triangle.size();\n                    vector<vector<int>> f(2, vector<int>(n));\n                    f[0][0] = triangle[0][0];\n                    for (int i = 1; i < n; ++i) {\n                        int curr = i % 2;\n                        int prev = 1 - curr;\n                        f[curr][0] = f[prev][0] + triangle[i][0];\n                        for (int j = 1; j < i; ++j) {\n                            f[curr][j] = min(f[prev][j - 1], f[prev][j]) + triangle[i][j];\n                        }\n                        f[curr][i] = f[prev][i - 1] + triangle[i][i];\n                    }\n                    return *min_element(f[(n - 1) % 2].begin(), f[(n - 1) % 2].end());\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int minimumTotal(vector<vector<int>>& triangle) \n                {\n                    int row = triangle.size();\n            \n                    // 我们不开辟新空间，直接遍历并修改二维数组，所以不必设置初始值\n                    for (int i = 1; i < row; ++i)\n                    {\n                        for (int j = 0; j <= i; ++j)\n                        {\n                            // 当前位置的最小路径和，应该是上一层的位置的最小路径和+当前位置的值。\n                            // 求出来我们是直接放到原始数组中的，不要混淆。\n                            // 由于上面的位置已经被遍历修改过，已经是该位置的最小路径和，所以直接加等。\n                            if (j == 0)\n                                triangle[i][j] += triangle[i-1][j]; \n                            else if (j == i)\n                                triangle[i][j] += triangle[i-1][j-1];\n                            else\n                                triangle[i][j] += min(triangle[i-1][j-1], triangle[i-1][j]);\n                        }\n                    }\n            \n                    // 求返回值：最底层的数组中的最小值\n                    int minSum = triangle[row - 1][0];\n                    for (auto e : triangle[row - 1])\n                    {\n                        if (minSum > e) minSum = e;\n                    }\n                    return minSum;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int minimumTotal(vector<vector<int>>& triangle) {\n                    int row = triangle.size();\n                    //自下而上遍历\n                    for (int i = row - 2; i >= 0; --i) // 最后一行作初始值 不参与遍历\n                    {\n                        for (int j = 0; j <= i; ++j)\n                        {\n                            triangle[i][j] += min(triangle[i+1][j], triangle[i+1][j+1]);\n                        }\n                    }\n            \n                    return triangle[0][0];\n                }\n            };\n        "]
    },
    {
        "id":71,
        "description":"\n        You are given an array prices where prices[i] is the price of a given stock on the i^th day.\n\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\n\n \n\nExample 1:\n\nInput: prices = [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5.\nNote that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell.\nExample 2:\n\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transactions are done and the max profit = 0.\n \n\nConstraints:\n\n1 <= prices.length <= 10^5\n0 <= prices[i] <= 10^4\n        ",
        "tag":["Array","Dynamic Programming"],
        "answer":["\n        class Solution {\n            public:\n                int maxProfit(vector<int>& prices) {\n                    int n = (int)prices.size(), ans = 0;\n                    for (int i = 0; i < n; ++i){\n                        for (int j = i + 1; j < n; ++j) {\n                            ans = max(ans, prices[j] - prices[i]);\n                        }\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int maxProfit(vector<int>& prices) {\n                    int inf = 1e9;\n                    int minprice = inf, maxprofit = 0;\n                    for (int price: prices) {\n                        maxprofit = max(maxprofit, price - minprice);\n                        minprice = min(price, minprice);\n                    }\n                    return maxprofit;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int maxProfit(vector<int>& prices) {\n                    int ans = 0;\n                    vector<int> St;\n                    prices.emplace_back(-1); \\ 哨兵👨‍✈️\n                    for (int i = 0; i < prices.size(); ++ i){\n                        while (!St.empty() && St.back() > prices[i]){ \\ 维护单调栈📈\n                            ans = std::max(ans, St.back() - St.front()); \\ 维护最大值\n                            St.pop_back();\n                        }\n                        St.emplace_back(prices[i]);\n                    }\n            \n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int maxProfit(vector<int>& prices) {\n                    int minprice = int(1e9);\n                    int maxprofit = 0;\n                    for (auto price : prices){\n                        maxprofit = max(maxprofit, price - minprice);\n                        minprice = min(minprice, price);\n                    }\n                    return maxprofit;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int maxProfit(vector<int>& prices) {\n                    int n = prices.size();\n                    if (n == 0) return 0; // 边界条件\n                    int minprice = prices[0];\n                    vector<int> dp (n, 0);\n            \n                    for (int i = 1; i < n; i++){\n                        minprice = min(minprice, prices[i]);\n                        dp[i] = max(dp[i - 1], prices[i] - minprice);\n                    }\n                    return dp[n - 1];\n                }\n            };\n        "]
    },
    {
        "id":72,
        "description":"\n        You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\n\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\n\nFind and return the maximum profit you can achieve.\n\n \n\nExample 1:\n\nInput: prices = [7,1,5,3,6,4]\nOutput: 7\nExplanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4.\nThen buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3.\nTotal profit is 4 + 3 = 7.\nExample 2:\n\nInput: prices = [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nTotal profit is 4.\nExample 3:\n\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0.\n \n\nConstraints:\n\n1 <= prices.length <= 3 * 10^4\n0 <= prices[i] <= 10^4\n        ",
        "tag":["Greedy","Array","Dynamic Programming"],
        "answer":["\n        class Solution {\n            public:\n                int maxProfit(vector<int>& prices) {\n                    int n = prices.size();\n                    int dp[n][2];\n                    dp[0][0] = 0, dp[0][1] = -prices[0];\n                    for (int i = 1; i < n; ++i) {\n                        dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);\n                        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);\n                    }\n                    return dp[n - 1][0];\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int maxProfit(vector<int>& prices) {   \n                    int ans = 0;\n                    int n = prices.size();\n                    for (int i = 1; i < n; ++i) {\n                        ans += max(0, prices[i] - prices[i - 1]);\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int maxProfit(vector<int> &prices) {\n                    int n = prices.size(), memo[n][2];\n                    memset(memo, -1, sizeof(memo)); // -1 表示还没有计算过\n                    function<int(int, bool)> dfs = [&](int i, bool hold) -> int {\n                        if (i < 0) return hold ? INT_MIN : 0;\n                        int &res = memo[i][hold];\n                        if (res != -1) return res;\n                        if (hold) return res = max(dfs(i - 1, true), dfs(i - 1, false) - prices[i]);\n                        return res = max(dfs(i - 1, false), dfs(i - 1, true) + prices[i]);\n                    };\n                    return dfs(n - 1, false);\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int maxProfit(vector<int> &prices) {\n                    int n = prices.size(), f[n + 1][2];\n                    memset(f, 0, sizeof(f));\n                    f[0][1] = INT_MIN;\n                    for (int i = 0; i < n; ++i) {\n                        f[i + 1][0] = max(f[i][0], f[i][1] + prices[i]);\n                        f[i + 1][1] = max(f[i][1], f[i][0] - prices[i]);\n                    }\n                    return f[n][0];\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int maxProfit(vector<int> &prices) {\n                    int f0 = 0, f1 = INT_MIN;\n                    for (int p: prices) {\n                        int new_f0 = max(f0, f1 + p);\n                        f1 = max(f1, f0 - p);\n                        f0 = new_f0;\n                    }\n                    return f0;\n                }\n            };\n        "]
    },
    {
        "id":73,
        "description":"\n        You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\nFind the maximum profit you can achieve. You may complete at most two transactions.\n\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\n \n\nExample 1:\n\nInput: prices = [3,3,5,0,0,3,1,4]\nOutput: 6\nExplanation: Buy on day 4 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\nThen buy on day 7 (price = 1) and sell on day 8 (price = 4), profit = 4-1 = 3.\nExample 2:\n\nInput: prices = [1,2,3,4,5]\nOutput: 4\nExplanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4.\nNote that you cannot buy on day 1, buy on day 2 and sell them later, as you are engaging multiple transactions at the same time. You must sell before buying again.\nExample 3:\n\nInput: prices = [7,6,4,3,1]\nOutput: 0\nExplanation: In this case, no transaction is done, i.e. max profit = 0.\n \n\nConstraints:\n\n1 <= prices.length <= 10^5\n0 <= prices[i] <= 10^5\n        ",
        "tag":["Array","Dynamic Programming"],
        "answer":["\n        class Solution {\n            public:\n                int maxProfit(vector<int>& prices) {\n                    int n = prices.size();\n                    int buy1 = -prices[0], sell1 = 0;\n                    int buy2 = -prices[0], sell2 = 0;\n                    for (int i = 1; i < n; ++i) {\n                        buy1 = max(buy1, -prices[i]);\n                        sell1 = max(sell1, buy1 + prices[i]);\n                        buy2 = max(buy2, sell1 - prices[i]);\n                        sell2 = max(sell2, buy2 + prices[i]);\n                    }\n                    return sell2;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int maxProfit(vector<int>& prices) {\n                    /* 定义dp数组 */\n                    vector<vector<int>> dp(prices.size() + 1, vector<int>(5,0));\n                    /* dp数组初始化 */\n                    dp[0][0] = 0;\n                    dp[0][1] = -prices[0];\n                    dp[0][2] = 0;\n                    dp[0][3] = -prices[0];\n                    dp[0][4] = 0;\n            \n                    for(int i = 1; i < prices.size(); i++) {\n                        dp[i][0] = dp[i - 1][0];\n                        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);\n                        dp[i][2] = max(dp[i - 1][2], dp[i - 1][1] + prices[i]);\n                        dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);\n                        dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);\n                    }\n                    return dp[prices.size()-1][4];\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int maxProfit(vector<int>& prices) {\n                    int n = prices.size();\n                    int dp[n][3][2];\n                    for (int k = 0; k <= 2; k++) {\n                        dp[0][k][0] = 0;\n                        dp[0][k][1] = -prices[0];\n                    }\n                    for (int i = 1; i < n; i++) {\n                        dp[i][0][0] = 0;\n                        dp[i][0][1] = max(dp[i - 1][0][1], dp[i - 1][0][0] - prices[i]);\n                        for (int k = 1; k <= 2; k++) {\n                            dp[i][k][0] = max(dp[i - 1][k][0], dp[i - 1][k - 1][1] + prices[i]);\n                            dp[i][k][1] = max(dp[i - 1][k][1], dp[i - 1][k][0] - prices[i]);\n                        }\n                    }\n                    return dp[n - 1][2][0];\n                }\n            };\n        "]
    },
    {
        "id":74,
        "description":"\n        A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\n\nGiven a string s, return true if it is a palindrome, or false otherwise.\n\n \n\nExample 1:\n\nInput: s = \"A man, a plan, a canal: Panama\"\nOutput: true\nExplanation: \"amanaplanacanalpanama\" is a palindrome.\nExample 2:\n\nInput: s = \"race a car\"\nOutput: false\nExplanation: \"raceacar\" is not a palindrome.\nExample 3:\n\nInput: s = \" \"\nOutput: true\nExplanation: s is an empty string \"\" after removing non-alphanumeric characters.\nSince an empty string reads the same forward and backward, it is a palindrome.\n \n\nConstraints:\n\n1 <= s.length <= 2 * 10^5\ns consists only of printable ASCII characters.\n        ",
        "tag":["Two Pointers","String"],
        "answer":["\n        class Solution {\n            public:\n                bool isPalindrome(string s) {\n                    string sgood;\n                    for (char ch: s) {\n                        if (isalnum(ch)) {\n                            sgood += tolower(ch);\n                        }\n                    }\n                    string sgood_rev(sgood.rbegin(), sgood.rend());\n                    return sgood == sgood_rev;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool isPalindrome(string s) {\n                    string sgood;\n                    for (char ch: s) {\n                        if (isalnum(ch)) {\n                            sgood += tolower(ch);\n                        }\n                    }\n                    int n = sgood.size();\n                    int left = 0, right = n - 1;\n                    while (left < right) {\n                       if (sgood[left] != sgood[right]) {\n                            return false;\n                        }\n                        ++left;\n                        --right;\n                    }\n                    return true;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool isPalindrome(string s) {\n                    int n = s.size();\n                    int left = 0, right = n - 1;\n                    while (left < right) {\n                        while (left < right && !isalnum(s[left])) {\n                            ++left;\n                        }\n                        while (left < right && !isalnum(s[right])) {\n                            --right;\n                        }\n                        if (left < right) {\n                            if (tolower(s[left]) != tolower(s[right])) {\n                                return false;\n                            }\n                            ++left;\n                            --right;\n                        }\n                    }\n                    return true;\n                }\n            };\n        "]
    },
    {
        "id":75,
        "description":"\n        A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n\nEvery adjacent pair of words differs by a single letter.\nEvery si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\nsk == endWord\nGiven two words, beginWord and endWord, and a dictionary wordList, return all the shortest transformation sequences from beginWord to endWord, or an empty list if no such sequence exists. Each sequence should be returned as a list of the words [beginWord, s1, s2, ..., sk].\n\n \n\nExample 1:\n\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\nOutput: [[\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],[\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]]\nExplanation: There are 2 shortest transformation sequences:\n\"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\"\n\"hit\" -> \"hot\" -> \"lot\" -> \"log\" -> \"cog\"\nExample 2:\n\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\nOutput: []\nExplanation: The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence.\n \n\nConstraints:\n\n1 <= beginWord.length <= 5\nendWord.length == beginWord.length\n1 <= wordList.length <= 500\nwordList[i].length == beginWord.length\nbeginWord, endWord, and wordList[i] consist of lowercase English letters.\nbeginWord != endWord\nAll the words in wordList are unique.\nThe sum of all shortest transformation sequences does not exceed 10^5.\n        ",
        "tag":["Breadth-First Search","Hash Table","String","Backtracking"],
        "answer":["\n        class Solution {\n            public:\n                vector<vector<string>> findLadders(string beginWord, string endWord, vector<string> &wordList) {\n                    vector<vector<string>> res;\n                    // 因为需要快速判断扩展出的单词是否在 wordList 里，因此需要将 wordList 存入哈希表，这里命名为「字典」\n                    unordered_set<string> dict = {wordList.begin(), wordList.end()};\n                    // 修改以后看一下，如果根本就不在 dict 里面，跳过\n                    if (dict.find(endWord) == dict.end()) {\n                        return res;\n                    }\n                    // 特殊用例处理\n                    dict.erase(beginWord);\n            \n                    // 第 1 步：广度优先搜索建图\n                    // 记录扩展出的单词是在第几次扩展的时候得到的，key：单词，value：在广度优先搜索的第几层\n                    unordered_map<string, int> steps = {{beginWord, 0}};\n                    // 记录了单词是从哪些单词扩展而来，key：单词，value：单词列表，这些单词可以变换到 key ，它们是一对多关系\n                    unordered_map<string, set<string>> from = {{beginWord, {}}};\n                    int step = 0;\n                    bool found = false;\n                    queue<string> q = queue<string>{{beginWord}};\n                    int wordLen = beginWord.length();\n                    while (!q.empty()) {\n                        step++;\n                        int size = q.size();\n                        for (int i = 0; i < size; i++) {\n                            const string currWord = move(q.front());\n                            string nextWord = currWord;\n                            q.pop();\n                            // 将每一位替换成 26 个小写英文字母\n                            for (int j = 0; j < wordLen; ++j) {\n                                const char origin = nextWord[j];\n                                for (char c = 'a'; c <= 'z'; ++c) {\n                                    nextWord[j] = c;\n                                    if (steps[nextWord] == step) {\n                                        from[nextWord].insert(currWord);\n                                    }\n                                    if (dict.find(nextWord) == dict.end()) {\n                                        continue;\n                                    }\n                                    // 如果从一个单词扩展出来的单词以前遍历过，距离一定更远，为了避免搜索到已经遍历到，且距离更远的单词，需要将它从 dict 中删除\n                                    dict.erase(nextWord);\n                                    // 这一层扩展出的单词进入队列\n                                    q.push(nextWord);\n                                    // 记录 nextWord 从 currWord 而来\n                                    from[nextWord].insert(currWord);\n                                    // 记录 nextWord 的 step\n                                    steps[nextWord] = step;\n                                    if (nextWord == endWord) {\n                                        found = true;\n                                    }\n                                }\n                                nextWord[j] = origin;\n                            }\n                        }\n                        if (found) {\n                            break;\n                        }\n                    }\n                    // 第 2 步：回溯找到所有解，从 endWord 恢复到 beginWord ，所以每次尝试操作 path 列表的头部\n                    if (found) {\n                        vector<string> Path = {endWord};\n                        backtrack(res, endWord, from, Path);\n                    }\n                    return res;\n                }\n            \n                void backtrack(vector<vector<string>> &res, const string &Node, unordered_map<string, set<string>> &from,\n                         vector<string> &path) {\n                    if (from[Node].empty()) {\n                        res.push_back({path.rbegin(), path.rend()});\n                        return;\n                    }\n                    for (const string &Parent: from[Node]) {\n                        path.push_back(Parent);\n                        backtrack(res, Parent, from, path);\n                        path.pop_back();\n                    }\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\n                    vector<vector<string>> res;\n                    unordered_set<string> dict(wordList.begin(), wordList.end()), head{beginWord}, tail{endWord};\n                    if(!dict.count(endWord)) return res;\n                    dict.erase(beginWord), dict.erase(endWord);\n                    unordered_map<string, vector<string>> next;\n                    bool reversed = false, found = false; // 一些初始化准备\n                    while (!head.empty()) {\n                        unordered_set<string> temp; // 保存已转化过的 string\n                        for (const auto &w : head) { // 层 遍历\n                            string s = w;\n                            for (size_t i = 0; i < s.size(); ++i) { // 回溯查找子节点\n                                char c = s[i];\n                                for (char j = 'a'; j <= 'z'; ++j) {\n                                    s[i] = j;\n                                    if (tail.count(s)) { // 退出条件\n                                        reversed ? next[s].push_back(w) : next[w].push_back(s);\n                                        found = true;\n                                    }\n                                    if (dict.count(s)) { // 保存已转换的子节点\n                                        reversed ? next[s].push_back(w) : next[w].push_back(s);\n                                        temp.insert(s);\n                                    }\n                                }\n                                s[i] = c;\n                            }\n                        }\n                        if (found) break; // 退出\n                        for (const auto &w : temp) dict.erase(w); // 删除已转换的 string\n                        if (temp.size() <= tail.size()) head = temp; // 根据左右层节点大小来切换遍历方向\n                        else {\n                            reversed = !reversed;\n                            head = tail;\n                            tail = temp;\n                        }\n                    }\n                    if (found) { // 根据上面双向BFS构建的树型数据结构来梳理出不同的转换序\n                        vector<string> path = {beginWord};\n                        backtracking(beginWord, endWord, next, path, res); // 回溯算法的应用\n                    }\n                    return res;\n                }\n            \n            private:\n                void backtracking(const string &src, const string &dst, unordered_map<string,vector<string>> &next,\n                    vector<string> &path, vector<vector<string>> &res) {\n                    if (src == dst) res.push_back(path);\n                    for (const auto &w : next[src]) { // 按 层 为单位回溯求不同的转换序\n                        path.push_back(w);\n                        backtracking(w, dst, next, path, res);\n                        path.pop_back();\n                    }\n                }\n            };\n        ","\n        class Solution {\n            public:\n                   \n                unordered_set<string> words;\n            \n                //判断节点是否直连\n                bool connect(const string &s1, const string &s2)\n                {\n                    int n = s1.size();\n                    int cnt = 0;\n                    for(int i = 0; i < n; i++)\n                    {\n                        if(s1[i] != s2[i])\n                        {\n                            cnt++;\n                            if(cnt > 1) return false;\n                        }\n                    }\n                    return cnt == 1;\n                }\n            \n                //返回从某一层节点集合startSet到endWord的路径集合\n                vector<vector<string>> findPath(unordered_set<string> &startSet, string &end)\n                {\n                    int num = startSet.size();\n                    unordered_set<string> nbSet; //下一层节点集合\n                    vector<vector<string>> ret;\n                    if(num == 0) return ret; //起始节点集合为空，递归结束\n                    \n                    for(auto &t:startSet) //求下一层节点集合\n                    {\n                        for(int j = 0; j < t.size(); j++)\n                        {\n                            for(char c='a'; c <= 'z'; c++)\n                            {\n                                if(c == t[j]) continue;\n                                string temp = t;\n                                temp[j] = c;\n                                if(temp == end) //如果下一层节点中包含endWord，记录该路径\n                                {\n                                    ret.push_back(vector<string>{t, end});\n                                }\n                                if(words.count(temp) != 0 && nbSet.count(temp) == 0) nbSet.insert(move(temp));\n                            }\n                        }\n                    }\n                    \n                    //如果下一层节点中包含endWord，递归结束\n                    if(nbSet.count(end) > 0) return ret; \n                    \n                    //遍历过的节点不再遍历\n                    for(auto &it:nbSet) words.erase(it);\n                    \n                    auto nbPathSet = findPath(nbSet, end); //递归调用\n                    for(auto &itNb : nbPathSet) //构建本层到end的路径\n                    {\n                        for(auto &itStart : startSet)\n                        {\n                            if(connect(itNb[0], itStart))\n                            {\n                                vector<string> path{itStart};\n                                path.insert(path.end(), itNb.begin(), itNb.end());\n                                ret.push_back(move(path));\n                            }\n                        }\n                    }\n                    return ret;\n                }\n            \n                vector<vector<string>> findLadders(string beginWord, string endWord, vector<string>& wordList) {\n                    vector<vector<string>> ret;\n                    for(auto &it: wordList) words.insert(it); //构建hash表\n                    if(words.count(endWord) == 0) return ret;\n                    words.erase(beginWord);\n            \n                    unordered_set<string> startSet;\n                    startSet.insert(beginWord); //startWord作为第一个节点集合\n                    \n                    return findPath(startSet, endWord);\n                }\n            };\n        "]
    },
    {
        "id":76,
        "description":"\n        A transformation sequence from word beginWord to word endWord using a dictionary wordList is a sequence of words beginWord -> s1 -> s2 -> ... -> sk such that:\n\nEvery adjacent pair of words differs by a single letter.\nEvery si for 1 <= i <= k is in wordList. Note that beginWord does not need to be in wordList.\nsk == endWord\nGiven two words, beginWord and endWord, and a dictionary wordList, return the number of words in the shortest transformation sequence from beginWord to endWord, or 0 if no such sequence exists.\n\n \n\nExample 1:\n\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\nOutput: 5\nExplanation: One shortest transformation sequence is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> cog\", which is 5 words long.\nExample 2:\n\nInput: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\nOutput: 0\nExplanation: The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence.\n \n\nConstraints:\n\n1 <= beginWord.length <= 10\nendWord.length == beginWord.length\n1 <= wordList.length <= 5000\nwordList[i].length == beginWord.length\nbeginWord, endWord, and wordList[i] consist of lowercase English letters.\nbeginWord != endWord\nAll the words in wordList are unique.\n        ",
        "tag":["Breadth-First Search","Hash Table","String"],
        "answer":["\n        class Solution {\n            public:\n                unordered_map<string, int> wordId;\n                vector<vector<int>> edge;\n                int nodeNum = 0;\n            \n                void addWord(string& word) {\n                    if (!wordId.count(word)) {\n                        wordId[word] = nodeNum++;\n                        edge.emplace_back();\n                    }\n                }\n            \n                void addEdge(string& word) {\n                    addWord(word);\n                    int id1 = wordId[word];\n                    for (char& it : word) {\n                        char tmp = it;\n                        it = '*';\n                        addWord(word);\n                        int id2 = wordId[word];\n                        edge[id1].push_back(id2);\n                        edge[id2].push_back(id1);\n                        it = tmp;\n                    }\n                }\n            \n                int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\n                    for (string& word : wordList) {\n                        addEdge(word);\n                    }\n                    addEdge(beginWord);\n                    if (!wordId.count(endWord)) {\n                        return 0;\n                    }\n                    vector<int> dis(nodeNum, INT_MAX);\n                    int beginId = wordId[beginWord], endId = wordId[endWord];\n                    dis[beginId] = 0;\n            \n                    queue<int> que;\n                    que.push(beginId);\n                    while (!que.empty()) {\n                        int x = que.front();\n                        que.pop();\n                        if (x == endId) {\n                            return dis[endId] / 2 + 1;\n                        }\n                        for (int& it : edge[x]) {\n                            if (dis[it] == INT_MAX) {\n                                dis[it] = dis[x] + 1;\n                                que.push(it);\n                            }\n                        }\n                    }\n                    return 0;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                unordered_map<string, int> wordId;\n                vector<vector<int>> edge;\n                int nodeNum = 0;\n            \n                void addWord(string& word) {\n                    if (!wordId.count(word)) {\n                        wordId[word] = nodeNum++;\n                        edge.emplace_back();\n                    }\n                }\n            \n                void addEdge(string& word) {\n                    addWord(word);\n                    int id1 = wordId[word];\n                    for (char& it : word) {\n                        char tmp = it;\n                        it = '*';\n                        addWord(word);\n                        int id2 = wordId[word];\n                        edge[id1].push_back(id2);\n                        edge[id2].push_back(id1);\n                        it = tmp;\n                    }\n                }\n            \n                int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\n                    for (string& word : wordList) {\n                        addEdge(word);\n                    }\n                    addEdge(beginWord);\n                    if (!wordId.count(endWord)) {\n                        return 0;\n                    }\n            \n                    vector<int> disBegin(nodeNum, INT_MAX);\n                    int beginId = wordId[beginWord];\n                    disBegin[beginId] = 0;\n                    queue<int> queBegin;\n                    queBegin.push(beginId);\n            \n                    vector<int> disEnd(nodeNum, INT_MAX);\n                    int endId = wordId[endWord];\n                    disEnd[endId] = 0;\n                    queue<int> queEnd;\n                    queEnd.push(endId);\n            \n                    while (!queBegin.empty() && !queEnd.empty()) {\n                        int queBeginSize = queBegin.size();\n                        for (int i = 0; i < queBeginSize; ++i) {\n                            int nodeBegin = queBegin.front();\n                            queBegin.pop();\n                            if (disEnd[nodeBegin] != INT_MAX) {\n                                return (disBegin[nodeBegin] + disEnd[nodeBegin]) / 2 + 1;\n                            }\n                            for (int& it : edge[nodeBegin]) {\n                                if (disBegin[it] == INT_MAX) {\n                                    disBegin[it] = disBegin[nodeBegin] + 1;\n                                    queBegin.push(it);\n                                }\n                            }\n                        }\n            \n                        int queEndSize = queEnd.size();\n                        for (int i = 0; i < queEndSize; ++i) {\n                            int nodeEnd = queEnd.front();\n                            queEnd.pop();\n                            if (disBegin[nodeEnd] != INT_MAX) {\n                                return (disBegin[nodeEnd] + disEnd[nodeEnd]) / 2 + 1;\n                            }\n                            for (int& it : edge[nodeEnd]) {\n                                if (disEnd[it] == INT_MAX) {\n                                    disEnd[it] = disEnd[nodeEnd] + 1;\n                                    queEnd.push(it);\n                                }\n                            }\n                        }\n                    }\n                    return 0;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int ladderLength(string beginWord, string endWord, vector<string>& wordList) {\n                    // 将vector转成unordered_set，提高查询速度\n                    unordered_set<string> wordSet(wordList.begin(), wordList.end());\n                    // 如果endWord没有在wordSet出现，直接返回0\n                    if (wordSet.find(endWord) == wordSet.end()) return 0;\n                    // 记录word是否访问过\n                    unordered_map<string, int> visitMap; // <word, 查询到这个word路径长度>\n                    // 初始化队列\n                    queue<string> que;\n                    que.push(beginWord);\n                    // 初始化visitMap\n                    visitMap.insert(pair<string, int>(beginWord, 1));\n            \n                    while(!que.empty()) {\n                        string word = que.front();\n                        que.pop();\n                        int path = visitMap[word]; // 这个word的路径长度\n                        for (int i = 0; i < word.size(); i++) {\n                            string newWord = word; // 用一个新单词替换word，因为每次置换一个字母\n                            for (int j = 0 ; j < 26; j++) {\n                                newWord[i] = j + 'a';\n                                if (newWord == endWord) return path + 1; // 找到了end，返回path+1\n                                // wordSet出现了newWord，并且newWord没有被访问过\n                                if (wordSet.find(newWord) != wordSet.end()\n                                        && visitMap.find(newWord) == visitMap.end()) {\n                                    // 添加访问信息\n                                    visitMap.insert(pair<string, int>(newWord, path + 1));\n                                    que.push(newWord);\n                                }\n                            }\n                        }\n                    }\n                    return 0;\n                }\n            };\n        "]
    },
    {
        "id":77,
        "description":"\n        Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.\n\nYou must write an algorithm that runs in O(n) time.\n\n \n\nExample 1:\n\nInput: nums = [100,4,200,1,3,2]\nOutput: 4\nExplanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.\nExample 2:\n\nInput: nums = [0,3,7,2,5,8,4,6,0,1]\nOutput: 9\n \n\nConstraints:\n\n0 <= nums.length <= 10^5\n-10^9 <= nums[i] <= 10^9\n        ",
        "tag":["Union Find","Array","Hash Table"],
        "answer":["\n        class Solution {\n            public:\n                int longestConsecutive(vector<int>& nums) {\n                    unordered_set<int> num_set;\n                    for (const int& num : nums) {\n                        num_set.insert(num);\n                    }\n            \n                    int longestStreak = 0;\n            \n                    for (const int& num : num_set) {\n                        if (!num_set.count(num - 1)) {\n                            int currentNum = num;\n                            int currentStreak = 1;\n            \n                            while (num_set.count(currentNum + 1)) {\n                                currentNum += 1;\n                                currentStreak += 1;\n                            }\n            \n                            longestStreak = max(longestStreak, currentStreak);\n                        }\n                    }\n            \n                    return longestStreak;           \n                }\n            };\n        ","\n        \nclass Solution {\n    public:\n        int longestConsecutive(vector<int>& nums) {\n    \n            std::sort(nums.begin(),nums.end());\n            // 使用 std::unique 函数移除重复元素，并返回指向新的逻辑结尾的迭代器\n            auto it = std::unique(nums.begin(), nums.end());\n            \n            // 使用容器的 erase 函数擦除重复元素之后的部分\n            nums.erase(it, nums.end());\n    \n            int len=nums.size();\n            if(len==0){\n                return 0;\n            }\n            vector<int> dp(len,1);\n            int ans=1;\n    \n            for(int i=1;i<len;i++){\n                if(nums[i-1]==nums[i]-1){\n                    dp[i]=dp[i-1]+1;\n                }\n    \n                if(dp[i]>ans){\n                    ans=dp[i];\n                }\n            }\n    \n            return ans;\n    \n        }\n    };\n        ","\n        class Solution {\n            public:\n                int longestConsecutive(vector<int>& nums) {\n                    unordered_set<int> hash;\n                    for(auto x : nums) hash.insert(x);    //放入hash表中\n                    int res = 0;\n                    for(auto x : hash)\n                    {\n                        if(!hash.count(x-1))\n                        {\n                            int y = x;   //以当前数x向后枚举\n                            while(hash.count(y + 1)) y++;\n                            res = max(res, y - x + 1);  //更新答案\n                        }\n                    }\n                    return res;\n                }\n            };\n        "]
    },
    {
        "id":78,
        "description":"\n        Given a string s, partition s such that every \nsubstring\n of the partition is a \npalindrome\n. Return all possible palindrome partitioning of s.\n\n \n\nExample 1:\n\nInput: s = \"aab\"\nOutput: [[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]\nExample 2:\n\nInput: s = \"a\"\nOutput: [[\"a\"]]\n \n\nConstraints:\n\n1 <= s.length <= 16\ns contains only lowercase English letters.\n        ",
        "tag":["String","Dynamic Programming","Backtracking"],
        "answer":["\n        class Solution {\n            private:\n                vector<vector<int>> f;\n                vector<vector<string>> ret;\n                vector<string> ans;\n                int n;\n            \n            public:\n                void dfs(const string& s, int i) {\n                    if (i == n) {\n                        ret.push_back(ans);\n                        return;\n                    }\n                    for (int j = i; j < n; ++j) {\n                        if (f[i][j]) {\n                            ans.push_back(s.substr(i, j - i + 1));\n                            dfs(s, j + 1);\n                            ans.pop_back();\n                        }\n                    }\n                }\n            \n                vector<vector<string>> partition(string s) {\n                    n = s.size();\n                    f.assign(n, vector<int>(n, true));\n            \n                    for (int i = n - 1; i >= 0; --i) {\n                        for (int j = i + 1; j < n; ++j) {\n                            f[i][j] = (s[i] == s[j]) && f[i + 1][j - 1];\n                        }\n                    }\n            \n                    dfs(s, 0);\n                    return ret;\n                }\n            };\n        ","\n        class Solution {\n            private:\n                vector<vector<int>> f;\n                vector<vector<string>> ret;\n                vector<string> ans;\n                int n;\n            \n            public:\n                void dfs(const string& s, int i) {\n                    if (i == n) {\n                        ret.push_back(ans);\n                        return;\n                    }\n                    for (int j = i; j < n; ++j) {\n                        if (isPalindrome(s, i, j) == 1) {\n                            ans.push_back(s.substr(i, j - i + 1));\n                            dfs(s, j + 1);\n                            ans.pop_back();\n                        }\n                    }\n                }\n            \n                // 记忆化搜索中，f[i][j] = 0 表示未搜索，1 表示是回文串，-1 表示不是回文串\n                int isPalindrome(const string& s, int i, int j) {\n                    if (f[i][j]) {\n                        return f[i][j];\n                    }\n                    if (i >= j) {\n                        return f[i][j] = 1;\n                    }\n                    return f[i][j] = (s[i] == s[j] ? isPalindrome(s, i + 1, j - 1) : -1);\n                }\n            \n                vector<vector<string>> partition(string s) {\n                    n = s.size();\n                    f.assign(n, vector<int>(n));\n            \n                    dfs(s, 0);\n                    return ret;\n                }\n            };\n        ","\n        class Solution {\n            bool isPalindrome(string &s, int left, int right) {\n                while (left < right)\n                    if (s[left++] != s[right--])\n                        return false;\n                return true;\n            }\n        \n        public:\n            vector<vector<string>> partition(string s) {\n                vector<vector<string>> ans;\n                vector<string> path;\n                int n = s.length();\n        \n                // start 表示当前这段回文子串的开始位置\n                function<void(int, int)> dfs = [&](int i, int start) {\n                    if (i == n) {\n                        ans.emplace_back(path);\n                        return;\n                    }\n        \n                    // 不选 i 和 i+1 之间的逗号（i=n-1 时右边没有逗号）\n                    if (i < n - 1)\n                        dfs(i + 1, start);\n        \n                    // 选 i 和 i+1 之间的逗号\n                    if (isPalindrome(s, start, i)) {\n                        path.push_back(s.substr(start, i - start + 1));\n                        dfs(i + 1, i + 1);\n                        path.pop_back(); // 恢复现场\n                    }\n                };\n                dfs(0, 0);\n                return ans;\n            }\n        };\n        ","\n        class Solution {\n            bool isPalindrome(string &s, int left, int right) {\n                while (left < right)\n                    if (s[left++] != s[right--])\n                        return false;\n                return true;\n            }\n        \n        public:\n            vector<vector<string>> partition(string s) {\n                vector<vector<string>> ans;\n                vector<string> path;\n                int n = s.length();\n                function<void(int)> dfs = [&](int i) {\n                    if (i == n) {\n                        ans.emplace_back(path);\n                        return;\n                    }\n                    for (int j = i; j < n; ++j) { // 枚举子串的结束位置\n                        if (isPalindrome(s, i, j)) {\n                            path.push_back(s.substr(i, j - i + 1));\n                            dfs(j + 1);\n                            path.pop_back(); // 恢复现场\n                        }\n                    }\n                };\n                dfs(0);\n                return ans;\n            }\n        };\n        "]
    },
    {
        "id":79,
        "description":"\n        Given a string s, partition s such that every \nsubstring\n of the partition is a \npalindrome\n.\n\nReturn the minimum cuts needed for a palindrome partitioning of s.\n\n \n\nExample 1:\n\nInput: s = \"aab\"\nOutput: 1\nExplanation: The palindrome partitioning [\"aa\",\"b\"] could be produced using 1 cut.\nExample 2:\n\nInput: s = \"a\"\nOutput: 0\nExample 3:\n\nInput: s = \"ab\"\nOutput: 1\n \n\nConstraints:\n\n1 <= s.length <= 2000\ns consists of lowercase English letters only.\n        ",
        "tag":["String","Dynamic Programming"],
        "answer":["\n        class Solution {\n            public:\n                int minCut(string s) {\n                    int n = s.size();\n                    vector<vector<int>> g(n, vector<int>(n, true));\n            \n                    for (int i = n - 1; i >= 0; --i) {\n                        for (int j = i + 1; j < n; ++j) {\n                            g[i][j] = (s[i] == s[j]) && g[i + 1][j - 1];\n                        }\n                    }\n            \n                    vector<int> f(n, INT_MAX);\n                    for (int i = 0; i < n; ++i) {\n                        if (g[0][i]) {\n                            f[i] = 0;\n                        }\n                        else {\n                            for (int j = 0; j < i; ++j) {\n                                if (g[j + 1][i]) {\n                                    f[i] = min(f[i], f[j] + 1);\n                                }\n                            }\n                        }\n                    }\n            \n                    return f[n - 1];\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int minCut(string s) {\n                    int n = s.size();\n                    vector<vector<bool>> isPalindromic(n, vector<bool>(n, false));//二维数组，isPalindromic[i][j]表示[i, j]是不是回文子串\n                    for(int i = n - 1; i >= 0; i--){\n                        for(int j = i; j < n; j++){\n                            if(s[i] == s[j] && (j - i <= 1 || isPalindromic[i + 1][j - 1])){\n                                isPalindromic[i][j] = true;\n                            }\n                        }\n                    }\n            \n                    //初始化dp数组，dp[i]表示范围是[0, i]的回文子串，最少分割次数是dp[i]\n                    vector<int> dp(n);\n                    for(int i = 0; i < n; i++) dp[i] = i;\n                    for(int i = 1; i < n; i++){\n                        if(isPalindromic[0][i])\n                        {\n                            dp[i] = 0;\n                            continue;\n                        }\n                        for(int j = 0; j < i; j++){\n                            if(isPalindromic[j + 1][i]){\n                                dp[i] = min(dp[i], dp[j] + 1);\n                            }\n                        }\n                    }\n                    return dp[n - 1];\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int minCut(string s) {\n                    int n = s.length();  \n                    vector<int> dp(n + 5, 0x3f3f3f3f); \n                    dp[0] = 0;\n                    for (int i = 0; i < 2 * n - 1; i++) {\n                        int l = i / 2, r = l + i % 2;\n                        dp[l + 1] = min(dp[l + 1], dp[l] + 1);\n                        for (;l >= 0 && r < n && s[l] == s[r]; l--, r++) dp[r + 1] = min(dp[r + 1], dp[l] + 1);\n                    }          \n                    return dp[n] - 1;\n                }\n            };\n        "]
    },
    {
        "id":80,
        "description":"\n        There are n gas stations along a circular route, where the amount of gas at the i^th station is gas[i].\n\nYou have a car with an unlimited gas tank and it costs cost[i] of gas to travel from the i^th station to its next (i + 1)^th station. You begin the journey with an empty tank at one of the gas stations.\n\nGiven two integer arrays gas and cost, return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1. If there exists a solution, it is guaranteed to be unique\n\n \n\nExample 1:\n\nInput: gas = [1,2,3,4,5], cost = [3,4,5,1,2]\nOutput: 3\nExplanation:\nStart at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 4. Your tank = 4 - 1 + 5 = 8\nTravel to station 0. Your tank = 8 - 2 + 1 = 7\nTravel to station 1. Your tank = 7 - 3 + 2 = 6\nTravel to station 2. Your tank = 6 - 4 + 3 = 5\nTravel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.\nTherefore, return 3 as the starting index.\nExample 2:\n\nInput: gas = [2,3,4], cost = [3,4,3]\nOutput: -1\nExplanation:\nYou can't start at station 0 or 1, as there is not enough gas to travel to the next station.\nLet's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4\nTravel to station 0. Your tank = 4 - 3 + 2 = 3\nTravel to station 1. Your tank = 3 - 3 + 3 = 3\nYou cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.\nTherefore, you can't travel around the circuit once no matter where you start.\n \n\nConstraints:\n\nn == gas.length == cost.length\n1 <= n <= 10^5\n0 <= gas[i], cost[i] <= 10^4\n        ",
        "tag":["Greedy","Array"],
        "answer":["\n        class Solution {\n            public:\n                int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n                    int n = gas.size();\n                    int i = 0;\n                    while (i < n) {\n                        int sumOfGas = 0, sumOfCost = 0;\n                        int cnt = 0;\n                        while (cnt < n) {\n                            int j = (i + cnt) % n;\n                            sumOfGas += gas[j];\n                            sumOfCost += cost[j];\n                            if (sumOfCost > sumOfGas) {\n                                break;\n                            }\n                            cnt++;\n                        }\n                        if (cnt == n) {\n                            return i;\n                        } else {\n                            i = i + cnt + 1;\n                        }\n                    }\n                    return -1;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n                    int cursum = 0;\n                    int sum = 0;\n                    int start = 0;\n                    for(int i = 0; i < gas.size(); i++) {\n                        cursum += gas[i] - cost[i];\n                        sum += gas[i] - cost[i];\n                        if(cursum < 0) {\n                            start = i+1;\n                            cursum = 0;\n                        }\n                    }\n                    if(sum < 0) return -1;\n                    return start;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {\n                    int n = gas.size();\n                    int rem = 0;\n                    for(int i = 0,j;i<n;){\n                        for(j = 0;j<n;j++){\n                            int k = (i+j) % n;\n                            rem = rem + gas[k] -cost[k];\n                            if(rem<0) break;\n                        }\n                        if(n==j) return i;\n                        i = i + j + 1;\n                        rem = 0;\n                    }\n                    return -1;\n                }\n            };\n        "]
    },
    {
        "id":81,
        "description":"\n        There are n children standing in a line. Each child is assigned a rating value given in the integer array ratings.\n\nYou are giving candies to these children subjected to the following requirements:\n\nEach child must have at least one candy.\nChildren with a higher rating get more candies than their neighbors.\nReturn the minimum number of candies you need to have to distribute the candies to the children.\n\n \n\nExample 1:\n\nInput: ratings = [1,0,2]\nOutput: 5\nExplanation: You can allocate to the first, second and third child with 2, 1, 2 candies respectively.\nExample 2:\n\nInput: ratings = [1,2,2]\nOutput: 4\nExplanation: You can allocate to the first, second and third child with 1, 2, 1 candies respectively.\nThe third child gets 1 candy because it satisfies the above two conditions.\n \n\nConstraints:\n\nn == ratings.length\n1 <= n <= 2 * 10^4\n0 <= ratings[i] <= 2 * 10^4\n        ",
        "tag":["Greedy","Array"],
        "answer":["\n        class Solution {\n            public:\n                int candy(vector<int>& ratings) {\n                    int n = ratings.size();\n                    vector<int> left(n);\n                    for (int i = 0; i < n; i++) {\n                        if (i > 0 && ratings[i] > ratings[i - 1]) {\n                            left[i] = left[i - 1] + 1;\n                        } else {\n                            left[i] = 1;\n                        }\n                    }\n                    int right = 0, ret = 0;\n                    for (int i = n - 1; i >= 0; i--) {\n                        if (i < n - 1 && ratings[i] > ratings[i + 1]) {\n                            right++;\n                        } else {\n                            right = 1;\n                        }\n                        ret += max(left[i], right);\n                    }\n                    return ret;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int candy(vector<int>& ratings) {\n                    int n = ratings.size();\n                    int ret = 1;\n                    int inc = 1, dec = 0, pre = 1;\n                    for (int i = 1; i < n; i++) {\n                        if (ratings[i] >= ratings[i - 1]) {\n                            dec = 0;\n                            pre = ratings[i] == ratings[i - 1] ? 1 : pre + 1;\n                            ret += pre;\n                            inc = pre;\n                        } else {\n                            dec++;\n                            if (dec == inc) {\n                                dec++;\n                            }\n                            ret += dec;\n                            pre = 1;\n                        }\n                    }\n                    return ret;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int candy(vector<int>& ratings) {\n                    vector<int> nums(ratings.size(), 1);\n                    for (int i = 1; i < ratings.size(); ++i) if (ratings[i] > ratings[i - 1]) nums[i] = nums[i - 1] + 1;     \n                    for (int i = ratings.size() - 2; i >= 0; --i) if (ratings[i] > ratings[i + 1]) nums[i] = max(nums[i], nums[i + 1] + 1);\n                    return accumulate(nums.begin(), nums.end(), 0);\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int candy(vector<int>& ratings) {\n                    vector<int> candyVec(ratings.size(), 1);\n                    // 从前向后\n                    for (int i = 1; i < ratings.size(); i++) {\n                        if (ratings[i] > ratings[i - 1]) candyVec[i] = candyVec[i - 1] + 1;\n                    }\n                    // 从后向前\n                    for (int i = ratings.size() - 2; i >= 0; i--) {\n                        if (ratings[i] > ratings[i + 1] ) {\n                            candyVec[i] = max(candyVec[i], candyVec[i + 1] + 1);\n                        }\n                    }\n                    // 统计结果\n                    int result = 0;\n                    for (int i = 0; i < candyVec.size(); i++) result += candyVec[i];\n                    return result;\n                }\n            };\n        "]
    },
    {
        "id":82,
        "description":"\n        Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.\n\nYou must implement a solution with a linear runtime complexity and use only constant extra space.\n\n \n\nExample 1:\n\nInput: nums = [2,2,1]\nOutput: 1\nExample 2:\n\nInput: nums = [4,1,2,1,2]\nOutput: 4\nExample 3:\n\nInput: nums = [1]\nOutput: 1\n \n\nConstraints:\n\n1 <= nums.length <= 3 * 10^4\n-3 * 10^4 <= nums[i] <= 3 * 10^4\nEach element in the array appears twice except for one element which appears only once.\n        ",
        "tag":["Bit Manipulation","Array"],
        "answer":["\n        class Solution {\n            public:\n                int singleNumber(vector<int>& nums) {\n                    int ret = 0;\n                    for (auto e: nums) ret ^= e;\n                    return ret;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int singleNumber(vector<int>& nums) {\n                    int res=0;\n                    for(int i=0;i<nums.size();i++) res^=nums[i];\n                    return res;\n                }\n            };\n        ","\n        int singleNumber(int* nums, int numsSize){\n            int res = nums[0];\n            for( int i = 1;i < numsSize;i++ )\n                res ^= nums[i];\n            return res;\n        }\n        "]
    },
    {
        "id":83,
        "description":"\n        Given an integer array nums where every element appears three times except for one, which appears exactly once. Find the single element and return it.\n\nYou must implement a solution with a linear runtime complexity and use only constant extra space.\n\n \n\nExample 1:\n\nInput: nums = [2,2,3,2]\nOutput: 3\nExample 2:\n\nInput: nums = [0,1,0,1,0,1,99]\nOutput: 99\n \n\nConstraints:\n\n1 <= nums.length <= 3 * 10^4\n-2^31 <= nums[i] <= 2^31 - 1\nEach element in nums appears exactly three times except for one element which appears once.\n        ",
        "tag":["Bit Manipulation","Array"],
        "answer":["\n        class Solution {\n            public:\n                int singleNumber(vector<int>& nums) {\n                    unordered_map<int, int> freq;\n                    for (int num: nums) {\n                        ++freq[num];\n                    }\n                    int ans = 0;\n                    for (auto [num, occ]: freq) {\n                        if (occ == 1) {\n                            ans = num;\n                            break;\n                        }\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int singleNumber(vector<int>& nums) {\n                    int ans = 0;\n                    for (int i = 0; i < 32; ++i) {\n                        int total = 0;\n                        for (int num: nums) {\n                            total += ((num >> i) & 1);\n                        }\n                        if (total % 3) {\n                            ans |= (1 << i);\n                        }\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int singleNumber(vector<int>& nums) {\n                    int a = 0, b = 0;\n                    for (int num: nums) {\n                        tie(a, b) = pair{(~a & b & num) | (a & ~b & ~num), ~a & (b ^ num)};\n                    }\n                    return b;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int singleNumber(vector<int>& nums) {\n                    int a = 0, b = 0;\n                    for (int num: nums) {\n                        b = ~a & (b ^ num);\n                        a = ~b & (a ^ num);\n                    }\n                    return b;\n                }\n            };\n        "]
    },
    {
        "id":84,
        "description":"\n        Given a string s and a dictionary of strings wordDict, return true if s can be segmented into a space-separated sequence of one or more dictionary words.\n\nNote that the same word in the dictionary may be reused multiple times in the segmentation.\n\n \n\nExample 1:\n\nInput: s = \"leetcode\", wordDict = [\"leet\",\"code\"]\nOutput: true\nExplanation: Return true because \"leetcode\" can be segmented as \"leet code\".\nExample 2:\n\nInput: s = \"applepenapple\", wordDict = [\"apple\",\"pen\"]\nOutput: true\nExplanation: Return true because \"applepenapple\" can be segmented as \"apple pen apple\".\nNote that you are allowed to reuse a dictionary word.\nExample 3:\n\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\nOutput: false\n \n\nConstraints:\n\n1 <= s.length <= 300\n1 <= wordDict.length <= 1000\n1 <= wordDict[i].length <= 20\ns and wordDict[i] consist of only lowercase English letters.\nAll the strings of wordDict are unique.\n        ",
        "tag":["Trie","Memoization","Array","Hash Table","String","Dynamic Programming"],
        "answer":["\n        class Solution {\n            public:\n                bool wordBreak(string s, vector<string>& wordDict) {\n                    auto wordDictSet = unordered_set <string> ();\n                    for (auto word: wordDict) {\n                        wordDictSet.insert(word);\n                    }\n            \n                    auto dp = vector <bool> (s.size() + 1);\n                    dp[0] = true;\n                    for (int i = 1; i <= s.size(); ++i) {\n                        for (int j = 0; j < i; ++j) {\n                            if (dp[j] && wordDictSet.find(s.substr(j, i - j)) != wordDictSet.end()) {\n                                dp[i] = true;\n                                break;\n                            }\n                        }\n                    }\n            \n                    return dp[s.size()];\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool wordBreak(string s, vector<string>& wordDict) {\n                    unordered_set<string> wordSet(wordDict.begin(), wordDict.end());\n                    vector<bool> dp(s.size() + 1, false);\n                    dp[0] = true; // 递推基础\n                    // 完全背包，求排列数，先背包后物品\n                    for (int i = 1; i <= s.size(); i++) {   // 遍历背包\n                        for (int j = 0; j < i; j++) {       // 遍历物品\n                            string word = s.substr(j, i - j); //substr(起始位置，截取的个数)\n                            if (wordSet.find(word) != wordSet.end() && dp[j]) {\n                                dp[i] = true;\n                            }\n                        }\n                    }\n                    return dp[s.size()];\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool wordBreak(string s, vector<string>& wordDict) {\n            \n                    int s_len = s.length();\n                    //定义dp\n                    vector<bool> dp(s_len + 1, false);\n                    //边界条件\n                    dp[0] = true;\n                    for (int i = 0; i < s_len; ++i) {\n                        for (auto& word:wordDict) {\n                            int word_len = word.length();\n                            if (dp[i] && (i + word_len <= s_len) && s.substr(i, word_len) == word) {\n                                //状态转移公式\n                                dp[i + word_len] = dp[i];\n                            }\n                        }\n                    }\n                    return dp[s_len];\n                }\n            };\n        "]
    },
    {
        "id":85,
        "description":"\n        Given a string s and a dictionary of strings wordDict, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in any order.\n\nNote that the same word in the dictionary may be reused multiple times in the segmentation.\n\n \n\nExample 1:\n\nInput: s = \"catsanddog\", wordDict = [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"]\nOutput: [\"cats and dog\",\"cat sand dog\"]\nExample 2:\n\nInput: s = \"pineapplepenapple\", wordDict = [\"apple\",\"pen\",\"applepen\",\"pine\",\"pineapple\"]\nOutput: [\"pine apple pen apple\",\"pineapple pen apple\",\"pine applepen apple\"]\nExplanation: Note that you are allowed to reuse a dictionary word.\nExample 3:\n\nInput: s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]\nOutput: []\n \n\nConstraints:\n\n1 <= s.length <= 20\n1 <= wordDict.length <= 1000\n1 <= wordDict[i].length <= 10\ns and wordDict[i] consist of only lowercase English letters.\nAll the strings of wordDict are unique.\nInput is generated in a way that the length of the answer doesn't exceed 10^5.\n        ",
        "tag":["Trie","Memoization","Array","Hash Table","String","Dynamic Programming","Backtracking"],
        "answer":["\n        class Solution {\n            private:\n                unordered_map<int, vector<string>> ans;\n                unordered_set<string> wordSet;\n            \n            public:\n                vector<string> wordBreak(string s, vector<string>& wordDict) {\n                    wordSet = unordered_set(wordDict.begin(), wordDict.end());\n                    backtrack(s, 0);\n                    return ans[0];\n                }\n            \n                void backtrack(const string& s, int index) {\n                    if (!ans.count(index)) {\n                        if (index == s.size()) {\n                            ans[index] = {\"\"};\n                            return;\n                        }\n                        ans[index] = {};\n                        for (int i = index + 1; i <= s.size(); ++i) {\n                            string word = s.substr(index, i - index);\n                            if (wordSet.count(word)) {\n                                backtrack(s, i);\n                                for (const string& succ: ans[i]) {\n                                    ans[index].push_back(succ.empty() ? word : word + \" \" + succ);\n                                }\n                            }\n                        }\n                    }\n                }\n            };\n        ","\n        class Solution {\n            //选or不选的问题，回溯算法,每次考虑一个字母，若它能和之前未加入队列的单词构成\n            //dfs(i,j)表示考虑是否将s(i,j)的字母加入seq中\n            //递归出口：dp(n,n)表示已将所有的单词都拆分完成\n            //递归入口：dp(0,0)\n            //同样需要使用哈希表记录单词\n            public:\n                vector<string> wordBreak(string s, vector<string>& wordDict) {\n                    //初始化\n                    unordered_set<string> Dict;\n                    for(auto& word:wordDict){\n                        Dict.insert(word);\n                    }\n                    vector<string> res;\n                    vector<string> seq;     //记录当前遍历选择构成的单词，若遍历到末尾则装入\n                    int n = s.size();\n            \n                    function<void(int, int)> dfs = [&](int i, int j){\n                        //首先是返回条件\n                        if(i == n){\n                            //组装seq中所有单词，加入res\n                            string tmp;\n                            for(int i = 0; i < seq.size() - 1; i++){\n                                tmp += seq[i] + ' ';\n                            }\n                            tmp += seq.back();\n                            res.push_back(tmp);\n                        }\n                        //然后对于每一个字母我们可以不考虑在此断点,当然,最后一个字母我们必须考虑\n                        if(j < n - 1){\n                            dfs(i,j+1);\n                        }\n                        //其次，若我们考虑在此截断，将s(i,j)加入seq,首先s(i,j)形成的单词得在哈希表中\n                        string a = s.substr(i, j - i + 1);\n                        if(Dict.count(a)){\n                            seq.push_back(a);\n                            dfs(j + 1, j + 1);\n                            //回溯\n                            seq.pop_back();\n                        }\n                    };\n                    dfs(0,0);\n                    return res;\n                }\n            };\n        ","\n        class Solution {\n            private:\n            vector<string> res;\n            \n            public:\n                void dfs(string &s,vector<string>& wordDict,int i,string &t){\n                    if(i==s.size()){\n                        t.erase(t.size()-1,1);//弹出末尾空格\n                        res.push_back(t);\n                        return ;\n                    }\n            \n                    for(auto item:wordDict)//开始匹配字典与s从i之后的字符，相同则回溯递归\n                    {\n                        int l=item.size();\n                        string cmp=s.substr(i,l);\n                        int tt=t.size();//记录要清楚状态的位置。\n                        if(cmp==item){\n                            t.append(cmp);\n                            t.push_back(' ');\n                            dfs(s,wordDict,i+l,t);\n                            t.erase(tt,l+1);    //回溯的特点，清除状态\n                        }\n                        else continue;\n                    }\n            \n                }\n            \n                vector<string> wordBreak(string s, vector<string>& wordDict) {\n                    string t;\n                    dfs(s,wordDict,0,t);\n                    return res;\n                }\n            };\n        "]
    },
    {
        "id":86,
        "description":"\n        Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\n\nImplement the LRUCache class:\n\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity.\nint get(int key) Return the value of the key if the key exists, otherwise return -1.\nvoid put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key.\nThe functions get and put must each run in O(1) average time complexity.\n\n \n\nExample 1:\n\nInput\n[\"LRUCache\", \"put\", \"put\", \"get\", \"put\", \"get\", \"put\", \"get\", \"get\", \"get\"]\n[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]\nOutput\n[null, null, null, 1, null, -1, null, -1, 3, 4]\n\nExplanation\nLRUCache lRUCache = new LRUCache(2);\nlRUCache.put(1, 1); // cache is {1=1}\nlRUCache.put(2, 2); // cache is {1=1, 2=2}\nlRUCache.get(1);    // return 1\nlRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3}\nlRUCache.get(2);    // returns -1 (not found)\nlRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3}\nlRUCache.get(1);    // return -1 (not found)\nlRUCache.get(3);    // return 3\nlRUCache.get(4);    // return 4\n \n\nConstraints:\n\n1 <= capacity <= 3000\n0 <= key <= 10^4\n0 <= value <= 10^5\nAt most 2 * 10^5 calls will be made to get and put.\n        ",
        "tag":["Design","Hash Table","Linked List","Doubly-Linked List"],
        "answer":["\n        struct DLinkedNode {\n            int key, value;\n            DLinkedNode* prev;\n            DLinkedNode* next;\n            DLinkedNode(): key(0), value(0), prev(nullptr), next(nullptr) {}\n            DLinkedNode(int _key, int _value): key(_key), value(_value), prev(nullptr), next(nullptr) {}\n        };\n        \n        class LRUCache {\n        private:\n            unordered_map<int, DLinkedNode*> cache;\n            DLinkedNode* head;\n            DLinkedNode* tail;\n            int size;\n            int capacity;\n        \n        public:\n            LRUCache(int _capacity): capacity(_capacity), size(0) {\n                // 使用伪头部和伪尾部节点\n                head = new DLinkedNode();\n                tail = new DLinkedNode();\n                head->next = tail;\n                tail->prev = head;\n            }\n            \n            int get(int key) {\n                if (!cache.count(key)) {\n                    return -1;\n                }\n                // 如果 key 存在，先通过哈希表定位，再移到头部\n                DLinkedNode* node = cache[key];\n                moveToHead(node);\n                return node->value;\n            }\n            \n            void put(int key, int value) {\n                if (!cache.count(key)) {\n                    // 如果 key 不存在，创建一个新的节点\n                    DLinkedNode* node = new DLinkedNode(key, value);\n                    // 添加进哈希表\n                    cache[key] = node;\n                    // 添加至双向链表的头部\n                    addToHead(node);\n                    ++size;\n                    if (size > capacity) {\n                        // 如果超出容量，删除双向链表的尾部节点\n                        DLinkedNode* removed = removeTail();\n                        // 删除哈希表中对应的项\n                        cache.erase(removed->key);\n                        // 防止内存泄漏\n                        delete removed;\n                        --size;\n                    }\n                }\n                else {\n                    // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部\n                    DLinkedNode* node = cache[key];\n                    node->value = value;\n                    moveToHead(node);\n                }\n            }\n        \n            void addToHead(DLinkedNode* node) {\n                node->prev = head;\n                node->next = head->next;\n                head->next->prev = node;\n                head->next = node;\n            }\n            \n            void removeNode(DLinkedNode* node) {\n                node->prev->next = node->next;\n                node->next->prev = node->prev;\n            }\n        \n            void moveToHead(DLinkedNode* node) {\n                removeNode(node);\n                addToHead(node);\n            }\n        \n            DLinkedNode* removeTail() {\n                DLinkedNode* node = tail->prev;\n                removeNode(node);\n                return node;\n            }\n        };\n        ","\n        class LRUCache {\n            public:\n            \n                //定义双链表\n                struct Node{\n                    int key,value;\n                    Node* left ,*right;\n                    Node(int _key,int _value): key(_key),value(_value),left(NULL),right(NULL){}\n                }*L,*R;//双链表的最左和最右节点，不存贮值。\n                int n;\n                unordered_map<int,Node*>hash;\n            \n                void remove(Node* p)\n                {\n                    p->right->left = p->left;\n                    p->left->right = p->right;\n                }\n                void insert(Node *p)\n                {\n                    p->right = L->right;\n                    p->left = L;\n                    L->right->left = p;\n                    L->right = p;\n                }\n                LRUCache(int capacity) {\n                    n = capacity;\n                    L = new Node(-1,-1),R = new Node(-1,-1);\n                    L->right = R;\n                    R->left = L;    \n                }\n                \n                int get(int key) {\n                    if(hash.count(key) == 0) return -1; //不存在关键字 key \n                    auto p = hash[key];\n                    remove(p);\n                    insert(p);//将当前节点放在双链表的第一位\n                    return p->value;\n                }\n                \n                void put(int key, int value) {\n                    if(hash.count(key)) //如果key存在，则修改对应的value\n                    {\n                        auto p = hash[key];\n                        p->value = value;\n                        remove(p);\n                        insert(p);\n                    }\n                    else \n                    {\n                        if(hash.size() == n) //如果缓存已满，则删除双链表最右侧的节点\n                        {\n                            auto  p = R->left;\n                            remove(p);\n                            hash.erase(p->key); //更新哈希表\n                            delete p; //释放内存\n                        }\n                        //否则，插入(key, value)\n                        auto p = new Node(key,value);\n                        hash[key] = p;\n                        insert(p);\n                    }\n                }\n            };\n        ","\n        class LRUCache {\n            //首先，要实现O(1)时间get只能使用hash表\n            public:\n                LRUCache(int capacity) : capacity(capacity) {\n                    //直接使用capacity初始化capacity\n                    time = 0;\n                    poptime = 0;\n                }\n                \n                int get(int key) {\n                    if(umap.find(key) != umap.end()){\n                        //如果找到了，我们更新使用时间\n                        int lasttime = times[key];\n                        times[key] = time;\n                        time_to_key.erase(lasttime);\n                        time_to_key[time] = key;\n                        time++;\n                        return umap[key];\n                    }else{\n                        return -1;\n                    }\n                }\n                \n                void put(int key, int value) {\n                    //首先将其添加进新时间序列\n                    if(times.find(key) != times.end()){\n                        //如果之前就存在，我们要同时更新\n                        int lasttime = times[key];\n                        time_to_key.erase(lasttime);\n                        time_to_key[time] = key;\n                        times[key] = time;\n                        time++;\n                    }else{\n                        //如果之前不存在，则直接加入\n                        times[key] = time;\n                        time_to_key[time] = key;\n                        time++;\n                    }\n            \n                    //然后将其插入\n                    umap[key] = value;\n            \n                    //然后判断是否满员\n                    if(umap.size() == capacity + 1){\n                        //首先获取第一个有效的弹出时间节点\n                        while(time_to_key.find(poptime) == time_to_key.end()){\n                            poptime++;\n                        }\n                        //然后弹出它\n                        int theKey = time_to_key[poptime];\n                        times.erase(theKey);\n                        umap.erase(theKey);\n                        time_to_key.erase(poptime);\n                        poptime++;\n                    }\n                }\n            private:\n                int capacity;\n                int time;                           //标记节点的插入序号\n                int poptime;                        //标记最久未使用序号\n                unordered_map<int,int> umap;        //记录<key,value>\n                unordered_map<int,int> times;       //记录<key,插入时间>\n                unordered_map<int,int> time_to_key; //记录<插入时间,key>\n            };\n        "]
    },
    {
        "id":87,
        "description":"\n        You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.\n\nEvaluate the expression. Return an integer that represents the value of the expression.\n\nNote that:\n\nThe valid operators are '+', '-', '*', and '/'.\nEach operand may be an integer or another expression.\nThe division between two integers always truncates toward zero.\nThere will not be any division by zero.\nThe input represents a valid arithmetic expression in a reverse polish notation.\nThe answer and all the intermediate calculations can be represented in a 32-bit integer.\n \n\nExample 1:\n\nInput: tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]\nOutput: 9\nExplanation: ((2 + 1) * 3) = 9\nExample 2:\n\nInput: tokens = [\"4\",\"13\",\"5\",\"/\",\"+\"]\nOutput: 6\nExplanation: (4 + (13 / 5)) = 6\nExample 3:\n\nInput: tokens = [\"10\",\"6\",\"9\",\"3\",\"+\",\"-11\",\"*\",\"/\",\"*\",\"17\",\"+\",\"5\",\"+\"]\nOutput: 22\nExplanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5\n= ((10 * (6 / (12 * -11))) + 17) + 5\n= ((10 * (6 / -132)) + 17) + 5\n= ((10 * 0) + 17) + 5\n= (0 + 17) + 5\n= 17 + 5\n= 22\n \n\nConstraints:\n\n1 <= tokens.length <= 10^4\ntokens[i] is either an operator: \"+\", \"-\", \"*\", or \"/\", or an integer in the range [-200, 200].\n        ",
        "tag":["Stack","Array","Math"],
        "answer":["\n        class Solution {\n            public:\n                int evalRPN(vector<string>& tokens) {\n                    stack<int> stk;\n                    int n = tokens.size();\n                    for (int i = 0; i < n; i++) {\n                        string& token = tokens[i];\n                        if (isNumber(token)) {\n                            stk.push(atoi(token.c_str()));\n                        } else {\n                            int num2 = stk.top();\n                            stk.pop();\n                            int num1 = stk.top();\n                            stk.pop();\n                            switch (token[0]) {\n                                case '+':\n                                    stk.push(num1 + num2);\n                                    break;\n                                case '-':\n                                    stk.push(num1 - num2);\n                                    break;\n                                case '*':\n                                    stk.push(num1 * num2);\n                                    break;\n                                case '/':\n                                    stk.push(num1 / num2);\n                                    break;\n                            }\n                        }\n                    }\n                    return stk.top();\n                }\n            \n                bool isNumber(string& token) {\n                    return !(token == \"+\" || token == \"-\" || token == \"*\" || token == \"/\");\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int evalRPN(vector<string>& tokens) {\n                    int n = tokens.size();\n                    vector<int> stk((n + 1) / 2);\n                    int index = -1;\n                    for (int i = 0; i < n; i++) {\n                        string& token = tokens[i];\n                        if (token.length() > 1 || isdigit(token[0])) {\n                            index++;\n                            stk[index] = atoi(token.c_str());\n                        } else {\n                            switch (token[0]) {\n                                case '+':\n                                    index--;\n                                    stk[index] += stk[index + 1];\n                                    break;\n                                case '-':\n                                    index--;\n                                    stk[index] -= stk[index + 1];\n                                    break;\n                                case '*':\n                                    index--;\n                                    stk[index] *= stk[index + 1];\n                                    break;\n                                case '/':\n                                    index--;\n                                    stk[index] /= stk[index + 1];\n                                    break;\n                            }\n                        }\n                    }\n                    return stk[index];\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int evalRPN(vector<string>& tokens) {\n                    stack<int> stk;\n                    for(int i = 0; i < tokens.size(); i ++){\n                        string str = tokens[i];\n                        if(str != \"+\" && str != \"-\" && str != \"*\" && str != \"/\"){\n                            stk.push(atoi(str.c_str()));\n                        }else{\n                            int num2 = stk.top(); stk.pop();\n                            int num1 = stk.top(); stk.pop();\n                            if(str[0] == '+'){\n                                stk.push(num1 + num2);\n                            }else if(str[0] == '-'){\n                                stk.push(num1 - num2);\n                            }else if(str[0] == '*'){\n                                stk.push(num1 * num2);\n                            }else if(str[0] == '/'){\n                                stk.push(num1 / num2);\n                            }\n                        }\n                    }\n                    return stk.top();\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int evalRPN(vector<string>& tokens) {\n                    stack<int> st;\n                    for(string c : tokens){\n                        if(c == \"+\" || c == \"-\" || c == \"*\" || c == \"/\"){\n                            int tmp1 = st.top();\n                            st.pop();\n                            int tmp2 = st.top();\n                            st.pop();\n                            if(c == \"+\") st.push(tmp2 + tmp1);\n                            else if(c == \"-\") st.push(tmp2 - tmp1);\n                            else if(c == \"*\") st.push(tmp2 * tmp1);\n                            else st.push(tmp2 / tmp1);\n                        }else{\n                            st.push(stoi(c));\n                        }\n                    }\n                    return st.top();\n                }\n            };\n        "]
    },
    {
        "id":88,
        "description":"\n        Given an input string s, reverse the order of the words.\n\nA word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.\n\nReturn a string of the words in reverse order concatenated by a single space.\n\nNote that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.\n\n \n\nExample 1:\n\nInput: s = \"the sky is blue\"\nOutput: \"blue is sky the\"\nExample 2:\n\nInput: s = \"  hello world  \"\nOutput: \"world hello\"\nExplanation: Your reversed string should not contain leading or trailing spaces.\nExample 3:\n\nInput: s = \"a good   example\"\nOutput: \"example good a\"\nExplanation: You need to reduce multiple spaces between two words to a single space in the reversed string.\n \n\nConstraints:\n\n1 <= s.length <= 10^4\ns contains English letters (upper-case and lower-case), digits, and spaces ' '.\nThere is at least one word in s.\n        ",
        "tag":["Two Pointers","String"],
        "answer":["\n        class Solution {\n            public:\n                string reverseWords(string s) {\n                    // 反转整个字符串\n                    reverse(s.begin(), s.end());\n            \n                    int n = s.size();\n                    int idx = 0;\n                    for (int start = 0; start < n; ++start) {\n                        if (s[start] != ' ') {\n                            // 填一个空白字符然后将idx移动到下一个单词的开头位置\n                            if (idx != 0) s[idx++] = ' ';\n            \n                            // 循环遍历至单词的末尾\n                            int end = start;\n                            while (end < n && s[end] != ' ') s[idx++] = s[end++];\n            \n                            // 反转整个单词\n                            reverse(s.begin() + idx - (end - start), s.begin() + idx);\n            \n                            // 更新start，去找下一个单词\n                            start = end;\n                        }\n                    }\n                    s.erase(s.begin() + idx, s.end());\n                    return s;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                string reverseWords(string s) {\n                    int left = 0, right = s.size() - 1;\n                    // 去掉字符串开头的空白字符\n                    while (left <= right && s[left] == ' ') ++left;\n            \n                    // 去掉字符串末尾的空白字符\n                    while (left <= right && s[right] == ' ') --right;\n            \n                    deque<string> d;\n                    string word;\n            \n                    while (left <= right) {\n                        char c = s[left];\n                        if (word.size() && c == ' ') {\n                            // 将单词 push 到队列的头部\n                            d.push_front(move(word));\n                            word = \"\";\n                        }\n                        else if (c != ' ') {\n                            word += c;\n                        }\n                        ++left;\n                    }\n                    d.push_front(move(word));\n                    \n                    string ans;\n                    while (!d.empty()) {\n                        ans += d.front();\n                        d.pop_front();\n                        if (!d.empty()) ans += ' ';\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                string reverseWords(string s) {\n                    //定义两个指针，分别指向单词开始前一个位置和单词最后一个字母\n                    int left = s.size() - 1, right = s.size() - 1;\n                    string ans;\n                    //当左右指针都大于0时寻找单词进行赋值，从字符串最右端开始遍历\n                    while(right >= 0 && left >= 0)\n                    {\n                        //如果right为-1说明已经反转完成，退出，遍历寻找单词最后一个字母\n                        while(right != -1 && s.at(right) == ' ')  right--;\n                        if(right < 0)   break;\n                        //遍历寻找单词第一个字母的前一个位置\n                        //分为第一个字符在第一个位置和第一个位置为空格两种情况，所以-1时应该停止且避免访问负位置\n                        left = right - 1;\n                        while(left != -1 && s.at(left) != ' ')  left--;\n                        //字符串拼接\n                        ans.append(s, left + 1, right - left);\n                        ans += ' ';\n                        right = left - 1;\n                    }\n                    //删除多余添加的空格\n                    ans.pop_back();\n                    return ans;\n                }\n            };\n        "]
    },
    {
        "id":89,
        "description":"\n        Given an integer array nums, find a \nsubarray\n that has the largest product, and return the product.\n\nThe test cases are generated so that the answer will fit in a 32-bit integer.\n\n \n\nExample 1:\n\nInput: nums = [2,3,-2,4]\nOutput: 6\nExplanation: [2,3] has the largest product 6.\nExample 2:\n\nInput: nums = [-2,0,-1]\nOutput: 0\nExplanation: The result cannot be 2, because [-2,-1] is not a subarray.\n \n\nConstraints:\n\n1 <= nums.length <= 2 * 10^4\n-10 <= nums[i] <= 10\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\n        ",
        "tag":["Array","Dynamic Programming"],
        "answer":["\n        class Solution {\n            public:\n                int maxProduct(vector<int>& nums) {\n                    vector <int> maxF(nums), minF(nums);\n                    for (int i = 1; i < nums.size(); ++i) {\n                        maxF[i] = max(maxF[i - 1] * nums[i], max(nums[i], minF[i - 1] * nums[i]));\n                        minF[i] = min(minF[i - 1] * nums[i], min(nums[i], maxF[i - 1] * nums[i]));\n                    }\n                    return *max_element(maxF.begin(), maxF.end());\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int maxProduct(vector<int>& nums) {\n                    int n = nums.size();\n                    if(n == 0){\n                        return 0;\n                    } else if(n == 1) {\n                        return nums[0];\n                    }\n                    int p = nums[0];\n                    int maxP = nums[0];\n                    int minP = nums[0];\n                    for(int i = 1; i < n; i++) {\n                        int t = maxP;\n                        maxP = max(max(maxP * nums[i], nums[i]), minP *nums[i]);\n                        minP = min(min(t * nums[i], nums[i]), minP * nums[i]);\n                        p = max(maxP, p);\n                    }\n                    return p;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int maxProduct(vector<int>& nums) {\n                    int nums_len = nums.size();\n                    int max_res = INT_MIN;\n                    int cur_max = 1, cur_min = 1;\n                    for (int i = 0; i < nums_len; ++i) {\n                       //提前保存一下cur_max和cur_min前一个状态，避免更新cur_min的时候用了最新状态的cur_max\n                        int temp_max = cur_max, temp_min = cur_min;\n                        //状态转移公式\n                        cur_max = max(max(temp_max*nums[i], temp_min*nums[i]), nums[i]);\n                        cur_min = min(min(temp_max*nums[i], temp_min*nums[i]), nums[i]);\n                        //更新全局最大值\n                        max_res = max(max_res, cur_max); \n                    }\n                    return max_res;\n                }\n            };\n        "]
    },
    {
        "id":90,
        "description":"\n        Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:\n\n[4,5,6,7,0,1,2] if it was rotated 4 times.\n[0,1,2,4,5,6,7] if it was rotated 7 times.\nNotice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].\n\nGiven the sorted rotated array nums of unique elements, return the minimum element of this array.\n\nYou must write an algorithm that runs in O(log n) time.\n\n \n\nExample 1:\n\nInput: nums = [3,4,5,1,2]\nOutput: 1\nExplanation: The original array was [1,2,3,4,5] rotated 3 times.\nExample 2:\n\nInput: nums = [4,5,6,7,0,1,2]\nOutput: 0\nExplanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times.\nExample 3:\n\nInput: nums = [11,13,15,17]\nOutput: 11\nExplanation: The original array was [11,13,15,17] and it was rotated 4 times. \n \n\nConstraints:\n\nn == nums.length\n1 <= n <= 5000\n-5000 <= nums[i] <= 5000\nAll the integers of nums are unique.\nnums is sorted and rotated between 1 and n times.\n        ",
        "tag":["Array","Binary Search"],
        "answer":["\n        class Solution {\n            public:\n                int findMin(vector<int>& nums) {\n                    int low = 0;\n                    int high = nums.size() - 1;\n                    while (low < high) {\n                        int pivot = low + (high - low) / 2;\n                        if (nums[pivot] < nums[high]) {\n                            high = pivot;\n                        }\n                        else {\n                            low = pivot + 1;\n                        }\n                    }\n                    return nums[low];\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int findMin(vector<int>& nums) {\n                    int left = 0;\n                    int right = nums.size() - 1;\n                    while (left < right) {\n                        int mid = left + (right - left) / 2;\n                        if (nums[mid] > nums[right]) {          \n                            left = mid + 1;\n                        } else {                               \n                            right = mid;\n                        }\n                    }\n                    return nums[left];\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int findMin(vector<int>& nums) {\n                    int left = 0;\n                    int right = nums.size() - 1;\n                    while (left <= right) {                         // 循环的条件选为左闭右闭区间left <= right\n                        int mid = left + (right - left) / 2;\n                        if (nums[mid] >= nums[right]) {             // 注意是当中值大于等于右值时，\n                            left = mid + 1;                         // 将左边界移动到中值的右边\n                        } else {                                    // 当中值小于右值时\n                            right = mid;                            // 将右边界移动到中值处\n                        }\n                    }\n                    return nums[right];                             // 最小值返回nums[right]\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int findMin(vector<int>& nums) {\n                    int right_boundary = nums[nums.size() - 1];\n                    int left = 0;\n                    int right = nums.size() - 1;\n                    while (left < right) {\n                        int mid = left + (right - left) / 2;\n                        if (nums[mid] > right_boundary) {\n                            left = mid + 1;\n                        } else {\n                            right = mid;\n                        }\n                    }\n                    return nums[left];\n                }\n            };\n        "]
    },
    {
        "id":91,
        "description":"\n        Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,4,4,5,6,7] might become:\n\n[4,5,6,7,0,1,4] if it was rotated 4 times.\n[0,1,4,4,5,6,7] if it was rotated 7 times.\nNotice that rotating an array [a[0], a[1], a[2], ..., a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], ..., a[n-2]].\n\nGiven the sorted rotated array nums that may contain duplicates, return the minimum element of this array.\n\nYou must decrease the overall operation steps as much as possible.\n\n \n\nExample 1:\n\nInput: nums = [1,3,5]\nOutput: 1\nExample 2:\n\nInput: nums = [2,2,2,0,1]\nOutput: 0\n \n\nConstraints:\n\nn == nums.length\n1 <= n <= 5000\n-5000 <= nums[i] <= 5000\nnums is sorted and rotated between 1 and n times.\n        ",
        "tag":["Array","Binary Search"],
        "answer":["\n        class Solution {\n            public:\n                int findMin(vector<int>& nums) {\n                    int low = 0;\n                    int high = nums.size() - 1;\n                    while (low < high) {\n                        int pivot = low + (high - low) / 2;\n                        if (nums[pivot] < nums[high]) {\n                            high = pivot;\n                        }\n                        else if (nums[pivot] > nums[high]) {\n                            low = pivot + 1;\n                        }\n                        else {\n                            high -= 1;\n                        }\n                    }\n                    return nums[low];\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int findMin(vector<int> &nums) {\n                    int left = -1, right = nums.size() - 1; // 开区间 (-1, n-1)\n                    while (left + 1 < right) { // 开区间不为空\n                        int mid = left + (right - left) / 2;\n                        if (nums[mid] < nums[right]) right = mid; // 蓝色\n                        else if (nums[mid] > nums[right]) left = mid; // 红色\n                        else --right;\n                    }\n                    return nums[right];\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int findMin(vector<int>& nums) {\n                    // 恢复二段性\n                    int n = nums.size();\n                    int left = 0,right = n - 1;\n                    while(left < right && nums[right] == nums[0]){\n                        right--;\n                    }\n                    // 找到旋转点\n                    while (left < right){\n                        int mid = left + right + 1 >> 1;\n                        if(nums[mid] >= nums[0]){\n                            left = mid;\n                        } else{\n                            right = mid - 1;\n                        }\n                    }\n                    return right + 1 < n ? nums[right + 1] : nums[0];\n                }\n            };\n        "]
    },
    {
        "id":92,
        "description":"\n        Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\n\nImplement the MinStack class:\n\nMinStack() initializes the stack object.\nvoid push(int val) pushes the element val onto the stack.\nvoid pop() removes the element on the top of the stack.\nint top() gets the top element of the stack.\nint getMin() retrieves the minimum element in the stack.\nYou must implement a solution with O(1) time complexity for each function.\n\n \n\nExample 1:\n\nInput\n[\"MinStack\",\"push\",\"push\",\"push\",\"getMin\",\"pop\",\"top\",\"getMin\"]\n[[],[-2],[0],[-3],[],[],[],[]]\n\nOutput\n[null,null,null,null,-3,null,0,-2]\n\nExplanation\nMinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin(); // return -3\nminStack.pop();\nminStack.top();    // return 0\nminStack.getMin(); // return -2\n \n\nConstraints:\n\n-2^31 <= val <= 2^31 - 1\nMethods pop, top and getMin operations will always be called on non-empty stacks.\nAt most 3 * 10^4 calls will be made to push, pop, top, and getMin.\n        ",
        "tag":["Stack","Design"],
        "answer":["\n        class MinStack {\n            stack<int> x_stack;\n            stack<int> min_stack;\n        public:\n            MinStack() {\n                min_stack.push(INT_MAX);\n            }\n            \n            void push(int x) {\n                x_stack.push(x);\n                min_stack.push(min(min_stack.top(), x));\n            }\n            \n            void pop() {\n                x_stack.pop();\n                min_stack.pop();\n            }\n            \n            int top() {\n                return x_stack.top();\n            }\n            \n            int getMin() {\n                return min_stack.top();\n            }\n        };\n        ","\n        class MinStack {\n            public:\n                /* 定义两个栈容器 */\n                stack<int> st;\n                stack<int> minStack;\n            \n                /** 构造函数清空栈容器  */\n                MinStack() {\n                    while(!st.empty()) {\n                        st.pop();\n                    }\n                    while(!minStack.empty()) {\n                        minStack.pop();\n                    }\n                    /* 初始化最小栈的栈顶元素为最大值为了防止top访问空指针报错 */\n                    minStack.push(INT_MAX);\n                }\n                \n                void push(int x) {\n                    st.push(x);\n                    /* 比较最小栈的栈顶的值和当前值val的大小，将最小值押入最小栈也就是记录了当前st栈的最小值为栈顶元素 */\n                    int minVal = std::min(minStack.top(), x);\n                    /* 将最小值押入最小栈 */\n                    minStack.push(minVal);\n                }\n                \n                void pop() {\n                    /* 弹出两个栈的栈顶元素 */\n                    st.pop();\n                    minStack.pop();\n                }\n                \n                int top() {\n                    return st.top();\n                }\n                \n                int min() {\n                    /* 取最小栈的栈顶元素就是此时st栈的最小值 */\n                    return minStack.top();\n                }\n            };\n        ","\n        class MinStack {\n            private:\n                stack<int> s;\n                vector<int> v;\n            public:\n                /** initialize your data structure here. */\n                MinStack() {\n                    \n                }\n                \n                void push(int val) {\n                    if(s.empty()){\n                        v.push_back(val);\n                    }else{\n                        if(val < v.back()){\n                            v.push_back(val);\n                        }else{\n                            v.push_back(v.back());\n                        }\n                    }\n                    s.push(val);\n                }\n                \n                void pop() {\n                    s.pop();\n                    v.pop_back();\n                }\n                \n                int top() {\n                    return s.top();\n                }\n                \n                int getMin() {\n                    return v.back();\n                }\n            };\n        "]
    },
    {
        "id":93,
        "description":"\n        A peak element is an element that is strictly greater than its neighbors.\n\nGiven a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\n\nYou may imagine that nums[-1] = nums[n] = -∞. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\n\nYou must write an algorithm that runs in O(log n) time.\n\n \n\nExample 1:\n\nInput: nums = [1,2,3,1]\nOutput: 2\nExplanation: 3 is a peak element and your function should return the index number 2.\nExample 2:\n\nInput: nums = [1,2,1,3,5,6,4]\nOutput: 5\nExplanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.\n \n\nConstraints:\n\n1 <= nums.length <= 1000\n-2^31 <= nums[i] <= 2^31 - 1\nnums[i] != nums[i + 1] for all valid i.\n        ",
        "tag":["Array","Binary Search"],
        "answer":["\n        class Solution {\n            public:\n                int findPeakElement(vector<int>& nums) {\n                    return max_element(nums.begin(), nums.end()) - nums.begin();\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int findPeakElement(vector<int>& nums) {\n                    int n = nums.size();\n                    int idx = rand() % n;\n            \n                    // 辅助函数，输入下标 i，返回一个二元组 (0/1, nums[i])\n                    // 方便处理 nums[-1] 以及 nums[n] 的边界情况\n                    auto get = [&](int i) -> pair<int, int> {\n                        if (i == -1 || i == n) {\n                            return {0, 0};\n                        }\n                        return {1, nums[i]};\n                    };\n            \n                    while (!(get(idx - 1) < get(idx) && get(idx) > get(idx + 1))) {\n                        if (get(idx) < get(idx + 1)) {\n                            idx += 1;\n                        }\n                        else {\n                            idx -= 1;\n                        }\n                    }\n                    \n                    return idx;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int findPeakElement(vector<int>& nums) {\n                    int n = nums.size();\n            \n                    // 辅助函数，输入下标 i，返回一个二元组 (0/1, nums[i])\n                    // 方便处理 nums[-1] 以及 nums[n] 的边界情况\n                    auto get = [&](int i) -> pair<int, int> {\n                        if (i == -1 || i == n) {\n                            return {0, 0};\n                        }\n                        return {1, nums[i]};\n                    };\n            \n                    int left = 0, right = n - 1, ans = -1;\n                    while (left <= right) {\n                        int mid = (left + right) / 2;\n                        if (get(mid - 1) < get(mid) && get(mid) > get(mid + 1)) {\n                            ans = mid;\n                            break;\n                        }\n                        if (get(mid) < get(mid + 1)) {\n                            left = mid + 1;\n                        }\n                        else {\n                            right = mid - 1;\n                        }\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int findPeakElement(vector<int> &nums) {\n                    int left = -1, right = nums.size() - 1; // 开区间 (-1, n-1)\n                    while (left + 1 < right) { // 开区间不为空\n                        int mid = left + (right - left) / 2;\n                        if (nums[mid] > nums[mid + 1]) right = mid; // 蓝色\n                        else left = mid; // 红色\n                    }\n                    return right;\n                }\n            };\n        "]
    },
    {
        "id":94,
        "description":"\n        Given an integer array nums, return the maximum difference between two successive elements in its sorted form. If the array contains less than two elements, return 0.\n\nYou must write an algorithm that runs in linear time and uses linear extra space.\n\n \n\nExample 1:\n\nInput: nums = [3,6,9,1]\nOutput: 3\nExplanation: The sorted form of the array is [1,3,6,9], either (3,6) or (6,9) has the maximum difference 3.\nExample 2:\n\nInput: nums = [10]\nOutput: 0\nExplanation: The array contains less than 2 elements, therefore return 0.\n \n\nConstraints:\n\n1 <= nums.length <= 10^5\n0 <= nums[i] <= 10^9\n        ",
        "tag":["Array","Bucket Sort","Radix Sort","Sorting"],
        "answer":["\n        class Solution {\n            public:\n                int maximumGap(vector<int>& nums) {\n                    int n = nums.size();\n                    if (n < 2) {\n                        return 0;\n                    }\n                    int exp = 1;\n                    vector<int> buf(n);\n                    int maxVal = *max_element(nums.begin(), nums.end());\n            \n                    while (maxVal >= exp) {\n                        vector<int> cnt(10);\n                        for (int i = 0; i < n; i++) {\n                            int digit = (nums[i] / exp) % 10;\n                            cnt[digit]++;\n                        }\n                        for (int i = 1; i < 10; i++) {\n                            cnt[i] += cnt[i - 1];\n                        }\n                        for (int i = n - 1; i >= 0; i--) {\n                            int digit = (nums[i] / exp) % 10;\n                            buf[cnt[digit] - 1] = nums[i];\n                            cnt[digit]--;\n                        }\n                        copy(buf.begin(), buf.end(), nums.begin());\n                        exp *= 10;\n                    }\n            \n                    int ret = 0;\n                    for (int i = 1; i < n; i++) {\n                        ret = max(ret, nums[i] - nums[i - 1]);\n                    }\n                    return ret;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int maximumGap(vector<int>& nums) {\n                    int n = nums.size();\n                    if (n < 2) {\n                        return 0;\n                    }\n                    int minVal = *min_element(nums.begin(), nums.end());\n                    int maxVal = *max_element(nums.begin(), nums.end());\n                    int d = max(1, (maxVal - minVal) / (n - 1));\n                    int bucketSize = (maxVal - minVal) / d + 1;\n            \n                    vector<pair<int, int>> bucket(bucketSize, {-1, -1});  // 存储 (桶内最小值，桶内最大值) 对，(-1, -1) 表示该桶是空的\n                    for (int i = 0; i < n; i++) {\n                        int idx = (nums[i] - minVal) / d;\n                        if (bucket[idx].first == -1) {\n                            bucket[idx].first = bucket[idx].second = nums[i];\n                        } else {\n                            bucket[idx].first = min(bucket[idx].first, nums[i]);\n                            bucket[idx].second = max(bucket[idx].second, nums[i]);\n                        }\n                    }\n            \n                    int ret = 0;\n                    int prev = -1;\n                    for (int i = 0; i < bucketSize; i++) {\n                        if (bucket[i].first == -1) continue;\n                        if (prev != -1) {\n                            ret = max(ret, bucket[i].first - bucket[prev].second);\n                        }\n                        prev = i;\n                    }\n                    return ret;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int maximumGap(vector<int>& nums) {\n                    int maxn=-1;\n                    int n=nums.size();\n                    if(n<2)    return 0;\n                    else{\n                        sort(nums.begin(),nums.end());\n                        for(int i=1;i<n;i++)\n                            maxn=max(maxn,nums[i]-nums[i-1]);\n                    }\n                    return maxn;\n                }\n            };\n        "]
    },
    {
        "id":95,
        "description":"\n        Given two version numbers, version1 and version2, compare them.\n\nVersion numbers consist of one or more revisions joined by a dot '.'. Each revision consists of digits and may contain leading zeros. Every revision contains at least one character. Revisions are 0-indexed from left to right, with the leftmost revision being revision 0, the next revision being revision 1, and so on. For example 2.5.33 and 0.1 are valid version numbers.\n\nTo compare version numbers, compare their revisions in left-to-right order. Revisions are compared using their integer value ignoring any leading zeros. This means that revisions 1 and 001 are considered equal. If a version number does not specify a revision at an index, then treat the revision as 0. For example, version 1.0 is less than version 1.1 because their revision 0s are the same, but their revision 1s are 0 and 1 respectively, and 0 < 1.\n\nReturn the following:\n\nIf version1 < version2, return -1.\nIf version1 > version2, return 1.\nOtherwise, return 0.\n \n\nExample 1:\n\nInput: version1 = \"1.01\", version2 = \"1.001\"\nOutput: 0\nExplanation: Ignoring leading zeroes, both \"01\" and \"001\" represent the same integer \"1\".\nExample 2:\n\nInput: version1 = \"1.0\", version2 = \"1.0.0\"\nOutput: 0\nExplanation: version1 does not specify revision 2, which means it is treated as \"0\".\nExample 3:\n\nInput: version1 = \"0.1\", version2 = \"1.1\"\nOutput: -1\nExplanation: version1's revision 0 is \"0\", while version2's revision 0 is \"1\". 0 < 1, so version1 < version2.\n \n\nConstraints:\n\n1 <= version1.length, version2.length <= 500\nversion1 and version2 only contain digits and '.'.\nversion1 and version2 are valid version numbers.\nAll the given revisions in version1 and version2 can be stored in a 32-bit integer.\n        ",
        "tag":["Two Pointers","String"],
        "answer":["\n        class Solution {\n            public:\n                int compareVersion(string version1, string version2) {\n                    int n = version1.length(), m = version2.length();\n                    int i = 0, j = 0;\n                    while (i < n || j < m) {\n                        int x = 0;\n                        for (; i < n && version1[i] != '.'; ++i) {\n                            x = x * 10 + version1[i] - '0';\n                        }\n                        ++i; // 跳过点号\n                        int y = 0;\n                        for (; j < m && version2[j] != '.'; ++j) {\n                            y = y * 10 + version2[j] - '0';\n                        }\n                        ++j; // 跳过点号\n                        if (x != y) {\n                            return x > y ? 1 : -1;\n                        }\n                    }\n                    return 0;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int compareVersion(string v1, string v2) {\n                    int i = 0, j = 0;\n                    while(i < v1.size() || j < v2.size())\n                    {\n                        long long num1 = 0, num2 = 0;   //数据加强了，这里要用long long\n                        while(i < v1.size() && v1[i] != '.') num1 = num1 * 10 + v1[i++] - '0';\n                        while(j < v2.size() && v2[j] != '.') num2 = num2 * 10 + v2[j++] - '0';\n                        if(num1 > num2) return 1;\n                        else if( num1 < num2) return -1;\n                        i++,j++;\n                    }\n                    return 0;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int compareVersion(string version1, string version2) {\n                    int p1 = 0;\n                    int p2 = 0;\n            \n                    int len1 = version1.size();\n                    int len2 = version2.size();\n            \n                    while (p1 < len1 || p2 < len2) {\n                        // 从左到右逐位（两个.之间的小版本）对比 两个版本号\n                        int num1 = 0;\n                        int num2 = 0;\n            \n            \n                        while(p1 < len1 && version1[p1] != '.') {\n                            num1 = num1 * 10 + (version1[p1] - '0');\n                            p1++;\n                        }\n                        while(p2 < len2 && version2[p2] != '.') {\n                            num2 = num2 * 10 + (version2[p2] - '0');\n                            p2++;\n                        }\n            \n                        // 比较版本号\n                        if (num1 < num2) return -1;\n                        if (num1 > num2) return 1;\n            \n                        // 跳过 '.'\n                        p1++;\n                        p2++;\n                    }\n            \n                    return 0;\n                }\n            };\n        "]
    },
    {
        "id":96,
        "description":"\n        Given two integers representing the numerator and denominator of a fraction, return the fraction in string format.\n\nIf the fractional part is repeating, enclose the repeating part in parentheses.\n\nIf multiple answers are possible, return any of them.\n\nIt is guaranteed that the length of the answer string is less than 104 for all the given inputs.\n\n \n\nExample 1:\n\nInput: numerator = 1, denominator = 2\nOutput: \"0.5\"\nExample 2:\n\nInput: numerator = 2, denominator = 1\nOutput: \"2\"\nExample 3:\n\nInput: numerator = 4, denominator = 333\nOutput: \"0.(012)\"\n \n\nConstraints:\n\n-2^31 <= numerator, denominator <= 2^31 - 1\ndenominator != 0\n        ",
        "tag":["Hash Table","Math","String"],
        "answer":["\n        class Solution {\n            public:\n                string fractionToDecimal(int numerator, int denominator) {\n                    long numeratorLong = numerator;\n                    long denominatorLong = denominator;\n                    if (numeratorLong % denominatorLong == 0) {\n                        return to_string(numeratorLong / denominatorLong);\n                    }\n            \n                    string ans;\n                    if (numeratorLong < 0 ^ denominatorLong < 0) {\n                        ans.push_back('-');\n                    }\n            \n                    // 整数部分\n                    numeratorLong = abs(numeratorLong);\n                    denominatorLong = abs(denominatorLong);\n                    long integerPart = numeratorLong / denominatorLong;\n                    ans += to_string(integerPart);\n                    ans.push_back('.');\n            \n                    // 小数部分\n                    string fractionPart;\n                    unordered_map<long, int> remainderIndexMap;\n                    long remainder = numeratorLong % denominatorLong;\n                    int index = 0;\n                    while (remainder != 0 && !remainderIndexMap.count(remainder)) {\n                        remainderIndexMap[remainder] = index;\n                        remainder *= 10;\n                        fractionPart += to_string(remainder / denominatorLong);\n                        remainder %= denominatorLong;\n                        index++;\n                    }\n                    if (remainder != 0) { // 有循环节\n                        int insertIndex = remainderIndexMap[remainder];\n                        fractionPart = fractionPart.substr(0,insertIndex) + '(' + fractionPart.substr(insertIndex);\n                        fractionPart.push_back(')');\n                    }\n                    ans += fractionPart;\n            \n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                static string fractionToDecimal(int numerator, int denominator) {\n                    long long a = numerator;\n                    long long b = denominator;\n                    if (a % b == 0) {\n                        return to_string(a / b);\n                    }\n                    string result;\n                    if (a * b < 0) {\n                        result += \"-\";\n                    }\n                    a = abs(a);\n                    b = abs(b);\n                    result += to_string(a / b) + \".\";\n                    a = a % b;\n                    unordered_map<long long, int> map;\n                    while (a != 0) {\n                        map[a] = (int) result.size();\n                        a *= 10;\n                        result += to_string(a / b);\n                        a = a % b;\n                        if (map.count(a)) {\n                            int index = map[a];\n                            return result.insert(index, \"(\") + \")\";\n                        }\n                    }\n                    return result;\n                }\n            };\n        ","\n        class Solution {\n            using ll = long long;\n        public:\n            string fractionToDecimal(int numerator, int denominator) {\n                ll n = numerator, d = denominator;\n                string ret;\n                // 计算整数部分\n                // 判断负数\n                if(n * d < 0) ret += \"-\";\n        \n        \n                ll a = n / d;\n                if(a < 0) a *= -1;\n                ret += to_string(a);\n        \n                if(n < 0) n*= -1;\n                if(d < 0) d*= -1;\n        \n                // 计算小数部分\n                n %= d;\n                if(n == 0) {\n                    // 无小数\n                    return ret;\n                }\n                ret += \".\";\n                // 连除\n                // 哈希表记录是否有数组第二次出现\n                unordered_map<int, int> st;\n                string t;\n                int index = 0;\n                while(n && !st.count(n)) {\n                    st[n] = index++;\n                    n *= 10;\n                    t.push_back((char)(n / d + '0'));\n                    n %= d;\n                }\n                if(n != 0) {\n                    // 说明出现了循环，此时对循环部分 [st[n], index] 加括号\n                    ret += t.substr(0, st[n]) + \"(\" + t.substr(st[n]) + \")\";\n                } else {\n                    ret += t;\n                }\n                return ret;\n            }\n        };\n        "]
    },
    {
        "id":97,
        "description":"\n        Given a 1-indexed array of integers numbers that is already sorted in non-decreasing order, find two numbers such that they add up to a specific target number. Let these two numbers be numbers[index1] and numbers[index2] where 1 <= index1 < index2 < numbers.length.\n\nReturn the indices of the two numbers, index1 and index2, added by one as an integer array [index1, index2] of length 2.\n\nThe tests are generated such that there is exactly one solution. You may not use the same element twice.\n\nYour solution must use only constant extra space.\n\n \n\nExample 1:\n\nInput: numbers = [2,7,11,15], target = 9\nOutput: [1,2]\nExplanation: The sum of 2 and 7 is 9. Therefore, index1 = 1, index2 = 2. We return [1, 2].\nExample 2:\n\nInput: numbers = [2,3,4], target = 6\nOutput: [1,3]\nExplanation: The sum of 2 and 4 is 6. Therefore index1 = 1, index2 = 3. We return [1, 3].\nExample 3:\n\nInput: numbers = [-1,0], target = -1\nOutput: [1,2]\nExplanation: The sum of -1 and 0 is -1. Therefore index1 = 1, index2 = 2. We return [1, 2].\n \n\nConstraints:\n\n2 <= numbers.length <= 3 * 10^4\n-1000 <= numbers[i] <= 1000\nnumbers is sorted in non-decreasing order.\n-1000 <= target <= 1000\nThe tests are generated such that there is exactly one solution.\n        ",
        "tag":["Array","Two Pointers","Binary Search"],
        "answer":["\n        class Solution {\n            public:\n                vector<int> twoSum(vector<int>& numbers, int target) {\n                    for (int i = 0; i < numbers.size(); ++i) {\n                        int low = i + 1, high = numbers.size() - 1;\n                        while (low <= high) {\n                            int mid = (high - low) / 2 + low;\n                            if (numbers[mid] == target - numbers[i]) {\n                                return {i + 1, mid + 1};\n                            } else if (numbers[mid] > target - numbers[i]) {\n                                high = mid - 1;\n                            } else {\n                                low = mid + 1;\n                            }\n                        }\n                    }\n                    return {-1, -1};\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<int> twoSum(vector<int>& numbers, int target) {\n                    int low = 0, high = numbers.size() - 1;\n                    while (low < high) {\n                        int sum = numbers[low] + numbers[high];\n                        if (sum == target) {\n                            return {low + 1, high + 1};\n                        } else if (sum < target) {\n                            ++low;\n                        } else {\n                            --high;\n                        }\n                    }\n                    return {-1, -1};\n                }\n            };\n        ","\n        vector<int> twoSum(vector<int>& numbers, int target) {\n            int i = 0;\n            int j = numbers.size()-1;\n            while (i < j) {\n                int sum = numbers[i] + numbers[j];\n                if (sum < target) {\n                    i++;\n                } else if (sum > target) {\n                    j--;\n                } else {\n                    return vector<int>{i+1, j+1};\n                }\n            }\n            return vector<int>{-1, -1};\n        }\n        "]
    },
    {
        "id":98,
        "description":"\n        Given an integer columnNumber, return its corresponding column title as it appears in an Excel sheet.\n\nFor example:\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n \n\nExample 1:\n\nInput: columnNumber = 1\nOutput: \"A\"\nExample 2:\n\nInput: columnNumber = 28\nOutput: \"AB\"\nExample 3:\n\nInput: columnNumber = 701\nOutput: \"ZY\"\n \n\nConstraints:\n\n1 <= columnNumber <= 2^31 - 1\n        ",
        "tag":["Math","String"],
        "answer":["\n        class Solution {\n            public:\n                string convertToTitle(int columnNumber) {\n                    string ans;\n                    while (columnNumber > 0) {\n                        int a0 = (columnNumber - 1) % 26 + 1;\n                        ans += a0 - 1 + 'A';\n                        columnNumber = (columnNumber - a0) / 26;\n                    }\n                    reverse(ans.begin(), ans.end());\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                string convertToTitle(int columnNumber) {\n                    string ans;\n                    while (columnNumber > 0) {\n                        --columnNumber;\n                        ans += columnNumber % 26 + 'A';\n                        columnNumber /= 26;\n                    }\n                    reverse(ans.begin(), ans.end());\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                string convertToTitle(int columnNumber) {\n                    int dividend = columnNumber;\n                    vector<char> tmpRst;\n                    while(dividend > 0)\n                    {\n                        int remainder = dividend%26;\n                        if(remainder == 0)  // a_0 == 26\n                        {\n                            tmpRst.push_back('Z');\n                            dividend -= 26;\n                            dividend /=26;\n                        }\n                        else\n                        {\n                            tmpRst.push_back('A' + remainder-1);\n                            dividend /= 26;\n                        }\n                    }\n                    return string(tmpRst.rbegin(), tmpRst.rend());\n                }\n            };\n        ","\n        string convertToTitle(int columnNumber)\n{\n    string row;\n    while (columnNumber)\n    {\n        int remainder = columnNumber % 26;\n        if(remainder==0)//如果余数是0，就像上一位借个1（26）出来，让余数强行等于26\n        {\n            remainder = 26;\n            columnNumber -= 26;\n        }\n        row.push_back(remainder+ 64);\n        columnNumber /= 26;\n    }\n    reverse(row.begin(), row.end());\n    return row;\n}\n        "]
    },
    {
        "id":99,
        "description":"\n        Given an array nums of size n, return the majority element.\n\nThe majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.\n\n \n\nExample 1:\n\nInput: nums = [3,2,3]\nOutput: 3\nExample 2:\n\nInput: nums = [2,2,1,1,1,2,2]\nOutput: 2\n \n\nConstraints:\n\nn == nums.length\n1 <= n <= 5 * 10^4\n-10^9 <= nums[i] <= 10^9\n        ",
        "tag":["Array","Hash Table","Divide and Conquer","Counting","Sorting"],
        "answer":["\n        class Solution {\n            public:\n                int majorityElement(vector<int>& nums) {\n                    unordered_map<int, int> counts;\n                    int majority = 0, cnt = 0;\n                    for (int num: nums) {\n                        ++counts[num];\n                        if (counts[num] > cnt) {\n                            majority = num;\n                            cnt = counts[num];\n                        }\n                    }\n                    return majority;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int majorityElement(vector<int>& nums) {\n                    sort(nums.begin(), nums.end());\n                    return nums[nums.size() / 2];\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int majorityElement(vector<int>& nums) {\n                    while (true) {\n                        int candidate = nums[rand() % nums.size()];\n                        int count = 0;\n                        for (int num : nums)\n                            if (num == candidate)\n                                ++count;\n                        if (count > nums.size() / 2)\n                            return candidate;\n                    }\n                    return -1;\n                }\n            };\n        ","\n        class Solution {\n            int count_in_range(vector<int>& nums, int target, int lo, int hi) {\n                int count = 0;\n                for (int i = lo; i <= hi; ++i)\n                    if (nums[i] == target)\n                        ++count;\n                return count;\n            }\n            int majority_element_rec(vector<int>& nums, int lo, int hi) {\n                if (lo == hi)\n                    return nums[lo];\n                int mid = (lo + hi) / 2;\n                int left_majority = majority_element_rec(nums, lo, mid);\n                int right_majority = majority_element_rec(nums, mid + 1, hi);\n                if (count_in_range(nums, left_majority, lo, hi) > (hi - lo + 1) / 2)\n                    return left_majority;\n                if (count_in_range(nums, right_majority, lo, hi) > (hi - lo + 1) / 2)\n                    return right_majority;\n                return -1;\n            }\n        public:\n            int majorityElement(vector<int>& nums) {\n                return majority_element_rec(nums, 0, nums.size() - 1);\n            }\n        };\n        ","\n        class Solution {\n            public:\n                int majorityElement(vector<int>& nums) {\n                    int candidate = -1;\n                    int count = 0;\n                    for (int num : nums) {\n                        if (num == candidate)\n                            ++count;\n                        else if (--count < 0) {\n                            candidate = num;\n                            count = 1;\n                        }\n                    }\n                    return candidate;\n                }\n            };\n        "]
    },
    {
        "id":100,
        "description":"\n        Given a string columnTitle that represents the column title as appears in an Excel sheet, return its corresponding column number.\n\nFor example:\n\nA -> 1\nB -> 2\nC -> 3\n...\nZ -> 26\nAA -> 27\nAB -> 28 \n...\n \n\nExample 1:\n\nInput: columnTitle = \"A\"\nOutput: 1\nExample 2:\n\nInput: columnTitle = \"AB\"\nOutput: 28\nExample 3:\n\nInput: columnTitle = \"ZY\"\nOutput: 701\n \n\nConstraints:\n\n1 <= columnTitle.length <= 7\ncolumnTitle consists only of uppercase English letters.\ncolumnTitle is in the range [\"A\", \"FXSHRXW\"].\n        ",
        "tag":["Math","String"],
        "answer":["\n        class Solution {\n            public:\n                int titleToNumber(string columnTitle) {\n                    int number = 0;\n                    long multiple = 1;\n                    for (int i = columnTitle.size() - 1; i >= 0; i--) {\n                        int k = columnTitle[i] - 'A' + 1;\n                        number += k * multiple;\n                        multiple *= 26;\n                    }\n                    return number;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int titleToNumber(string columnTitle) {\n                    int n = columnTitle.size();\n                    int num = 0;\n                    for(int i = 0; i < n; ++i) {\n                        num = num * 26 + (columnTitle[i] - 'A' + 1) ;\n                    }\n                    return num;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int titleToNumber(string columnTitle) {\n                    const int change = 'A' - 1;   //转换成数字要减去的数\n                    int ans = 0;\n                    for(char& alt: columnTitle){  //遍历，每次乘于26\n                        ans *= 26;\n                        ans += alt - change;\n                    }\n                    return ans;\n                }\n            };\n        "]
    },
    {
        "id":101,
        "description":"\n        Given an integer n, return the number of trailing zeroes in n!.\n\nNote that n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1.\n\n \n\nExample 1:\n\nInput: n = 3\nOutput: 0\nExplanation: 3! = 6, no trailing zero.\nExample 2:\n\nInput: n = 5\nOutput: 1\nExplanation: 5! = 120, one trailing zero.\nExample 3:\n\nInput: n = 0\nOutput: 0\n \n\nConstraints:\n\n0 <= n <= 10^4\n        ",
        "tag":["Math"],
        "answer":["\n        class Solution {\n            public:\n                int trailingZeroes(int n) {\n                    int ans = 0;\n                    for (int i = 5; i <= n; i += 5) {\n                        for (int x = i; x % 5 == 0; x /= 5) {\n                            ++ans;\n                        }\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int trailingZeroes(int n) {\n                    int ans = 0;\n                    while (n) {\n                        n /= 5;\n                        ans += n;\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int trailingZeroes(int n) {\n                    int cnt = 0;\n                    for (int x = n / 5; x > 0; x /= 5) cnt += x;\n                    return cnt;\n                }\n            };\n        "]
    },
    {
        "id":102,
        "description":"\n        Given a list of non-negative integers nums, arrange them such that they form the largest number and return it.\n\nSince the result may be very large, so you need to return a string instead of an integer.\n\n \n\nExample 1:\n\nInput: nums = [10,2]\nOutput: \"210\"\nExample 2:\n\nInput: nums = [3,30,34,5,9]\nOutput: \"9534330\"\n \n\nConstraints:\n\n1 <= nums.length <= 100\n0 <= nums[i] <= 10^9\n        ",
        "tag":["Greedy","Array","String","Sorting"],
        "answer":["\n        class Solution {\n            public:\n                string largestNumber(vector<int> &nums) {\n                    sort(nums.begin(), nums.end(), [](const int &x, const int &y) {\n                        long sx = 10, sy = 10;\n                        while (sx <= x) {\n                            sx *= 10;\n                        }\n                        while (sy <= y) {\n                            sy *= 10;\n                        }\n                        return sy * x + y > sx * y + x;\n                    });\n                    if (nums[0] == 0) {\n                        return \"0\";\n                    }\n                    string ret;\n                    for (int &x : nums) {\n                        ret += to_string(x);\n                    }\n                    return ret;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                string largestNumber(vector<int>& nums) {\n                    vector<string> str;\n                    for(auto i : nums) {\n                        str.push_back(to_string(i));\n                    }\n                    // 使用 lambda 比较 elements.\n                    auto cmp = [](string left, string right) {\n                        return left + right > right + left;\n                    };\n                    sort(str.begin(),str.end(), cmp);\n                    stringstream ss;\n                    for(auto c : str) {\n                        ss << c;\n                    }\n                    string ans = ss.str();\n                    if(ans[0] == '0'){\n                        return \"0\";\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            private:\n                static bool cmp(const int& a, const int& b) {\n                    string sa = to_string(a);\n                    string sb = to_string(b);\n                    return sa + sb > sb + sa;\n                }\n            public:\n                string largestNumber(vector<int>& nums) {\n                    string ans;\n                    sort(nums.begin(), nums.end(), cmp);\n                    for (int& t : nums) {\n                        ans += to_string(t);\n                    }\n                    if (ans[0] == '0') {  // 不能是00000\n                        return \"0\";\n                    }\n                    return ans;\n                }\n            };\n        "]
    },
    {
        "id":103,
        "description":"\n        The DNA sequence is composed of a series of nucleotides abbreviated as 'A', 'C', 'G', and 'T'.\n\nFor example, \"ACGAATTCCG\" is a DNA sequence.\nWhen studying DNA, it is useful to identify repeated sequences within the DNA.\n\nGiven a string s that represents a DNA sequence, return all the 10-letter-long sequences (substrings) that occur more than once in a DNA molecule. You may return the answer in any order.\n\n \n\nExample 1:\n\nInput: s = \"AAAAACCCCCAAAAACCCCCCAAAAAGGGTTT\"\nOutput: [\"AAAAACCCCC\",\"CCCCCAAAAA\"]\nExample 2:\n\nInput: s = \"AAAAAAAAAAAAA\"\nOutput: [\"AAAAAAAAAA\"]\n \n\nConstraints:\n\n1 <= s.length <= 10^5\ns[i] is either 'A', 'C', 'G', or 'T'.\n        ",
        "tag":["Bit Manipulation","Hash Table","String","Sliding Window","Hash Function","Rolling Hash"],
        "answer":["\n        class Solution {\n            const int L = 10;\n        public:\n            vector<string> findRepeatedDnaSequences(string s) {\n                vector<string> ans;\n                unordered_map<string, int> cnt;\n                int n = s.length();\n                for (int i = 0; i <= n - L; ++i) {\n                    string sub = s.substr(i, L);\n                    if (++cnt[sub] == 2) {\n                        ans.push_back(sub);\n                    }\n                }\n                return ans;\n            }\n        };\n        ","\n        class Solution {\n            const int L = 10;\n            unordered_map<char, int> bin = {{'A', 0}, {'C', 1}, {'G', 2}, {'T', 3}};\n        public:\n            vector<string> findRepeatedDnaSequences(string s) {\n                vector<string> ans;\n                int n = s.length();\n                if (n <= L) {\n                    return ans;\n                }\n                int x = 0;\n                for (int i = 0; i < L - 1; ++i) {\n                    x = (x << 2) | bin[s[i]];\n                }\n                unordered_map<int, int> cnt;\n                for (int i = 0; i <= n - L; ++i) {\n                    x = ((x << 2) | bin[s[i + L - 1]]) & ((1 << (L * 2)) - 1);\n                    if (++cnt[x] == 2) {\n                        ans.push_back(s.substr(i, L));\n                    }\n                }\n                return ans;\n            }\n        };\n        ","\n        class Solution {\n            public:\n                vector<string> findRepeatedDnaSequences(string s) {\n                    int n = s.length();\n                    unordered_set<string> see;\n                    unordered_set<string> res;\n                    for(int i= 0;i+10<=n;i++){\n                        string substrs = s.substr(i,10);\n                        if(see.count(substrs)){\n                            res.insert(substrs);\n                        }\n                        else{\n                            see.insert(substrs);\n                        }\n                    }\n                    return vector<string>(res.begin(),res.end());\n                }\n            };\n        "]
    },
    {
        "id":104,
        "description":"\n        You are given an integer array prices where prices[i] is the price of a given stock on the i^th day, and an integer k.\n\nFind the maximum profit you can achieve. You may complete at most k transactions: i.e. you may buy at most k times and sell at most k times.\n\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\n \n\nExample 1:\n\nInput: k = 2, prices = [2,4,1]\nOutput: 2\nExplanation: Buy on day 1 (price = 2) and sell on day 2 (price = 4), profit = 4-2 = 2.\nExample 2:\n\nInput: k = 2, prices = [3,2,6,5,0,3]\nOutput: 7\nExplanation: Buy on day 2 (price = 2) and sell on day 3 (price = 6), profit = 6-2 = 4. Then buy on day 5 (price = 0) and sell on day 6 (price = 3), profit = 3-0 = 3.\n \n\nConstraints:\n\n1 <= k <= 100\n1 <= prices.length <= 1000\n0 <= prices[i] <= 1000\n        ",
        "tag":["Array","Dynamic Programming"],
        "answer":["\n        class Solution {\n            public:\n                int maxProfit(int k, vector<int>& prices) {\n                    if (prices.empty()) {\n                        return 0;\n                    }\n            \n                    int n = prices.size();\n                    k = min(k, n / 2);\n                    vector<vector<int>> buy(n, vector<int>(k + 1));\n                    vector<vector<int>> sell(n, vector<int>(k + 1));\n            \n                    buy[0][0] = -prices[0];\n                    sell[0][0] = 0;\n                    for (int i = 1; i <= k; ++i) {\n                        buy[0][i] = sell[0][i] = INT_MIN / 2;\n                    }\n            \n                    for (int i = 1; i < n; ++i) {\n                        buy[i][0] = max(buy[i - 1][0], sell[i - 1][0] - prices[i]);\n                        for (int j = 1; j <= k; ++j) {\n                            buy[i][j] = max(buy[i - 1][j], sell[i - 1][j] - prices[i]);\n                            sell[i][j] = max(sell[i - 1][j], buy[i - 1][j - 1] + prices[i]);   \n                        }\n                    }\n            \n                    return *max_element(sell[n - 1].begin(), sell[n - 1].end());\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int maxProfit(int k, vector<int>& prices) {\n                    if (prices.empty()) {\n                        return 0;\n                    }\n            \n                    int n = prices.size();\n                    k = min(k, n / 2);\n                    vector<int> buy(k + 1);\n                    vector<int> sell(k + 1);\n            \n                    buy[0] = -prices[0];\n                    sell[0] = 0;\n                    for (int i = 1; i <= k; ++i) {\n                        buy[i] = sell[i] = INT_MIN / 2;\n                    }\n            \n                    for (int i = 1; i < n; ++i) {\n                        buy[0] = max(buy[0], sell[0] - prices[i]);\n                        for (int j = 1; j <= k; ++j) {\n                            buy[j] = max(buy[j], sell[j] - prices[i]);\n                            sell[j] = max(sell[j], buy[j - 1] + prices[i]);   \n                        }\n                    }\n            \n                    return *max_element(sell.begin(), sell.end());\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int maxProfit(int k, vector<int>& prices) {\n                    if (prices.empty()) {\n                        return 0;\n                    }\n            \n                    int n = prices.size();\n                    // 二分查找的上下界\n                    int left = 1, right = *max_element(prices.begin(), prices.end());\n                    // 存储答案，如果值为 -1 表示二分查找失败\n                    int ans = -1;\n                    while (left <= right) {\n                        // 二分得到当前的斜率（手续费）\n                        int c = (left + right) / 2;\n            \n                        // 使用与 714 题相同的动态规划方法求解出最大收益以及对应的交易次数\n                        int buyCount = 0, sellCount = 0;\n                        int buy = -prices[0], sell = 0;\n            \n                        for (int i = 1; i < n; ++i) {\n                            if (sell - prices[i] >= buy) {\n                                buy = sell - prices[i];\n                                buyCount = sellCount;\n                            }\n                            if (buy + prices[i] - c >= sell) {\n                                sell = buy + prices[i] - c;\n                                sellCount = buyCount + 1;\n                            }\n                        }\n            \n                        // 如果交易次数大于等于 k，那么可以更新答案\n                        // 这里即使交易次数严格大于 k，更新答案也没有关系，因为总能二分到等于 k 的\n                        if (sellCount >= k) {\n                            // 别忘了加上 kc\n                            ans = sell + k * c;\n                            left = c + 1;\n                        }\n                        else {\n                            right = c - 1;\n                        }\n                    }\n            \n                    // 如果二分查找失败，说明交易次数的限制不是瓶颈\n                    // 可以看作交易次数无限，直接使用贪心方法得到答案\n                    if (ans == -1) {\n                        ans = 0;\n                        for (int i = 1; i < n; ++i) {\n                            ans += max(prices[i] - prices[i - 1], 0);\n                        }\n                    }\n            \n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int maxProfit(int k, vector<int> &prices) {\n                    int n = prices.size(), memo[n][k + 1][2];\n                    memset(memo, -1, sizeof(memo)); // -1 表示还没有计算过\n                    function<int(int, int, bool)> dfs = [&](int i, int j, bool hold) -> int {\n                        if (j < 0) return INT_MIN / 2; // 防止溢出\n                        if (i < 0) return hold ? INT_MIN / 2 : 0;\n                        int &res = memo[i][j][hold];\n                        if (res != -1) return res;\n                        if (hold) return res = max(dfs(i - 1, j, true), dfs(i - 1, j - 1, false) - prices[i]);\n                        return res = max(dfs(i - 1, j, false), dfs(i - 1, j, true) + prices[i]);\n                    };\n                    return dfs(n - 1, k, false);\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int maxProfit(int k, vector<int> &prices) {\n                    int n = prices.size(), f[n + 1][k + 2][2];\n                    memset(f, -0x3f, sizeof(f));\n                    for (int j = 1; j <= k + 1; ++j)\n                        f[0][j][0] = 0;\n                    for (int i = 0; i < n; ++i)\n                        for (int j = 1; j <= k + 1; ++j) {\n                            f[i + 1][j][0] = max(f[i][j][0], f[i][j][1] + prices[i]);\n                            f[i + 1][j][1] = max(f[i][j][1], f[i][j - 1][0] - prices[i]);\n                        }\n                    return f[n][k + 1][0];\n                }\n            };\n        "]
    },
    {
        "id":105,
        "description":"\n        Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.\n\n \n\nExample 1:\n\nInput: nums = [1,2,3,4,5,6,7], k = 3\nOutput: [5,6,7,1,2,3,4]\nExplanation:\nrotate 1 steps to the right: [7,1,2,3,4,5,6]\nrotate 2 steps to the right: [6,7,1,2,3,4,5]\nrotate 3 steps to the right: [5,6,7,1,2,3,4]\nExample 2:\n\nInput: nums = [-1,-100,3,99], k = 2\nOutput: [3,99,-1,-100]\nExplanation: \nrotate 1 steps to the right: [99,-1,-100,3]\nrotate 2 steps to the right: [3,99,-1,-100]\n \n\nConstraints:\n\n1 <= nums.length <= 10^5\n-2^31 <= nums[i] <= 2^31 - 1\n0 <= k <= 10^5\n        ",
        "tag":["Array","Math","Two Pointers"],
        "answer":["\n        class Solution {\n            public:\n                void rotate(vector<int>& nums, int k) {\n                    int n = nums.size();\n                    vector<int> newArr(n);\n                    for (int i = 0; i < n; ++i) {\n                        newArr[(i + k) % n] = nums[i];\n                    }\n                    nums.assign(newArr.begin(), newArr.end());\n                }\n            };\n        ","\n        class Solution {\n            public:\n                void rotate(vector<int>& nums, int k) {\n                    int n = nums.size();\n                    k = k % n;\n                    int count = gcd(k, n);\n                    for (int start = 0; start < count; ++start) {\n                        int current = start;\n                        int prev = nums[start];\n                        do {\n                            int next = (current + k) % n;\n                            swap(nums[next], prev);\n                            current = next;\n                        } while (start != current);\n                    }\n                }\n            };\n        ","\n        class Solution {\n            public:\n                void reverse(vector<int>& nums, int start, int end) {\n                    while (start < end) {\n                        swap(nums[start], nums[end]);\n                        start += 1;\n                        end -= 1;\n                    }\n                }\n            \n                void rotate(vector<int>& nums, int k) {\n                    k %= nums.size();\n                    reverse(nums, 0, nums.size() - 1);\n                    reverse(nums, 0, k - 1);\n                    reverse(nums, k, nums.size() - 1);\n                }\n            };\n        "]
    },
    {
        "id":106,
        "description":"\n        Reverse bits of a given 32 bits unsigned integer.\n\nNote:\n\nNote that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.\nIn Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 2 above, the input represents the signed integer -3 and the output represents the signed integer -1073741825.\n \n\nExample 1:\n\nInput: n = 00000010100101000001111010011100\nOutput:    964176192 (00111001011110000010100101000000)\nExplanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000.\nExample 2:\n\nInput: n = 11111111111111111111111111111101\nOutput:   3221225471 (10111111111111111111111111111111)\nExplanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111.\n \n\nConstraints:\n\nThe input must be a binary string of length 32\n        ",
        "tag":["Bit Manipulation","Divide and Conquer"],
        "answer":["\n        class Solution {\n            public:\n                uint32_t reverseBits(uint32_t n) {\n                    uint32_t rev = 0;\n                    for (int i = 0; i < 32 && n > 0; ++i) {\n                        rev |= (n & 1) << (31 - i);\n                        n >>= 1;\n                    }\n                    return rev;\n                }\n            };\n        ","\n        class Solution {\n            private:\n                const uint32_t M1 = 0x55555555; // 01010101010101010101010101010101\n                const uint32_t M2 = 0x33333333; // 00110011001100110011001100110011\n                const uint32_t M4 = 0x0f0f0f0f; // 00001111000011110000111100001111\n                const uint32_t M8 = 0x00ff00ff; // 00000000111111110000000011111111\n            \n            public:\n                uint32_t reverseBits(uint32_t n) {\n                    n = n >> 1 & M1 | (n & M1) << 1;\n                    n = n >> 2 & M2 | (n & M2) << 2;\n                    n = n >> 4 & M4 | (n & M4) << 4;\n                    n = n >> 8 & M8 | (n & M8) << 8;\n                    return n >> 16 | n << 16;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                uint32_t reverseBits(uint32_t n) {\n                    uint32_t res = 0;\n                    for (int i = 0; i < 32; ++i) {\n                        res = (res << 1) | (n & 1);\n                        n >>= 1;\n                    }\n                    return res;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                uint32_t reverseBits(uint32_t n) {\n                    n = (n >> 16) | (n << 16);\n                    n = ((n & 0xff00ff00) >> 8) | ((n & 0x00ff00ff) << 8);\n                    n = ((n & 0xf0f0f0f0) >> 4) | ((n & 0x0f0f0f0f) << 4);\n                    n = ((n & 0xcccccccc) >> 2) | ((n & 0x33333333) << 2);\n                    n = ((n & 0xaaaaaaaa) >> 1) | ((n & 0x55555555) << 1);\n                    return n;\n                }\n            };\n        "]
    },
    {
        "id":107,
        "description":"\n        Write a function that takes the binary representation of an unsigned integer and returns the number of '1' bits it has (also known as the Hamming weight).\n\nNote:\n\nNote that in some languages, such as Java, there is no unsigned integer type. In this case, the input will be given as a signed integer type. It should not affect your implementation, as the integer's internal binary representation is the same, whether it is signed or unsigned.\nIn Java, the compiler represents the signed integers using 2's complement notation. Therefore, in Example 3, the input represents the signed integer. -3.\n \n\nExample 1:\n\nInput: n = 00000000000000000000000000001011\nOutput: 3\nExplanation: The input binary string 00000000000000000000000000001011 has a total of three '1' bits.\nExample 2:\n\nInput: n = 00000000000000000000000010000000\nOutput: 1\nExplanation: The input binary string 00000000000000000000000010000000 has a total of one '1' bit.\nExample 3:\n\nInput: n = 11111111111111111111111111111101\nOutput: 31\nExplanation: The input binary string 11111111111111111111111111111101 has a total of thirty one '1' bits.\n \n\nConstraints:\n\nThe input must be a binary string of length 32.\n        ",
        "tag":["Bit Manipulation","Divide and Conquer"],
        "answer":["\n        class Solution {\n            public:\n                int hammingWeight(uint32_t n) {\n                    int ret = 0;\n                    for (int i = 0; i < 32; i++) {\n                        if (n & (1 << i)) {\n                            ret++;\n                        }\n                    }\n                    return ret;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int hammingWeight(uint32_t n) {\n                    int ret = 0;\n                    while (n) {\n                        n &= n - 1;\n                        ret++;\n                    }\n                    return ret;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int hammingWeight(uint32_t n) {\n                    int res = 0;\n                    while(n) {\n                       //获取n对应二进制最右边一位\n                       if (n % 2) {\n                           ++res;\n                       }\n                       //n对应的二进制右移一位\n                       n = n / 2;\n                    }\n                    return res;\n                } \n            };\n        ","\n        class Solution {\n            public:\n                int hammingWeight(uint32_t n) {\n                    int res = 0;\n                    while(n) {\n                        ++res;\n                        //n对应二进制最右边不为零的bit位置为零\n                        n = n&(n-1);\n                    }\n                    return res;\n                } \n            };\n        "]
    },
    {
        "id":108,
        "description":"\n        You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.\n\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\n\n \n\nExample 1:\n\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\nExample 2:\n\nInput: nums = [2,7,9,3,1]\nOutput: 12\nExplanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).\nTotal amount you can rob = 2 + 9 + 1 = 12.\n \n\nConstraints:\n\n1 <= nums.length <= 100\n0 <= nums[i] <= 400\n        ",
        "tag":["Array","Dynamic Programming"],
        "answer":["\n        class Solution {\n            public:\n                int rob(vector<int>& nums) {\n                    if (nums.empty()) {\n                        return 0;\n                    }\n                    int size = nums.size();\n                    if (size == 1) {\n                        return nums[0];\n                    }\n                    vector<int> dp = vector<int>(size, 0);\n                    dp[0] = nums[0];\n                    dp[1] = max(nums[0], nums[1]);\n                    for (int i = 2; i < size; i++) {\n                        dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);\n                    }\n                    return dp[size - 1];\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int rob(vector<int>& nums) {\n                    if (nums.empty()) {\n                        return 0;\n                    }\n                    int size = nums.size();\n                    if (size == 1) {\n                        return nums[0];\n                    }\n                    int first = nums[0], second = max(nums[0], nums[1]);\n                    for (int i = 2; i < size; i++) {\n                        int temp = second;\n                        second = max(first + nums[i], second);\n                        first = temp;\n                    }\n                    return second;\n                }\n            };\n        ","\n        int rob(vector<int>& nums) {\n            if (nums.size() == 0) {\n                return 0;\n            }\n            // 子问题：\n            // f(k) = 偷 [0..k) 房间中的最大金额\n        \n            // f(0) = 0\n            // f(1) = nums[0]\n            // f(k) = max{ rob(k-1), nums[k-1] + rob(k-2) }\n        \n            int N = nums.size();\n            vector<int> dp(N+1, 0);\n            dp[0] = 0;\n            dp[1] = nums[0];\n            for (int k = 2; k <= N; k++) {\n                dp[k] = max(dp[k-1], nums[k-1] + dp[k-2]);\n            }\n            return dp[N];\n        }\n        "]
    },
    {
        "id":109,
        "description":"\n        Given an m x n 2D binary grid grid which represents a map of '1's (land) and '0's (water), return the number of islands.\n\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\n\n \n\nExample 1:\n\nInput: grid = [\n  [\"1\",\"1\",\"1\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"1\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"0\",\"0\"]\n]\nOutput: 1\nExample 2:\n\nInput: grid = [\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"1\",\"1\",\"0\",\"0\",\"0\"],\n  [\"0\",\"0\",\"1\",\"0\",\"0\"],\n  [\"0\",\"0\",\"0\",\"1\",\"1\"]\n]\nOutput: 3\n \n\nConstraints:\n\nm == grid.length\nn == grid[i].length\n1 <= m, n <= 300\ngrid[i][j] is '0' or '1'.\n        ",
        "tag":["Depth-First Search","Breadth-First Search","Union Find","Array","Matrix"],
        "answer":["\n        class Solution {\n            private:\n                void dfs(vector<vector<char>>& grid, int r, int c) {\n                    int nr = grid.size();\n                    int nc = grid[0].size();\n            \n                    grid[r][c] = '0';\n                    if (r - 1 >= 0 && grid[r-1][c] == '1') dfs(grid, r - 1, c);\n                    if (r + 1 < nr && grid[r+1][c] == '1') dfs(grid, r + 1, c);\n                    if (c - 1 >= 0 && grid[r][c-1] == '1') dfs(grid, r, c - 1);\n                    if (c + 1 < nc && grid[r][c+1] == '1') dfs(grid, r, c + 1);\n                }\n            \n            public:\n                int numIslands(vector<vector<char>>& grid) {\n                    int nr = grid.size();\n                    if (!nr) return 0;\n                    int nc = grid[0].size();\n            \n                    int num_islands = 0;\n                    for (int r = 0; r < nr; ++r) {\n                        for (int c = 0; c < nc; ++c) {\n                            if (grid[r][c] == '1') {\n                                ++num_islands;\n                                dfs(grid, r, c);\n                            }\n                        }\n                    }\n            \n                    return num_islands;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int numIslands(vector<vector<char>>& grid) {\n                    int nr = grid.size();\n                    if (!nr) return 0;\n                    int nc = grid[0].size();\n            \n                    int num_islands = 0;\n                    for (int r = 0; r < nr; ++r) {\n                        for (int c = 0; c < nc; ++c) {\n                            if (grid[r][c] == '1') {\n                                ++num_islands;\n                                grid[r][c] = '0';\n                                queue<pair<int, int>> neighbors;\n                                neighbors.push({r, c});\n                                while (!neighbors.empty()) {\n                                    auto rc = neighbors.front();\n                                    neighbors.pop();\n                                    int row = rc.first, col = rc.second;\n                                    if (row - 1 >= 0 && grid[row-1][col] == '1') {\n                                        neighbors.push({row-1, col});\n                                        grid[row-1][col] = '0';\n                                    }\n                                    if (row + 1 < nr && grid[row+1][col] == '1') {\n                                        neighbors.push({row+1, col});\n                                        grid[row+1][col] = '0';\n                                    }\n                                    if (col - 1 >= 0 && grid[row][col-1] == '1') {\n                                        neighbors.push({row, col-1});\n                                        grid[row][col-1] = '0';\n                                    }\n                                    if (col + 1 < nc && grid[row][col+1] == '1') {\n                                        neighbors.push({row, col+1});\n                                        grid[row][col+1] = '0';\n                                    }\n                                }\n                            }\n                        }\n                    }\n            \n                    return num_islands;\n                }\n            };\n        ","\n        class UnionFind {\n            public:\n                UnionFind(vector<vector<char>>& grid) {\n                    count = 0;\n                    int m = grid.size();\n                    int n = grid[0].size();\n                    for (int i = 0; i < m; ++i) {\n                        for (int j = 0; j < n; ++j) {\n                            if (grid[i][j] == '1') {\n                                parent.push_back(i * n + j);\n                                ++count;\n                            }\n                            else {\n                                parent.push_back(-1);\n                            }\n                            rank.push_back(0);\n                        }\n                    }\n                }\n            \n                int find(int i) {\n                    if (parent[i] != i) {\n                        parent[i] = find(parent[i]);\n                    }\n                    return parent[i];\n                }\n            \n                void unite(int x, int y) {\n                    int rootx = find(x);\n                    int rooty = find(y);\n                    if (rootx != rooty) {\n                        if (rank[rootx] < rank[rooty]) {\n                            swap(rootx, rooty);\n                        }\n                        parent[rooty] = rootx;\n                        if (rank[rootx] == rank[rooty]) rank[rootx] += 1;\n                        --count;\n                    }\n                }\n            \n                int getCount() const {\n                    return count;\n                }\n            \n            private:\n                vector<int> parent;\n                vector<int> rank;\n                int count;\n            };\n            \n            class Solution {\n            public:\n                int numIslands(vector<vector<char>>& grid) {\n                    int nr = grid.size();\n                    if (!nr) return 0;\n                    int nc = grid[0].size();\n            \n                    UnionFind uf(grid);\n                    int num_islands = 0;\n                    for (int r = 0; r < nr; ++r) {\n                        for (int c = 0; c < nc; ++c) {\n                            if (grid[r][c] == '1') {\n                                grid[r][c] = '0';\n                                if (r - 1 >= 0 && grid[r-1][c] == '1') uf.unite(r * nc + c, (r-1) * nc + c);\n                                if (r + 1 < nr && grid[r+1][c] == '1') uf.unite(r * nc + c, (r+1) * nc + c);\n                                if (c - 1 >= 0 && grid[r][c-1] == '1') uf.unite(r * nc + c, r * nc + c - 1);\n                                if (c + 1 < nc && grid[r][c+1] == '1') uf.unite(r * nc + c, r * nc + c + 1);\n                            }\n                        }\n                    }\n            \n                    return uf.getCount();\n                }\n            };\n        ","\nclass Solution {\nprivate:\n    int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\n    void dfs(vector<vector<char>>& grid, vector<vector<bool>>& visited, int x, int y) {\n        for (int i = 0; i < 4; i++) {\n            int nextx = x + dir[i][0];\n            int nexty = y + dir[i][1];\n            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过\n            if (!visited[nextx][nexty] && grid[nextx][nexty] == '1') { // 没有访问过的 同时 是陆地的\n\n                visited[nextx][nexty] = true; \n                dfs(grid, visited, nextx, nexty);\n            } \n        }\n    }\npublic:\n    int numIslands(vector<vector<char>>& grid) {\n        int n = grid.size(), m = grid[0].size();\n        vector<vector<bool>> visited = vector<vector<bool>>(n, vector<bool>(m, false)); \n\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (!visited[i][j] && grid[i][j] == '1') {  \n                    visited[i][j] = true;\n                    result++; // 遇到没访问过的陆地，+1\n                    dfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true\n                }\n            }\n        }\n        return result;\n    }\n};\n        ","\n        class Solution {\n            private:\n            int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 四个方向\n            void bfs(vector<vector<char>>& grid, vector<vector<bool>>& visited, int x, int y) {\n                queue<pair<int, int>> que;\n                que.push({x, y});\n                visited[x][y] = true; // 只要加入队列，立刻标记\n                while(!que.empty()) {\n                    pair<int ,int> cur = que.front(); que.pop();\n                    int curx = cur.first;\n                    int cury = cur.second;\n                    for (int i = 0; i < 4; i++) {\n                        int nextx = curx + dir[i][0];\n                        int nexty = cury + dir[i][1];\n                        if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 越界了，直接跳过\n                        if (!visited[nextx][nexty] && grid[nextx][nexty] == '1') {\n                            que.push({nextx, nexty});\n                            visited[nextx][nexty] = true; // 只要加入队列立刻标记\n                        }\n                    }\n                }\n            }\n            public:\n                int numIslands(vector<vector<char>>& grid) {\n                    int n = grid.size(), m = grid[0].size();\n                    vector<vector<bool>> visited = vector<vector<bool>>(n, vector<bool>(m, false));\n            \n                    int result = 0;\n                    for (int i = 0; i < n; i++) {\n                        for (int j = 0; j < m; j++) {\n                            if (!visited[i][j] && grid[i][j] == '1') {\n                                result++; // 遇到没访问过的陆地，+1\n                                bfs(grid, visited, i, j); // 将与其链接的陆地都标记上 true\n                            }\n                        }\n                    }\n                    return result;\n                }\n            };\n        "]
    },
    {
        "id":110,
        "description":"\n        Given two integers left and right that represent the range [left, right], return the bitwise AND of all numbers in this range, inclusive.\n\n \n\nExample 1:\n\nInput: left = 5, right = 7\nOutput: 4\nExample 2:\n\nInput: left = 0, right = 0\nOutput: 0\nExample 3:\n\nInput: left = 1, right = 2147483647\nOutput: 0\n \n\nConstraints:\n\n0 <= left <= right <= 2^31 - 1\n        ",
        "tag":["Bit Manipulation"],
        "answer":["\n        class Solution {\n            public:\n                int rangeBitwiseAnd(int m, int n) {\n                    int shift = 0;\n                    // 找到公共前缀\n                    while (m < n) {\n                        m >>= 1;\n                        n >>= 1;\n                        ++shift;\n                    }\n                    return m << shift;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int rangeBitwiseAnd(int m, int n) {\n                    while (m < n) {\n                        // 抹去最右边的 1\n                        n = n & (n - 1);\n                    }\n                    return n;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int rangeBitwiseAnd(int m, int n) {\n                    int mask = 1 << 30; // 最高位开始\n                    int anw = 0;\n                    while(mask > 0 && (m&mask) == (n&mask)) { //寻找相同前缀\n                        anw |= m&mask;\n                        mask >>= 1;\n                    }\n                    return anw;\n                }\n            };\n        "]
    },
    {
        "id":111,
        "description":"\n        Write an algorithm to determine if a number n is happy.\n\nA happy number is a number defined by the following process:\n\nStarting with any positive integer, replace the number by the sum of the squares of its digits.\nRepeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.\nThose numbers for which this process ends in 1 are happy.\nReturn true if n is a happy number, and false if not.\n\n \n\nExample 1:\n\nInput: n = 19\nOutput: true\nExplanation:\n1^2 + 9^2 = 82\n8^2 + 2^2 = 68\n6^2 + 8^2 = 100\n1^2 + 0^2 + 0^2 = 1\nExample 2:\n\nInput: n = 2\nOutput: false\n \n\nConstraints:\n\n1 <= n <= 2^31 - 1\n        ",
        "tag":["Hash Table","Math","Two Pointers"],
        "answer":["\n        class Solution {\n            public:\n                int bitSquareSum(int n) {\n                    int sum = 0;\n                    while(n > 0)\n                    {\n                        int bit = n % 10;\n                        sum += bit * bit;\n                        n = n / 10;\n                    }\n                    return sum;\n                }\n                \n                bool isHappy(int n) {\n                    int slow = n, fast = n;\n                    do{\n                        slow = bitSquareSum(slow);\n                        fast = bitSquareSum(fast);\n                        fast = bitSquareSum(fast);\n                    }while(slow != fast);\n                    \n                    return slow == 1;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool isHappy(int n) {\n                    int sum=0;\n                    while(1){\n                        // 按位置进行平方求和\n                        while(n!=0){\n                            sum+=(n%10)*(n%10);\n                            n=n/10;\n                        }\n                        // 和为1，是快乐数\n                        if(sum==1) return true;\n                        // 若和是个数且和不等于7，则一定不是快乐数\n                        if(sum/10==0&&sum!=7) return false;\n                        // 重置\n                        n=sum;sum=0;\n                    }\n                }\n            };\n        ","\n        \nclass Solution {\n    public:\n        //202.快乐数\n        bool isHappy(int n) {\n            unordered_set<int> set;\n            int res = n;\n            while (true) {\n                res = square(res);\n                if (res == 1) {\n                    return true;\n                }\n                if (set.find(res)!=set.end()) {//找到返回迭代器，失败返回end\n                    return false;\n                }\n                set.insert(res);\n                \n            }    \n        }\n    \n        int square(int n) {\n            int sum = 0, temp = 1;\n            while (n != 0) {\n                temp = n % 10;\n                sum += temp * temp;\n                n /= 10;\n            }\n            return sum;\n        }\n    };\n        "]
    },
    {
        "id":112,
        "description":"\n        Given an integer n, return the number of prime numbers that are strictly less than n.\n\n \n\nExample 1:\n\nInput: n = 10\nOutput: 4\nExplanation: There are 4 prime numbers less than 10, they are 2, 3, 5, 7.\nExample 2:\n\nInput: n = 0\nOutput: 0\nExample 3:\n\nInput: n = 1\nOutput: 0\n \n\nConstraints:\n\n0 <= n <= 5 * 10^6\n        ",
        "tag":["Array","Math","Enumeration","Number Theory"],
        "answer":["\n        class Solution {\n            public:\n                bool isPrime(int x) {\n                    for (int i = 2; i * i <= x; ++i) {\n                        if (x % i == 0) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n            \n                int countPrimes(int n) {\n                    int ans = 0;\n                    for (int i = 2; i < n; ++i) {\n                        ans += isPrime(i);\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int countPrimes(int n) {\n                    vector<int> isPrime(n, 1);\n                    int ans = 0;\n                    for (int i = 2; i < n; ++i) {\n                        if (isPrime[i]) {\n                            ans += 1;\n                            if ((long long)i * i < n) {\n                                for (int j = i * i; j < n; j += i) {\n                                    isPrime[j] = 0;\n                                }\n                            }\n                        }\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int countPrimes(int n) {\n                    vector<int> primes;\n                    vector<int> isPrime(n, 1);\n                    for (int i = 2; i < n; ++i) {\n                        if (isPrime[i]) {\n                            primes.push_back(i);\n                        }\n                        for (int j = 0; j < primes.size() && i * primes[j] < n; ++j) {\n                            isPrime[i * primes[j]] = 0;\n                            if (i % primes[j] == 0) {\n                                break;\n                            }\n                        }\n                    }\n                    return primes.size();\n                }\n            };\n        "]
    },
    {
        "id":113,
        "description":"\n        Given two strings s and t, determine if they are isomorphic.\n\nTwo strings s and t are isomorphic if the characters in s can be replaced to get t.\n\nAll occurrences of a character must be replaced with another character while preserving the order of characters. No two characters may map to the same character, but a character may map to itself.\n\n \n\nExample 1:\n\nInput: s = \"egg\", t = \"add\"\nOutput: true\nExample 2:\n\nInput: s = \"foo\", t = \"bar\"\nOutput: false\nExample 3:\n\nInput: s = \"paper\", t = \"title\"\nOutput: true\n \n\nConstraints:\n\n1 <= s.length <= 5 * 10^4\nt.length == s.length\ns and t consist of any valid ascii character.\n        ",
        "tag":["Hash Table","String"],
        "answer":["\n        class Solution {\n            public:\n                bool isIsomorphic(string s, string t) {\n                    unordered_map<char, char> s2t;\n                    unordered_map<char, char> t2s;\n                    int len = s.length();\n                    for (int i = 0; i < len; ++i) {\n                        char x = s[i], y = t[i];\n                        if ((s2t.count(x) && s2t[x] != y) || (t2s.count(y) && t2s[y] != x)) {\n                            return false;\n                        }\n                        s2t[x] = y;\n                        t2s[y] = x;\n                    }\n                    return true;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool isIsomorphic(string s, string t) {\n                    unordered_map<char, char> s2t;      // 存储s字符串中字符到t字符串字符的映射 \n                    unordered_map<char, char> t2s;      // 存储t字符串中字符到s字符串字符的映射\n                    char sc;\n                    char tc;\n                    for(int i = 0; i < s.size(); i++){\n                        sc = s[i];  // 获取s字符串当前字符\n                        tc = t[i];  // 获取s字符串当前字符\n                        if((s2t.count(sc) && s2t[sc] != tc) || (t2s.count(tc) && t2s[tc] != sc)){\n                            // 如果当前s字符和t字符不匹配，直接返回\n                            return false;\n                        }\n                        // 更新s字符和t字符的映射关系，如果已经存储的映射不改变结果\n                        s2t[sc] = tc;\n                        t2s[tc] = sc;\n                    }\n                    return true;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool isIsomorphic(string s, string t) {\n                    unordered_map<char, char> t2s, s2t;\n                    for (int i = 0; i < s.size(); i++) {\n                        char a = s[i], b = t[i];\n                        // 对于已有映射 a -> s2t[a]，若和当前字符映射 a -> b 不匹配，\n                        // 说明有一对多的映射关系，则返回 false ；\n                        // 对于映射 b -> a 也同理\n                        if (s2t.find(a) != s2t.end() && s2t[a] != b || \n                            t2s.find(b) != t2s.end() && t2s[b] != a)\n                            return false;\n                        s2t[a] = b;\n                        t2s[b] = a;\n                    }\n                    return true;\n                }\n            };\n        "]
    },
    {
        "id":114,
        "description":"\n        There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\n\nFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\nReturn true if you can finish all courses. Otherwise, return false.\n\n \n\nExample 1:\n\nInput: numCourses = 2, prerequisites = [[1,0]]\nOutput: true\nExplanation: There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0. So it is possible.\nExample 2:\n\nInput: numCourses = 2, prerequisites = [[1,0],[0,1]]\nOutput: false\nExplanation: There are a total of 2 courses to take. \nTo take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\n \n\nConstraints:\n\n1 <= numCourses <= 2000\n0 <= prerequisites.length <= 5000\nprerequisites[i].length == 2\n0 <= ai, bi < numCourses\nAll the pairs prerequisites[i] are unique.\n        ",
        "tag":["Depth-First Search","Breadth-First Search","Graph","Topological Sort"],
        "answer":["\n        class Solution {\n            private:\n                vector<vector<int>> edges;\n                vector<int> visited;\n                bool valid = true;\n            \n            public:\n                void dfs(int u) {\n                    visited[u] = 1;\n                    for (int v: edges[u]) {\n                        if (visited[v] == 0) {\n                            dfs(v);\n                            if (!valid) {\n                                return;\n                            }\n                        }\n                        else if (visited[v] == 1) {\n                            valid = false;\n                            return;\n                        }\n                    }\n                    visited[u] = 2;\n                }\n            \n                bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n                    edges.resize(numCourses);\n                    visited.resize(numCourses);\n                    for (const auto& info: prerequisites) {\n                        edges[info[1]].push_back(info[0]);\n                    }\n                    for (int i = 0; i < numCourses && valid; ++i) {\n                        if (!visited[i]) {\n                            dfs(i);\n                        }\n                    }\n                    return valid;\n                }\n            };\n        ","\n        class Solution {\n            private:\n                vector<vector<int>> edges;\n                vector<int> indeg;\n            \n            public:\n                bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n                    edges.resize(numCourses);\n                    indeg.resize(numCourses);\n                    for (const auto& info: prerequisites) {\n                        edges[info[1]].push_back(info[0]);\n                        ++indeg[info[0]];\n                    }\n            \n                    queue<int> q;\n                    for (int i = 0; i < numCourses; ++i) {\n                        if (indeg[i] == 0) {\n                            q.push(i);\n                        }\n                    }\n            \n                    int visited = 0;\n                    while (!q.empty()) {\n                        ++visited;\n                        int u = q.front();\n                        q.pop();\n                        for (int v: edges[u]) {\n                            --indeg[v];\n                            if (indeg[v] == 0) {\n                                q.push(v);\n                            }\n                        }\n                    }\n            \n                    return visited == numCourses;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n                    vector<vector<int>> curriculum(numCourses);\n                    for(auto& requery : prerequisites){\n                        curriculum[requery[0]].emplace_back(requery[1]);\n                    }\n                    //多次遍历\n                    vector<vector<int>> tmp;\n                    do{\n                        tmp = curriculum;   //先保存原来的\n                        for(int i = 0; i < curriculum.size(); i++){     //尝试更新\n                            if(!curriculum[i].empty()){\n                                //遇到前置为非空的我们尝试重新构造其所需表\n                                vector<int> newReq;\n                                for(auto& pre : curriculum[i]){\n                                    if(!curriculum[pre].empty()) newReq.push_back(pre);\n                                }\n                                swap(curriculum[i], newReq);    //然后更新新的需求表\n                            }\n                        }\n                    }while(tmp != curriculum);  //如果发现此轮没有更新则跳出\n                    //循环检测所有课程是否都可以修\n                    for(auto& curr : curriculum){\n                        if(!curr.empty()) return false;\n                    }\n            \n                    return true;\n                }\n            };\n        ","\n        class Solution {\n            struct ArcNode{//边结点\n                int adjvex;\n                ArcNode* nextarc;\n            };\n            typedef struct VNode{//顶点\n                int adjvex;\n                ArcNode* firstarc;\n                int indegree;\n            }VNode,ArcList[100000];\n            struct Graph{//图\n                int vexnum,arcnum;\n                ArcList vextices;\n            };\n            void CreatG(Graph &G,vector<vector<int>>&prerequisites){\n                for(int i=0;i<G.vexnum;i++){\n                    G.vextices[i].adjvex=i;\n                    G.vextices[i].firstarc=NULL;\n                    G.vextices[i].indegree=0;//初始化\n                }\n                for(int i=0;i<G.arcnum;i++){\n                    ArcNode*p=new ArcNode;\n                    p->adjvex=prerequisites[i][0];\n                    G.vextices[prerequisites[i][0]].indegree++;\n                    p->nextarc=G.vextices[prerequisites[i][1]].firstarc;\n                    G.vextices[prerequisites[i][1]].firstarc=p;//头插法\n                }\n                return;\n            }\n            void PrintG(Graph &G){\n                ArcNode*p=new ArcNode;\n                for(int i=0;i<G.vexnum;i++){\n                    cout<<i<<\": \"<<\"indegree: \"<<G.vextices[i].indegree<<\" \";\n                    for(p=G.vextices[i].firstarc;p!=NULL;p=p->nextarc){\n                        cout<<i<<\"->\"<<p->adjvex<<\" \";\n                    }\n                    cout<<\"\n\";\n                }\n            }\n            stack<int>S1;stack<int>S;\n            bool used[100000];\n            bool topsort(Graph &G){\n                //拓扑排序\n                fill(used,used+G.vexnum,false);\n                for(int i=0;i<G.vexnum;i++){\n                    if(G.vextices[i].indegree==0&&!used[i]){\n                        //找到源点\n                        S.push(i);\n                       // cout<<i<<\"\n\";\n                        used[i]=true;\n                        while(!S.empty()){\n                            S1.push(S.top());S.pop();\n                            //遍历该源点所有邻接边\n                            ArcNode* p=new ArcNode;\n                            for(p=G.vextices[S1.top()].firstarc;p!=NULL;p=p->nextarc){\n                                //入度减一\n                                G.vextices[p->adjvex].indegree--;\n                                if(G.vextices[p->adjvex].indegree==0){\n                                    S.push(p->adjvex);\n                                    used[p->adjvex]=true;\n                                }\n                            }\n                        }\n                    }\n                }\n                if(S1.size()==G.vexnum){\n                    return true;\n                }else{\n                    return false;\n                }\n            }\n        public:\n            bool canFinish(int numCourses, vector<vector<int>>& prerequisites) {\n                Graph G;\n                G.vexnum=numCourses;\n                G.arcnum=prerequisites.size();\n                CreatG(G,prerequisites);//创建邻接表\n               // PrintG(G);//检验\n                if(topsort(G)){\n                    return true;\n                }else{\n                    return false;\n                }\n            }\n        };\n        "]
    },
    {
        "id":115,
        "description":"\n        A trie (pronounced as \"try\") or prefix tree is a tree data structure used to efficiently store and retrieve keys in a dataset of strings. There are various applications of this data structure, such as autocomplete and spellchecker.\n\nImplement the Trie class:\n\nTrie() Initializes the trie object.\nvoid insert(String word) Inserts the string word into the trie.\nboolean search(String word) Returns true if the string word is in the trie (i.e., was inserted before), and false otherwise.\nboolean startsWith(String prefix) Returns true if there is a previously inserted string word that has the prefix prefix, and false otherwise.\n \n\nExample 1:\n\nInput\n[\"Trie\", \"insert\", \"search\", \"search\", \"startsWith\", \"insert\", \"search\"]\n[[], [\"apple\"], [\"apple\"], [\"app\"], [\"app\"], [\"app\"], [\"app\"]]\nOutput\n[null, null, true, false, true, null, true]\n\nExplanation\nTrie trie = new Trie();\ntrie.insert(\"apple\");\ntrie.search(\"apple\");   // return True\ntrie.search(\"app\");     // return False\ntrie.startsWith(\"app\"); // return True\ntrie.insert(\"app\");\ntrie.search(\"app\");     // return True\n \n\nConstraints:\n\n1 <= word.length, prefix.length <= 2000\nword and prefix consist only of lowercase English letters.\nAt most 3 * 10^4 calls in total will be made to insert, search, and startsWith.\n        ",
        "tag":["Design","Trie","Hash Table","String"],
        "answer":["\n        class Trie {\n            private:\n                vector<Trie*> children;\n                bool isEnd;\n            \n                Trie* searchPrefix(string prefix) {\n                    Trie* node = this;\n                    for (char ch : prefix) {\n                        ch -= 'a';\n                        if (node->children[ch] == nullptr) {\n                            return nullptr;\n                        }\n                        node = node->children[ch];\n                    }\n                    return node;\n                }\n            \n            public:\n                Trie() : children(26), isEnd(false) {}\n            \n                void insert(string word) {\n                    Trie* node = this;\n                    for (char ch : word) {\n                        ch -= 'a';\n                        if (node->children[ch] == nullptr) {\n                            node->children[ch] = new Trie();\n                        }\n                        node = node->children[ch];\n                    }\n                    node->isEnd = true;\n                }\n            \n                bool search(string word) {\n                    Trin e* node = this->searchPrefix(word);\n                    returnode != nullptr && node->isEnd;\n                }\n            \n                bool startsWith(string prefix) {\n                    return this->searchPrefix(prefix) != nullptr;\n                }\n            };\n        ","\n        class Trie {\n            private:\n                bool isEnd;\n                Trie* next[26];\n            public:\n                Trie() {\n                    isEnd = false;\n                    memset(next, 0, sizeof(next));\n                }\n                \n                void insert(string word) {\n                    Trie* node = this;\n                    for (char c : word) {\n                        if (node->next[c-'a'] == NULL) {\n                            node->next[c-'a'] = new Trie();\n                        }\n                        node = node->next[c-'a'];\n                    }\n                    node->isEnd = true;\n                }\n                \n                bool search(string word) {\n                    Trie* node = this;\n                    for (char c : word) {\n                        node = node->next[c - 'a'];\n                        if (node == NULL) {\n                            return false;\n                        }\n                    }\n                    return node->isEnd;\n                }\n                \n                bool startsWith(string prefix) {\n                    Trie* node = this;\n                    for (char c : prefix) {\n                        node = node->next[c-'a'];\n                        if (node == NULL) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n            };\n        ","\n        class TrieNode {\n            public:\n                vector<TrieNode*> children;\n                bool isWord;\n                TrieNode() : isWord(false), children(26, nullptr) {\n                }\n                ~TrieNode() {\n                    for (auto& c : children)\n                        delete c;\n                }\n            };\n            \n            class Trie {\n            public:\n                /** Initialize your data structure here. */\n                Trie() {\n                    root = new TrieNode();\n                }\n                \n                /** Inserts a word into the trie. */\n                void insert(string word) {\n                    TrieNode* p = root;\n                    for (char a : word) {\n                        int i = a - 'a';\n                        if (!p->children[i])\n                            p->children[i] = new TrieNode();\n                        p = p->children[i];\n                    }\n                    p->isWord = true;\n                }\n                \n                /** Returns if the word is in the trie. */\n                bool search(string word) {\n                    TrieNode* p = root;\n                    for (char a : word) {\n                        int i = a - 'a';\n                        if (!p->children[i])\n                            return false;\n                        p = p->children[i];\n                    }\n                    return p->isWord;\n                }\n                \n                /** Returns if there is any word in the trie that starts with the given prefix. */\n                bool startsWith(string prefix) {\n                    TrieNode* p = root;\n                    for (char a : prefix) {\n                        int i = a - 'a';\n                        if (!p->children[i])\n                            return false;\n                        p = p->children[i];\n                    }\n                    return true;\n                }\n            private:\n                TrieNode* root;\n            };\n        "]
    },
    {
        "id":116,
        "description":"\n        Given an array of positive integers nums and a positive integer target, return the minimal length of a \nsubarray\n whose sum is greater than or equal to target. If there is no such subarray, return 0 instead.\n\n \n\nExample 1:\n\nInput: target = 7, nums = [2,3,1,2,4,3]\nOutput: 2\nExplanation: The subarray [4,3] has the minimal length under the problem constraint.\nExample 2:\n\nInput: target = 4, nums = [1,4,4]\nOutput: 1\nExample 3:\n\nInput: target = 11, nums = [1,1,1,1,1,1,1,1]\nOutput: 0\n \n\nConstraints:\n\n1 <= target <= 10^9\n1 <= nums.length <= 10^5\n1 <= nums[i] <= 10^4\n        ",
        "tag":["Array","Binary Search","Prefix Sum","Sliding Window"],
        "answer":["\n        class Solution {\n            public:\n                int minSubArrayLen(int s, vector<int>& nums) {\n                    int n = nums.size();\n                    if (n == 0) {\n                        return 0;\n                    }\n                    int ans = INT_MAX;\n                    for (int i = 0; i < n; i++) {\n                        int sum = 0;\n                        for (int j = i; j < n; j++) {\n                            sum += nums[j];\n                            if (sum >= s) {\n                                ans = min(ans, j - i + 1);\n                                break;\n                            }\n                        }\n                    }\n                    return ans == INT_MAX ? 0 : ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int minSubArrayLen(int s, vector<int>& nums) {\n                    int n = nums.size();\n                    if (n == 0) {\n                        return 0;\n                    }\n                    int ans = INT_MAX;\n                    vector<int> sums(n + 1, 0); \n                    // 为了方便计算，令 size = n + 1 \n                    // sums[0] = 0 意味着前 0 个元素的前缀和为 0\n                    // sums[1] = A[0] 前 1 个元素的前缀和为 A[0]\n                    // 以此类推\n                    for (int i = 1; i <= n; i++) {\n                        sums[i] = sums[i - 1] + nums[i - 1];\n                    }\n                    for (int i = 1; i <= n; i++) {\n                        int target = s + sums[i - 1];\n                        auto bound = lower_bound(sums.begin(), sums.end(), target);\n                        if (bound != sums.end()) {\n                            ans = min(ans, static_cast<int>((bound - sums.begin()) - (i - 1)));\n                        }\n                    }\n                    return ans == INT_MAX ? 0 : ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int minSubArrayLen(int s, vector<int>& nums) {\n                    int n = nums.size();\n                    if (n == 0) {\n                        return 0;\n                    }\n                    int ans = INT_MAX;\n                    int start = 0, end = 0;\n                    int sum = 0;\n                    while (end < n) {\n                        sum += nums[end];\n                        while (sum >= s) {\n                            ans = min(ans, end - start + 1);\n                            sum -= nums[start];\n                            start++;\n                        }\n                        end++;\n                    }\n                    return ans == INT_MAX ? 0 : ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int minSubArrayLen(int target, vector<int>& nums) {\n                    int n=nums.size();\n                    if(n==0) return 0;\n                    int start=0,end=0,len=INT_MAX;\n                    while(end<n && start<=end){\n                        int sum=0;\n                       for(int i=start;i<=end;i++){\n                           sum+=nums[i];\n                       }\n                       if(sum<target){\n                           end++;\n                       }\n                        else{\n                           len=len<(end-start+1)?len:end-start+1;\n                           start++;\n                       }\n                    }\n                    if(len==INT_MAX) len=0;\n                    return len;\n                }\n            };\n        "]
    },
    {
        "id":117,
        "description":"\n        There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\n\nFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1.\nReturn the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\n\n \n\nExample 1:\n\nInput: numCourses = 2, prerequisites = [[1,0]]\nOutput: [0,1]\nExplanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1].\nExample 2:\n\nInput: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]\nOutput: [0,2,1,3]\nExplanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0.\nSo one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3].\nExample 3:\n\nInput: numCourses = 1, prerequisites = []\nOutput: [0]\n \n\nConstraints:\n\n1 <= numCourses <= 2000\n0 <= prerequisites.length <= numCourses * (numCourses - 1)\nprerequisites[i].length == 2\n0 <= ai, bi < numCourses\nai != bi\nAll the pairs [ai, bi] are distinct.\n        ",
        "tag":["Depth-First Search","Breadth-First Search","Graph","Topological Sort"],
        "answer":["\n        class Solution {\n            private:\n                // 存储有向图\n                vector<vector<int>> edges;\n                // 标记每个节点的状态：0=未搜索，1=搜索中，2=已完成\n                vector<int> visited;\n                // 用数组来模拟栈，下标 0 为栈底，n-1 为栈顶\n                vector<int> result;\n                // 判断有向图中是否有环\n                bool valid = true;\n            \n            public:\n                void dfs(int u) {\n                    // 将节点标记为「搜索中」\n                    visited[u] = 1;\n                    // 搜索其相邻节点\n                    // 只要发现有环，立刻停止搜索\n                    for (int v: edges[u]) {\n                        // 如果「未搜索」那么搜索相邻节点\n                        if (visited[v] == 0) {\n                            dfs(v);\n                            if (!valid) {\n                                return;\n                            }\n                        }\n                        // 如果「搜索中」说明找到了环\n                        else if (visited[v] == 1) {\n                            valid = false;\n                            return;\n                        }\n                    }\n                    // 将节点标记为「已完成」\n                    visited[u] = 2;\n                    // 将节点入栈\n                    result.push_back(u);\n                }\n            \n                vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\n                    edges.resize(numCourses);\n                    visited.resize(numCourses);\n                    for (const auto& info: prerequisites) {\n                        edges[info[1]].push_back(info[0]);\n                    }\n                    // 每次挑选一个「未搜索」的节点，开始进行深度优先搜索\n                    for (int i = 0; i < numCourses && valid; ++i) {\n                        if (!visited[i]) {\n                            dfs(i);\n                        }\n                    }\n                    if (!valid) {\n                        return {};\n                    }\n                    // 如果没有环，那么就有拓扑排序\n                    // 注意下标 0 为栈底，因此需要将数组反序输出\n                    reverse(result.begin(), result.end());\n                    return result;\n                }\n            };\n        ","\n        class Solution {\n            private:\n                // 存储有向图\n                vector<vector<int>> edges;\n                // 存储每个节点的入度\n                vector<int> indeg;\n                // 存储答案\n                vector<int> result;\n            \n            public:\n                vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\n                    edges.resize(numCourses);\n                    indeg.resize(numCourses);\n                    for (const auto& info: prerequisites) {\n                        edges[info[1]].push_back(info[0]);\n                        ++indeg[info[0]];\n                    }\n            \n                    queue<int> q;\n                    // 将所有入度为 0 的节点放入队列中\n                    for (int i = 0; i < numCourses; ++i) {\n                        if (indeg[i] == 0) {\n                            q.push(i);\n                        }\n                    }\n            \n                    while (!q.empty()) {\n                        // 从队首取出一个节点\n                        int u = q.front();\n                        q.pop();\n                        // 放入答案中\n                        result.push_back(u);\n                        for (int v: edges[u]) {\n                            --indeg[v];\n                            // 如果相邻节点 v 的入度为 0，就可以选 v 对应的课程了\n                            if (indeg[v] == 0) {\n                                q.push(v);\n                            }\n                        }\n                    }\n            \n                    if (result.size() != numCourses) {\n                        return {};\n                    }\n                    return result;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<int> findOrder(int numCourses, vector<vector<int>>& prerequisites) {\n                    vector<list<int>> courList(numCourses);\n                    vector<int> inNum(numCourses, 0);//每个课程的入度数\n                    for(auto p : prerequisites){//找到所有以该课程为前修课程的课程\n                        courList[p[1]].push_back(p[0]);\n                        inNum[p[0]]++;\n                    }\n                    queue<int> q;//存储所有入度为0的课程\n                    for (int i = 0; i < numCourses; i++) {\n                        if (inNum[i] == 0) {\n                            q.push(i);\n                        }\n                    }\n                    vector<int> ans;//记录访问结果\n                    while(!q.empty()){//删除入度为0的点\n                        int curNum = q.front();\n                        q.pop();\n                        ans.push_back(curNum);\n                        auto it = courList[curNum].begin();\n                        while(it != courList[curNum].end()){\n                            if(--inNum[*it] == 0) q.push(*it);\n                            it++;\n                        }\n                        courList[curNum].clear();\n                    }\n                    for(int num : inNum){//如果还存在入度不为0的点，则一定存在环\n                        if(num != 0) return {};\n                    }\n                    return ans;\n                }\n            };\n        "]
    },
    {
        "id":118,
        "description":"\n        Design a data structure that supports adding new words and finding if a string matches any previously added string.\n\nImplement the WordDictionary class:\n\nWordDictionary() Initializes the object.\nvoid addWord(word) Adds word to the data structure, it can be matched later.\nbool search(word) Returns true if there is any string in the data structure that matches word or false otherwise. word may contain dots '.' where dots can be matched with any letter.\n \n\nExample:\n\nInput\n[\"WordDictionary\",\"addWord\",\"addWord\",\"addWord\",\"search\",\"search\",\"search\",\"search\"]\n[[],[\"bad\"],[\"dad\"],[\"mad\"],[\"pad\"],[\"bad\"],[\".ad\"],[\"b..\"]]\nOutput\n[null,null,null,null,false,true,true,true]\n\nExplanation\nWordDictionary wordDictionary = new WordDictionary();\nwordDictionary.addWord(\"bad\");\nwordDictionary.addWord(\"dad\");\nwordDictionary.addWord(\"mad\");\nwordDictionary.search(\"pad\"); // return False\nwordDictionary.search(\"bad\"); // return True\nwordDictionary.search(\".ad\"); // return True\nwordDictionary.search(\"b..\"); // return True\n \n\nConstraints:\n\n1 <= word.length <= 25\nword in addWord consists of lowercase English letters.\nword in search consist of '.' or lowercase English letters.\nThere will be at most 2 dots in word for search queries.\nAt most 10^4 calls will be made to addWord and search.\n        ",
        "tag":["Depth-First Search","Design","Trie","String"],
        "answer":["\n        struct TrieNode{\n            vector<TrieNode *> child;\n            bool isEnd;\n            TrieNode() {\n                this->child = vector<TrieNode *>(26,nullptr);\n                this->isEnd = false;\n            }\n        };\n        \n        void insert(TrieNode * root, const string & word) {\n            TrieNode * node = root;\n            for (auto c : word) {\n                if (node->child[c - 'a'] == nullptr) {\n                    node->child[c - 'a'] = new TrieNode();\n                }\n                node = node->child[c - 'a'];\n            }\n            node->isEnd = true;\n        }\n        \n        class WordDictionary {\n        public:\n            WordDictionary() {\n                trie = new TrieNode();\n            }\n            \n            void addWord(string word) {\n                insert(trie,word);\n            }\n            \n            bool search(string word) {\n                return dfs(word, 0, trie);\n            }\n        \n            bool dfs(const string & word,int index,TrieNode * node) {\n        　　　　if (index == word.size()) {\n                    return node->isEnd;    \n                }\n                char ch = word[index];\n                if (ch >= 'a' && ch <= 'z') {\n                    TrieNode * child = node->child[ch - 'a'];\n                    if (child != nullptr && dfs(word, index + 1, child)) {\n                        return true;\n                    }\n                } else if (ch == '.') {\n                    for (int i = 0; i < 26; i++) {\n                        TrieNode * child = node->child[i];\n                        if (child != nullptr && dfs(word, index + 1, child)) {\n                            return true;\n                        }\n                    }\n                }\n                return false;\n            }\n        private:\n            TrieNode * trie;\n        };\n        ","\n        class TrieNode{\n            public:\n                vector<TrieNode*> child;\n                bool isWord;\n                TrieNode() : child(26, nullptr), isWord(false) {};\n                ~TrieNode() {\n                    for (auto c : child) delete c;\n                }\n            };\n            class WordDictionary {\n            public:\n                /** Initialize your data structure here. */\n                WordDictionary() {\n                    root = new TrieNode();\n                }\n                ~WordDictionary() {\n                    delete root;\n                }\n                /** Adds a word into the data structure. */\n                void addWord(string word) {\n                    TrieNode* p = root;\n                    for (char c : word) {\n                        int i = c - 'a';\n                        if (!p->child[i])\n                            p->child[i] = new TrieNode();\n                        p = p->child[i];\n                    }\n                    p->isWord = true;\n                }\n                \n                /** Returns if the word is in the data structure. A word could contain the dot character '.' to represent any one letter. */\n                bool search(string word) {\n                    return match(word, root, 0);\n                }\n                \n                bool match(string& word, TrieNode* p, int start) {\n                    if (!p) return false;\n                    if (start == word.size()) return p->isWord;\n                    char c = word[start];\n                    if (c != '.') {\n                        return match(word, p->child[c - 'a'], start + 1);\n                    } else {\n                        for (const auto& child : p->child) {\n                            if (match(word, child, start + 1))\n                                return true;\n                        }\n                    }\n                    return false;\n                }\n            private:\n                TrieNode* root;\n            };\n        ","\n        class WordDictionary {\n            public:\n                unordered_map<int, vector<set<string>>> words; // length -> mid character -> words\n            \n                WordDictionary() {\n            \n                }\n                \n                void addWord(string word) {\n                    int len = word.size();\n                    if (!words.count(len)) {\n                        words[len] = vector<set<string>>(26);\n                    }\n                    words[len][word[len/2]-'a'].insert(word);\n                }\n                \n                bool search(string word) {\n                    int len = word.size();\n                    if (!words.count(len)) return false;\n            \n                    if (word[len/2] == '.') {\n                        for (auto ws: words[len]) {\n                            for (auto w: ws) { \n                                int i = 0;\n                                for (i = 0; i < len; i++) {\n                                    if (word[i] == '.') continue;\n                                    if (w[i] == word[i]) continue;\n                                    break;\n                                }\n                                if (i == len) return true;\n                            }\n                        }\n                    } else {\n                        for (auto w: words[len][word[len/2]-'a']) {\n                            int i = 0;\n                            for (i = 0; i < len; i++) {\n                                if (word[i] == '.') continue;\n                                if (w[i] == word[i]) continue;\n                                break;\n                            }\n                            if (i == len) return true;\n                        }\n                    }\n            \n                    return false;\n                }\n            };\n        "]
    },
    {
        "id":119,
        "description":"\n        You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.\n\nGiven an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.\n\n \n\nExample 1:\n\nInput: nums = [2,3,2]\nOutput: 3\nExplanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.\nExample 2:\n\nInput: nums = [1,2,3,1]\nOutput: 4\nExplanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).\nTotal amount you can rob = 1 + 3 = 4.\nExample 3:\n\nInput: nums = [1,2,3]\nOutput: 3\n \n\nConstraints:\n\n1 <= nums.length <= 100\n0 <= nums[i] <= 1000\n        ",
        "tag":["Array","Dynamic Programming"],
        "answer":["\n        class Solution {\n            public:\n                int robRange(vector<int>& nums, int start, int end) {\n                    int first = nums[start], second = max(nums[start], nums[start + 1]);\n                    for (int i = start + 2; i <= end; i++) {\n                        int temp = second;\n                        second = max(first + nums[i], second);\n                        first = temp;\n                    }\n                    return second;\n                }\n            \n                int rob(vector<int>& nums) {\n                    int length = nums.size();\n                    if (length == 1) {\n                        return nums[0];\n                    } else if (length == 2) {\n                        return max(nums[0], nums[1]);\n                    }\n                    return max(robRange(nums, 0, length - 2), robRange(nums, 1, length - 1));\n                }\n            };\n        ","\n        class Solution {\n            int rob1(vector<int> &nums, int start, int end) { // [start,end)\n                int f0 = 0, f1 = 0;\n                for (int i = start; i < end; ++i) {\n                    int new_f = max(f1, f0 + nums[i]);\n                    f0 = f1;\n                    f1 = new_f;\n                }\n                return f1;\n            }\n        \n        public:\n            int rob(vector<int> &nums) {\n                int n = nums.size();\n                return max(nums[0] + rob1(nums, 2, n - 1), rob1(nums, 1, n));\n            }\n        };\n        ","\nclass Solution {\npublic:\n    int rob(vector<int>& nums) {\n        if (nums.size() == 0) return 0;\n        if (nums.size() == 1) return nums[0];\n        int result1 = robRange(nums, 0, nums.size() - 2); // 情况二\n        int result2 = robRange(nums, 1, nums.size() - 1); // 情况三\n        return max(result1, result2);\n    }\n    // 198.打家劫舍的逻辑\n    int robRange(vector<int>& nums, int start, int end) {\n        if (end == start) return nums[start];\n        vector<int> dp(nums.size());\n        dp[start] = nums[start];\n        dp[start + 1] = max(nums[start], nums[start + 1]);\n        for (int i = start + 2; i <= end; i++) {\n            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);\n        }\n        return dp[end];\n    }\n};\n        "]
    },
    {
        "id":120,
        "description":"\n        You are given a string s. You can convert s to a \npalindrome\n by adding characters in front of it.\n\nReturn the shortest palindrome you can find by performing this transformation.\n\n \n\nExample 1:\n\nInput: s = \"aacecaaa\"\nOutput: \"aaacecaaa\"\nExample 2:\n\nInput: s = \"abcd\"\nOutput: \"dcbabcd\"\n \n\nConstraints:\n\n0 <= s.length <= 5 * 10^4\ns consists of lowercase English letters only.\n        ",
        "tag":["String","String Matching","Hash Function","Rolling Hash"],
        "answer":["\n        class Solution {\n            public:\n                string shortestPalindrome(string s) {\n                    int n = s.size();\n                    int base = 131, mod = 1000000007;\n                    int left = 0, right = 0, mul = 1;\n                    int best = -1;\n                    for (int i = 0; i < n; ++i) {\n                        left = ((long long)left * base + s[i]) % mod;\n                        right = (right + (long long)mul * s[i]) % mod;\n                        if (left == right) {\n                            best = i;\n                        }\n                        mul = (long long)mul * base % mod;\n                    }\n                    string add = (best == n - 1 ? \"\" : s.substr(best + 1, n));\n                    reverse(add.begin(), add.end());\n                    return add + s;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                string shortestPalindrome(string s) {\n                    int n = s.size();\n                    vector<int> fail(n, -1);\n                    for (int i = 1; i < n; ++i) {\n                        int j = fail[i - 1];\n                        while (j != -1 && s[j + 1] != s[i]) {\n                            j = fail[j];\n                        }\n                        if (s[j + 1] == s[i]) {\n                            fail[i] = j + 1;\n                        }\n                    }\n                    int best = -1;\n                    for (int i = n - 1; i >= 0; --i) {\n                        while (best != -1 && s[best + 1] != s[i]) {\n                            best = fail[best];\n                        }\n                        if (s[best + 1] == s[i]) {\n                            ++best;\n                        }\n                    }\n                    string add = (best == n - 1 ? \"\" : s.substr(best + 1, n));\n                    reverse(add.begin(), add.end());\n                    return add + s;\n                }\n            };\n        ","\nclass Solution {\n    public:\n        string shortestPalindrome(string s) {\n             if(s.size() == 0)return \"\";\n             string rs = s;\n             reverse(rs.begin(),rs.end());\n             string str = s + \"#\" + rs;\n             int n = str.size();\n             vector<int> next(n + 1, 0);\n             for(int i = 1 ; i < n ; i ++){\n                 int j = next[i];\n                 while(j && str[i] != str[j]) j = next[j];\n                 if(str[i] == str[j]) next[i + 1] = j + 1;\n                 else next[i + 1] = 0;\n             }\n             cout<<str<<endl;\n             for(auto & it:next) cout<<it<<endl;\n             return  rs + s.substr(next[n - 1] + 1);\n        }\n    };\n        "]
    },
    {
        "id":121,
        "description":"\n        Given an integer array nums and an integer k, return the k^th largest element in the array.\n\nNote that it is the k^th largest element in the sorted order, not the k^th distinct element.\n\nCan you solve it without sorting?\n\n \n\nExample 1:\n\nInput: nums = [3,2,1,5,6,4], k = 2\nOutput: 5\nExample 2:\n\nInput: nums = [3,2,3,1,2,4,5,5,6], k = 4\nOutput: 4\n \n\nConstraints:\n\n1 <= k <= nums.length <= 10^5\n-10^4 <= nums[i] <= 10^4\n        ",
        "tag":["Array","Divide and Conquer","Quickselect","Sorting","Heap (Priority Queue)"],
        "answer":["\n        class Solution {\n            public:\n                int quickSelect(vector<int>& a, int l, int r, int index) {\n                    int q = randomPartition(a, l, r);\n                    if (q == index) {\n                        return a[q];\n                    } else {\n                        return q < index ? quickSelect(a, q + 1, r, index) : quickSelect(a, l, q - 1, index);\n                    }\n                }\n            \n                inline int randomPartition(vector<int>& a, int l, int r) {\n                    int i = rand() % (r - l + 1) + l;\n                    swap(a[i], a[r]);\n                    return partition(a, l, r);\n                }\n            \n                inline int partition(vector<int>& a, int l, int r) {\n                    int x = a[r], i = l - 1;\n                    for (int j = l; j < r; ++j) {\n                        if (a[j] <= x) {\n                            swap(a[++i], a[j]);\n                        }\n                    }\n                    swap(a[i + 1], a[r]);\n                    return i + 1;\n                }\n            \n                int findKthLargest(vector<int>& nums, int k) {\n                    srand(time(0));\n                    return quickSelect(nums, 0, nums.size() - 1, nums.size() - k);\n                }\n            };\n        ","\n        class Solution {\n            public:\n                void maxHeapify(vector<int>& a, int i, int heapSize) {\n                    int l = i * 2 + 1, r = i * 2 + 2, largest = i;\n                    if (l < heapSize && a[l] > a[largest]) {\n                        largest = l;\n                    } \n                    if (r < heapSize && a[r] > a[largest]) {\n                        largest = r;\n                    }\n                    if (largest != i) {\n                        swap(a[i], a[largest]);\n                        maxHeapify(a, largest, heapSize);\n                    }\n                }\n            \n                void buildMaxHeap(vector<int>& a, int heapSize) {\n                    for (int i = heapSize / 2; i >= 0; --i) {\n                        maxHeapify(a, i, heapSize);\n                    } \n                }\n            \n                int findKthLargest(vector<int>& nums, int k) {\n                    int heapSize = nums.size();\n                    buildMaxHeap(nums, heapSize);\n                    for (int i = nums.size() - 1; i >= nums.size() - k + 1; --i) {\n                        swap(nums[0], nums[i]);\n                        --heapSize;\n                        maxHeapify(nums, 0, heapSize);\n                    }\n                    return nums[0];\n                }\n            };\n        ","\n        class Solution \n{\npublic:\n    int findKthLargest(vector<int>& nums, int k) \n    {\n        priority_queue<int, vector<int>, less<int>> maxHeap;\n        for (int x : nums)\n            maxHeap.push(x);\n        for (int _ = 0; _ < k - 1; _ ++)\n            maxHeap.pop();\n        return maxHeap.top();\n    }\n};\n        ","\n        class Solution \n{\npublic:\n    int findKthLargest(vector<int>& nums, int k) \n    {\n        int n = nums.size();\n        build_maxHeap(nums);\n        for (int i = 0; i < k - 1; i ++)\n        {\n            swap(nums[0], nums[n-1-i]);\n            adjust_down(nums, 0, n-1-i - 1);\n        }\n        return nums[0];\n    }\n\n\n    void build_maxHeap(vector<int> & nums)\n    {\n        int n = nums.size();\n        for (int root = n/2; root > -1; root --)\n            adjust_down(nums, root, n - 1);\n    }\n\n    void adjust_down(vector<int> & nums, int root, int hi)\n    {\n        if (root > hi)\n            return ;\n        int t = nums[root];\n        int child = 2 * root + 1;\n        while (child <= hi)\n        {\n            if (child + 1 <= hi && nums[child] < nums[child + 1])\n                child ++;\n            if (t > nums[child])\n                break;\n            nums[root] = nums[child];\n            root = child;\n            child = 2 * root + 1;\n        }\n        nums[root] = t;\n    }\n};\n        ","\n        class Solution \n{\npublic:\n    int findKthLargest(vector<int>& nums, int k) \n    {\n        int n = nums.size();\n        int l = 0;\n        int r = n - 1;\n        while (true)\n        {\n            int idx = partition(nums, l, r);\n            if (idx == k - 1)\n                return nums[idx];\n            else if (idx < k - 1)\n                l = idx + 1;\n            else    \n                r = idx - 1;\n        }\n    }\n\n    int partition(vector<int> & nums, int l, int r)\n    {\n        int pivot = nums[l];\n        while (l < r)\n        {\n            while (l < r && nums[r] <= pivot)\n                r --;\n            nums[l] = nums[r];\n            while (l < r && nums[l] >= pivot)\n                l ++;\n            nums[r] = nums[l];\n        }\n        nums[l] = pivot;\n        return l;\n    }\n};\n        ","\n        class Solution \n{\npublic:\n    int findKthLargest(vector<int>& nums, int k) \n    {\n        int n = nums.size();\n        int l = 0;\n        int r = n - 1;\n        while (true)\n        {\n            int idx = partition(nums, l, r);\n            if (idx == k - 1)\n                return nums[idx];\n            else if (idx < k - 1)\n                l = idx + 1;\n            else    \n                r = idx - 1;\n        }\n    }\n\n    //----左右交换\n    int partition(vector<int> & nums, int l, int r)\n    {\n        int pivot = nums[l];\n        int begin = l;\n        while (l < r)\n        {\n            while (l < r && nums[r] <= pivot)\n                r --;\n            while (l < r && nums[l] >= pivot)\n                l ++;\n            if (l < r)\n                swap(nums[l], nums[r]);\n        }\n        swap(nums[begin], nums[l]);\n        return l;\n    }\n};\n        ","\n        class Solution \n{\npublic:\n    int findKthLargest(vector<int>& nums, int k) \n    {\n        int n = nums.size();\n        int l = 0;\n        int r = n - 1;\n        while (true)\n        {\n            int idx = partition(nums, l, r);\n            if (idx == k - 1)\n                return nums[idx];\n            else if (idx < k - 1)\n                l = idx + 1;\n            else    \n                r = idx - 1;\n        }\n    }\n\n    //----单向遍历\n    int partition(vector<int> & nums, int l, int r)\n    {\n        int pivot = nums[l];\n        int idx = l;\n        for (int i = l + 1; i < r + 1; i ++)\n        {\n            if (nums[i] >= pivot)\n            {\n                idx ++;\n                swap(nums[idx], nums[i]);\n            }\n        }\n        swap(nums[l], nums[idx]);\n        return idx;\n    }\n};\n        "]
    },
    {
        "id":122,
        "description":"\n        Find all valid combinations of k numbers that sum up to n such that the following conditions are true:\n\nOnly numbers 1 through 9 are used.\nEach number is used at most once.\nReturn a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.\n\n \n\nExample 1:\n\nInput: k = 3, n = 7\nOutput: [[1,2,4]]\nExplanation:\n1 + 2 + 4 = 7\nThere are no other valid combinations.\nExample 2:\n\nInput: k = 3, n = 9\nOutput: [[1,2,6],[1,3,5],[2,3,4]]\nExplanation:\n1 + 2 + 6 = 9\n1 + 3 + 5 = 9\n2 + 3 + 4 = 9\nThere are no other valid combinations.\nExample 3:\n\nInput: k = 4, n = 1\nOutput: []\nExplanation: There are no valid combinations.\nUsing 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 > 1, there are no valid combination.\n \n\nConstraints:\n\n2 <= k <= 9\n1 <= n <= 60\n        ",
        "tag":["Array","Backtracking"],
        "answer":["\n        class Solution {\n            public:\n                vector<int> temp;\n                vector<vector<int>> ans;\n            \n                bool check(int mask, int k, int n) {\n                    temp.clear();\n                    for (int i = 0; i < 9; ++i) {\n                        if ((1 << i) & mask) {\n                            temp.push_back(i + 1);\n                        }\n                    }\n                    return temp.size() == k && accumulate(temp.begin(), temp.end(), 0) == n; \n                }\n            \n                vector<vector<int>> combinationSum3(int k, int n) {\n                    for (int mask = 0; mask < (1 << 9); ++mask) {\n                        if (check(mask, k, n)) {\n                            ans.emplace_back(temp);\n                        }\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<int> temp;\n                vector<vector<int>> ans;\n            \n                void dfs(int cur, int n, int k, int sum) {\n                    if (temp.size() + (n - cur + 1) < k || temp.size() > k) {\n                        return;\n                    }\n                    if (temp.size() == k && accumulate(temp.begin(), temp.end(), 0) == sum) {\n                        ans.push_back(temp);\n                        return;\n                    }\n                    temp.push_back(cur);\n                    dfs(cur + 1, n, k, sum);\n                    temp.pop_back();\n                    dfs(cur + 1, n, k, sum);\n                }\n            \n                vector<vector<int>> combinationSum3(int k, int n) {\n                    dfs(1, 9, k, n);\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<vector<int>> combinationSum3(int k, int n) {\n                    vector<vector<int>> ans;\n                    vector<int> path;\n                    function<void(int, int)> dfs = [&](int i, int t) {\n                        int d = k - path.size(); // 还要选 d 个数\n                        if (t < 0 or t > (i * 2 - d + 1) * d / 2) // 剪枝\n                            return;\n                        if (d == 0) {\n                            ans.emplace_back(path);\n                            return;\n                        }\n                        for (int j = i; j >= d; --j) {\n                            path.push_back(j);\n                            dfs(j - 1, t - j);\n                            path.pop_back();\n                        }\n                    };\n                    dfs(9, n);\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<vector<int>> combinationSum3(int k, int n) {\n                    vector<vector<int>> ans;\n                    vector<int> path;\n                    function<void(int, int)> dfs = [&](int i, int t) {\n                        int d = k - path.size(); // 还要选 d 个数\n                        if (t < 0 or t > (i * 2 - d + 1) * d / 2) // 剪枝\n                            return;\n                        if (d == 0) {\n                            ans.emplace_back(path);\n                            return;\n                        }\n                        // 不选 i\n                        if (i > d) dfs(i - 1, t);\n                        // 选 i\n                        path.push_back(i);\n                        dfs(i - 1, t - i);\n                        path.pop_back();\n                    };\n                    dfs(9, n);\n                    return ans;\n                }\n            };\n        "]
    },
    {
        "id":123,
        "description":"\n        Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.\n\n \n\nExample 1:\n\nInput: nums = [1,2,3,1]\nOutput: true\nExample 2:\n\nInput: nums = [1,2,3,4]\nOutput: false\nExample 3:\n\nInput: nums = [1,1,1,3,3,4,3,2,4,2]\nOutput: true\n \n\nConstraints:\n\n1 <= nums.length <= 10^5\n-10^9 <= nums[i] <= 10^9\n        ",
        "tag":["Array","Hash Table","Sorting"],
        "answer":["\n        class Solution {\n            public:\n                bool containsDuplicate(vector<int>& nums) {\n                    sort(nums.begin(), nums.end());\n                    int n = nums.size();\n                    for (int i = 0; i < n - 1; i++) {\n                        if (nums[i] == nums[i + 1]) {\n                            return true;\n                        }\n                    }\n                    return false;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool containsDuplicate(vector<int>& nums) {\n                    unordered_set<int> s;\n                    for (int x: nums) {\n                        if (s.find(x) != s.end()) {\n                            return true;\n                        }\n                        s.insert(x);\n                    }\n                    return false;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool containsDuplicate(vector<int>& nums) {\n                    set<int> set;\n                    for(int x:nums){\n                        set.insert(x);\n                       }\n                    if(set.size()!=nums.size()){\n                            return true;\n                     }\n                    return false;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool containsDuplicate(vector<int>& nums) {\n                    sort(nums.begin(), nums.end());\n                    for (int i = 1; i < nums.size(); i++) \n                        if (nums[i-1] == nums[i]) return true;\n                    return false;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool containsDuplicate(vector<int>& nums) {\n                    unordered_set<int> set;\n                    for (int num: nums) {\n                        if (set.find(num) != set.end()) return true;\n                        set.insert(num);        \n                    }\n                    return false;\n                }\n            };\n        ","\n        public:\n    bool containsDuplicate(vector<int>& nums) {\n        if(nums.size() <= 1) return false;\n        unordered_map<int,int> map;\n        for(int num : nums) {\n            map[num]++;\n            if(map[num] >= 2) return true;\n        }\n        return false;\n    }\n};\n        "]
    },
    {
        "id":124,
        "description":"\n        Given an integer array nums and an integer k, return true if there are two distinct indices i and j in the array such that nums[i] == nums[j] and abs(i - j) <= k.\n\n \n\nExample 1:\n\nInput: nums = [1,2,3,1], k = 3\nOutput: true\nExample 2:\n\nInput: nums = [1,0,1,1], k = 1\nOutput: true\nExample 3:\n\nInput: nums = [1,2,3,1,2,3], k = 2\nOutput: false\n \n\nConstraints:\n\n1 <= nums.length <= 10^5\n-10^9 <= nums[i] <= 10^9\n0 <= k <= 10^5\n        ",
        "tag":["Array","Hash Table","Sliding Window"],
        "answer":["\n        class Solution {\n            public:\n                bool containsNearbyDuplicate(vector<int>& nums, int k) {\n                    unordered_map<int, int> dictionary;\n                    int length = nums.size();\n                    for (int i = 0; i < length; i++) {\n                        int num = nums[i];\n                        if (dictionary.count(num) && i - dictionary[num] <= k) {\n                            return true;\n                        }\n                        dictionary[num] = i;\n                    }\n                    return false;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool containsNearbyDuplicate(vector<int>& nums, int k) {\n                    unordered_set<int> s;\n                    int length = nums.size();\n                    for (int i = 0; i < length; i++) {\n                        if (i > k) {\n                            s.erase(nums[i - k - 1]);\n                        }\n                        if (s.count(nums[i])) {\n                            return true;\n                        }\n                        s.emplace(nums[i]);\n                    }\n                    return false;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool containsNearbyDuplicate(vector<int>& nums, int k) {\n                    int n = nums.size();\n                    unordered_map<int, bool> set;\n                    for(int i = 0; i < n; ++i){\n                        if(i > k) set[nums[i - k - 1]] = false;\n                        if(set[nums[i]]) return true;\n                        set[nums[i]] = true;\n                    }\n                    return false;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool containsNearbyDuplicate(vector<int>& nums, int k) {\n                    map<int, int> st;\n                    for (int i = 0; i < nums.size(); i ++) {\n                        if (st.count(nums[i])) {\n                            if (i - st[nums[i]] <= k) return true; \n                        }\n                        st[nums[i]] = i;\n                    }\n                    return\n                }\n            };\n        "]
    },
    {
        "id":125,
        "description":"\n        You are given an integer array nums and two integers indexDiff and valueDiff.\n\nFind a pair of indices (i, j) such that:\n\ni != j,\nabs(i - j) <= indexDiff.\nabs(nums[i] - nums[j]) <= valueDiff, and\nReturn true if such pair exists or false otherwise.\n\n \n\nExample 1:\n\nInput: nums = [1,2,3,1], indexDiff = 3, valueDiff = 0\nOutput: true\nExplanation: We can choose (i, j) = (0, 3).\nWe satisfy the three conditions:\ni != j --> 0 != 3\nabs(i - j) <= indexDiff --> abs(0 - 3) <= 3\nabs(nums[i] - nums[j]) <= valueDiff --> abs(1 - 1) <= 0\nExample 2:\n\nInput: nums = [1,5,9,1,5,9], indexDiff = 2, valueDiff = 3\nOutput: false\nExplanation: After trying all the possible pairs (i, j), we cannot satisfy the three conditions, so we return false.\n \n\nConstraints:\n\n2 <= nums.length <= 10^5\n-10^9 <= nums[i] <= 10^9\n1 <= indexDiff <= nums.length\n0 <= valueDiff <= 10^9\n        ",
        "tag":["Array","Bucket Sort","Ordered Set","Sorting","Sliding Window"],
        "answer":["\n        class Solution {\n            public:\n                bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\n                    int n = nums.size();\n                    set<int> rec;\n                    for (int i = 0; i < n; i++) {\n                        auto iter = rec.lower_bound(max(nums[i], INT_MIN + t) - t);\n                        if (iter != rec.end() && *iter <= min(nums[i], INT_MAX - t) + t) {\n                            return true;\n                        }\n                        rec.insert(nums[i]);\n                        if (i >= k) {\n                            rec.erase(nums[i - k]);\n                        }\n                    }\n                    return false;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int getID(int x, long w) {\n                    return x < 0 ? (x + 1ll) / w - 1 : x / w;\n                }\n            \n                bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\n                    unordered_map<int, int> mp;\n                    int n = nums.size();\n                    for (int i = 0; i < n; i++) {\n                        long x = nums[i];\n                        int id = getID(x, t + 1ll);\n                        if (mp.count(id)) {\n                            return true;\n                        }\n                        if (mp.count(id - 1) && abs(x - mp[id - 1]) <= t) {\n                            return true;\n                        }\n                        if (mp.count(id + 1) && abs(x - mp[id + 1]) <= t) {\n                            return true;\n                        }\n                        mp[id] = x;\n                        if (i >= k) {\n                            mp.erase(getID(nums[i - k], t + 1ll));\n                        }\n                    }\n                    return false;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {\n                    set<long> st;\n                    for (int i = 0; i < nums.size(); i++) {\n                        auto lb = st.lower_bound((long)nums[i] - t);\n                        if (lb != st.end() && *lb <= (long)nums[i] + t) return 1;\n                        st.insert(nums[i]);\n                        if (i >= k) st.erase(nums[i - k]);\n                    }\n                    return 0;\n                }\n            };\n        ","\n        #define LL long long\nclass Solution {\npublic:\n    LL size;\n    bool containsNearbyAlmostDuplicate(vector <int> & nums, int k, int t) {\n        int n = nums.size();\n        unordered_map<LL, LL> m;\n        size = t + 1L;\n        for (int i = 0; i < n; i++) {\n            LL u = nums[i] * 1L;\n            LL idx = getIdx(u);\n            // 目标桶已存在（桶不为空），说明前面已有 [u - t, u + t] 范围的数字\n            if (m.find(idx) != m.end()) return true;\n            // 检查相邻的桶\n            LL l = idx - 1, r = idx + 1;\n            if (m.find(l) != m.end() && abs(u - m[l]) <= t) return true;\n            if (m.find(r) != m.end() && abs(u - m[r]) <= t) return true;\n            // 建立目标桶\n            m.insert({idx, u});\n            // 移除下标范围不在 [max(0, i - k), i) 内的桶\n            if (i >= k) m.erase(getIdx(nums[i - k]));\n        }\n        return false;\n    }\n    LL getIdx(LL u) {\n        return u >= 0 ? u / size : ((u + 1) / size) - 1;\n    }\n};\n        "]
    },
    {
        "id":126,
        "description":"\n        Given a string s representing a valid expression, implement a basic calculator to evaluate it, and return the result of the evaluation.\n\nNote: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().\n\n \n\nExample 1:\n\nInput: s = \"1 + 1\"\nOutput: 2\nExample 2:\n\nInput: s = \" 2-1 + 2 \"\nOutput: 3\nExample 3:\n\nInput: s = \"(1+(4+5+2)-3)+(6+8)\"\nOutput: 23\n \n\nConstraints:\n\n1 <= s.length <= 3 * 10^5\ns consists of digits, '+', '-', '(', ')', and ' '.\ns represents a valid expression.\n'+' is not used as a unary operation (i.e., \"+1\" and \"+(2 + 3)\" is invalid).\n'-' could be used as a unary operation (i.e., \"-1\" and \"-(2 + 3)\" is valid).\nThere will be no two consecutive operators in the input.\nEvery number and running calculation will fit in a signed 32-bit integer.\n        ",
        "tag":["Stack","Recursion","Math","String"],
        "answer":["\n        class Solution {\n            public:\n                int calculate(string s) {\n                    stack<int> ops;\n                    ops.push(1);\n                    int sign = 1;\n            \n                    int ret = 0;\n                    int n = s.length();\n                    int i = 0;\n                    while (i < n) {\n                        if (s[i] == ' ') {\n                            i++;\n                        } else if (s[i] == '+') {\n                            sign = ops.top();\n                            i++;\n                        } else if (s[i] == '-') {\n                            sign = -ops.top();\n                            i++;\n                        } else if (s[i] == '(') {\n                            ops.push(sign);\n                            i++;\n                        } else if (s[i] == ')') {\n                            ops.pop();\n                            i++;\n                        } else {\n                            long num = 0;\n                            while (i < n && s[i] >= '0' && s[i] <= '9') {\n                                num = num * 10 + s[i] - '0';\n                                i++;\n                            }\n                            ret += sign * num;\n                        }\n                    }\n                    return ret;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                void replace(string& s){\n                    int pos = s.find(\" \");\n                    while (pos != -1) {\n                        s.replace(pos, 1, \"\");\n                        pos = s.find(\" \");\n                    }\n                }\n                int calculate(string s) {\n                    // 存放所有的数字\n                    stack<int> nums;\n                    // 为了防止第一个数为负数，先往 nums 加个 0\n                    nums.push(0);\n                    // 将所有的空格去掉\n                    replace(s);\n                    // 存放所有的操作，包括 +/-\n                    stack<char> ops;\n                    int n = s.size();\n                    for(int i = 0; i < n; i++) {\n                        char c = s[i];\n                        if(c == '(')\n                            ops.push(c);\n                        else if(c == ')') {\n                            // 计算到最近一个左括号为止\n                            while(!ops.empty()) {\n                                char op = ops.top();\n                                if(op != '(')\n                                    calc(nums, ops);\n                                else {\n                                    ops.pop();\n                                    break;\n                                }\n                            }\n                        }\n                        else {\n                            if(isdigit(c)) {\n                                int cur_num = 0;\n                                int j = i;\n                                // 将从 i 位置开始后面的连续数字整体取出，加入 nums\n                                while(j <n && isdigit(s[j]))\n                                    cur_num = cur_num*10 + (s[j++] - '0');\n                                // 注意上面的计算一定要有括号，否则有可能会溢出\n                                nums.push(cur_num);\n                                i = j-1;\n                            }\n                            else {\n                                if (i > 0 && (s[i - 1] == '(' || s[i - 1] == '+' || s[i - 1] == '-')) {\n                                    nums.push(0);\n                                }\n                                // 有一个新操作要入栈时，先把栈内可以算的都算了\n                                while(!ops.empty() && ops.top() != '(')\n                                    calc(nums, ops);\n                                ops.push(c);\n                            }\n                        }\n                    }\n                    while(!ops.empty())\n                        calc(nums, ops);\n                    return nums.top();\n                }\n                void calc(stack<int> &nums, stack<char> &ops) {\n                    if(nums.size() < 2 || ops.empty())\n                        return;\n                    int b = nums.top(); nums.pop();\n                    int a = nums.top(); nums.pop();\n                    char op = ops.top(); ops.pop();\n                    nums.push(op == '+' ? a+b : a-b);\n                }\n            };\n        ","\n        class Solution {\n            public:\n            \n                string removeBlank(string s) {\n                    string res = \"\";\n                    for(char c:s) {\n                        if(c!=' ') res += c;\n                    }\n                    return res;\n                }\n            \n                queue<string> getToken(string s) {\n                    \n                    s = removeBlank(s);\n                    string push_src = \"\";\n                    queue<string> res;\n                    bool pre = true;\n                    for(char c:s) {\n                        //判断是不是单目运算符 使用$代替单目运算符\n                        if(c == '-' && pre) {\n                            if(push_src!=\"\") {\n                                res.push(push_src);\n                                push_src = \"\";\n                                \n                            }\n                            res.push(\"$\");\n                            \n                        }else if(c == '+' || c=='-' || c=='*' || c=='/' || c=='(' || c==')'||c=='#') {\n                            if(c!=')')pre = true;\n                            if(push_src!=\"\") {\n                                res.push(push_src);\n                                push_src = \"\";\n                                \n                            }\n                            res.push(string(\"\")+c);\n                        }else{\n                            pre = false;\n                            push_src += c;\n                        }\n                    }\n                    if(push_src!=\"\") {\n                        res.push(push_src);\n                        push_src = \"\";\n                    }\n                    return res;\n                } \n            \n            \n            \n                int calculate(string s) {\n                    queue<string> in = getToken(s+\"#\");\n                    map<string,int> isp = {\n                        {\"#\",0},{\"(\",1},{\"*\",5},{\"/\",5},{\"+\",3},{\"-\",3},{\")\",8},{\"$\",7}\n                    };\n                    map<string,int> icp = {\n                        {\"#\",0},{\"(\",8},{\"*\",4},{\"/\",4},{\"+\",2},{\"-\",2},{\")\",1},{\"$\",6}\n                    };\n            \n                    queue<string> out;\n                    stack<string> stk;\n                    stk.push(\"#\");\n                    string ch = in.front();\n                    in.pop();\n                    while(stk.top()!=\"#\"||ch!=\"#\") {\n                        if(isp.find(ch)==isp.end()) {\n                            out.push(ch);\n                            ch = in.front();\n                            in.pop();\n                            continue;\n                        }\n                        if(icp[ch] > isp[stk.top()]) {\n            \n                            stk.push(ch);\n                            ch = in.front();\n                            in.pop();\n            \n                        }else if(icp[ch] < isp[stk.top()]) {\n                            out.push(stk.top());\n                            stk.pop();\n                        }else {\n                            stk.pop();\n                            if(ch!=\"#\") {\n                                ch = in.front();\n                                in.pop();\n                            }\n                        }\n                    }\n                    stack<int> sk;\n                    //TODO:逆波兰式子求解\n                    while(!out.empty()) {\n                        string cur = out.front();\n                        out.pop();\n                        if(cur == \"$\") {\n                            int a = sk.top();\n                            sk.pop();\n                            sk.push(-a);\n                        }else if(cur == \"+\") {\n                            int a2 = sk.top();\n                            sk.pop();\n                            int a1 = sk.top();\n                            sk.pop();\n                            sk.push(a1+a2);               \n                        }else if(cur == \"-\") {\n                            int a2 = sk.top();\n                            sk.pop();\n                            int a1 = sk.top();\n                            sk.pop();\n                            sk.push(a1-a2); \n                        }else if(cur == \"*\") {\n                            int a2 = sk.top();\n                            sk.pop();\n                            int a1 = sk.top();\n                            sk.pop();\n                            sk.push(a1*a2); \n                        }else if(cur == \"/\") {\n                            int a2 = sk.top();\n                            sk.pop();\n                            int a1 = sk.top();\n                            sk.pop();\n                            sk.push(a1/a2); \n                        }else {\n                            sk.push(stoi(cur));\n                        }\n                    }\n                    return sk.top();\n                }\n            };\n        "]
    },
    {
        "id":127,
        "description":"\n        Implement a last-in-first-out (LIFO) stack using only two queues. The implemented stack should support all the functions of a normal stack (push, top, pop, and empty).\n\nImplement the MyStack class:\n\nvoid push(int x) Pushes element x to the top of the stack.\nint pop() Removes the element on the top of the stack and returns it.\nint top() Returns the element on the top of the stack.\nboolean empty() Returns true if the stack is empty, false otherwise.\nNotes:\n\nYou must use only standard operations of a queue, which means that only push to back, peek/pop from front, size and is empty operations are valid.\nDepending on your language, the queue may not be supported natively. You may simulate a queue using a list or deque (double-ended queue) as long as you use only a queue's standard operations.\n \n\nExample 1:\n\nInput\n[\"MyStack\", \"push\", \"push\", \"top\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]\nOutput\n[null, null, null, 2, 2, false]\n\nExplanation\nMyStack myStack = new MyStack();\nmyStack.push(1);\nmyStack.push(2);\nmyStack.top(); // return 2\nmyStack.pop(); // return 2\nmyStack.empty(); // return False\n \n\nConstraints:\n\n1 <= x <= 9\nAt most 100 calls will be made to push, pop, top, and empty.\nAll the calls to pop and top are valid.\n        ",
        "tag":["Stack","Design","Queue"],
        "answer":["\n        class MyStack {\n            public:\n                queue<int> queue1;\n                queue<int> queue2;\n            \n                /** Initialize your data structure here. */\n                MyStack() {\n            \n                }\n            \n                /** Push element x onto stack. */\n                void push(int x) {\n                    queue2.push(x);\n                    while (!queue1.empty()) {\n                        queue2.push(queue1.front());\n                        queue1.pop();\n                    }\n                    swap(queue1, queue2);\n                }\n                \n                /** Removes the element on top of the stack and returns that element. */\n                int pop() {\n                    int r = queue1.front();\n                    queue1.pop();\n                    return r;\n                }\n                \n                /** Get the top element. */\n                int top() {\n                    int r = queue1.front();\n                    return r;\n                }\n                \n                /** Returns whether the stack is empty. */\n                bool empty() {\n                    return queue1.empty();\n                }\n            };\n        ","\n        class MyStack {\n            public:\n                queue<int> q;\n            \n                /** Initialize your data structure here. */\n                MyStack() {\n            \n                }\n            \n                /** Push element x onto stack. */\n                void push(int x) {\n                    int n = q.size();\n                    q.push(x);\n                    for (int i = 0; i < n; i++) {\n                        q.push(q.front());\n                        q.pop();\n                    }\n                }\n                \n                /** Removes the element on top of the stack and returns that element. */\n                int pop() {\n                    int r = q.front();\n                    q.pop();\n                    return r;\n                }\n                \n                /** Get the top element. */\n                int top() {\n                    int r = q.front();\n                    return r;\n                }\n                \n                /** Returns whether the stack is empty. */\n                bool empty() {\n                    return q.empty();\n                }\n            };\n        ","\n        class MyStack {\n            public:\n                queue<int> queue1;\n                queue<int> queue2;\n            \n                MyStack() {\n            \n                }\n            \n                void push(int x) {\n                    queue2.push(x);\n                    while (!queue1.empty()) {\n                        queue2.push(queue1.front());\n                        queue1.pop();\n                    }\n                    swap(queue1, queue2);\n                }\n                \n                int pop() {\n                    int r = queue1.front();\n                    queue1.pop();\n                    return r;\n                }\n                \n                int top() {\n                    int r = queue1.front();\n                    return r;\n                }\n                \n                bool empty() {\n                    return queue1.empty();\n                }\n            };\n        "]
    },
    {
        "id":128,
        "description":"\n        Given a string s which represents an expression, evaluate this expression and return its value. \n\nThe integer division should truncate toward zero.\n\nYou may assume that the given expression is always valid. All intermediate results will be in the range of [-2^31, 2^31 - 1].\n\nNote: You are not allowed to use any built-in function which evaluates strings as mathematical expressions, such as eval().\n\n \n\nExample 1:\n\nInput: s = \"3+2*2\"\nOutput: 7\nExample 2:\n\nInput: s = \" 3/2 \"\nOutput: 1\nExample 3:\n\nInput: s = \" 3+5 / 2 \"\nOutput: 5\n \n\nConstraints:\n\n1 <= s.length <= 3 * 10^5\ns consists of integers and operators ('+', '-', '*', '/') separated by some number of spaces.\ns represents a valid expression.\nAll the integers in the expression are non-negative integers in the range [0, 2^31 - 1].\nThe answer is guaranteed to fit in a 32-bit integer.\n        ",
        "tag":["Stack","Math","String"],
        "answer":["\n        class Solution {\n            public:\n                int calculate(string s) {\n                    vector<int> stk;\n                    char preSign = '+';\n                    int num = 0;\n                    int n = s.length();\n                    for (int i = 0; i < n; ++i) {\n                        if (isdigit(s[i])) {\n                            num = num * 10 + int(s[i] - '0');\n                        }\n                        if (!isdigit(s[i]) && s[i] != ' ' || i == n - 1) {\n                            switch (preSign) {\n                                case '+':\n                                    stk.push_back(num);\n                                    break;\n                                case '-':\n                                    stk.push_back(-num);\n                                    break;\n                                case '*':\n                                    stk.back() *= num;\n                                    break;\n                                default:\n                                    stk.back() /= num;\n                            }\n                            preSign = s[i];\n                            num = 0;\n                        }\n                    }\n                    return accumulate(stk.begin(), stk.end(), 0);\n                }\n            };\n        ","\n        class Solution {\n            public:\n                stack<int> num;  //存贮数字\n                stack<char> op;  //存贮操作\n            \n                void eval() \n                {\n                    int b = num.top(); num.pop();\n                    int a = num.top(); num.pop();\n                    char c = op.top(); op.pop();\n                    int r;\n                    if (c == '+') r = a + b;\n                    else if (c == '-') r = a - b;\n                    else if (c == '*') r = a * b;\n                    else r = a / b;\n                    num.push(r);\n                }\n            \n                int calculate(string s) {\n                    s = '0' + s;  // 对开头是负数的处理 \n                    unordered_map<char, int> pr; \n                    pr['+'] = pr['-'] = 1, pr['*'] = pr['/'] = 2; //定义运算符的优先级\n                    for(int i = 0; i < s.size(); i++)\n                    {\n                        char c = s[i]; \n                        if(c == ' ') continue;  //跳过空格\n                        if(isdigit(c))     //c是数字,读取一个连续的数字\n                        {\n                            int x= 0;\n                            while(i < s.size() && s[i] >= '0' && s[i] <= '9') x = x * 10 + (s[i++] - '0');  num.push(x);\n                            i--;\n                        }\n                        else  //c是操作符 \n                        {     //op栈非空并且栈顶操作符优先级大于等于当前操作符c的优先级，进行eval()计算\n                            while(op.size() && pr[op.top()] >= pr[c]) eval(); \n                            op.push(c);\n                        }\n                    }\n                    while(op.size()) eval(); \n                    return num.top();\n                }\n            };\n        ","\n        \nclass Solution {\n    public:\n        int calculate(string s) {\n            string post;\n            string stack;\n            int n=s.size(),top=0;\n            for(int i=0;i<n;i++)\n            {\n                if(s[i]<='9'&&s[i]>='0')\n                {\n                    while(i<n&&s[i]<='9'&&s[i]>='0')\n                    {\n                        post.push_back(s[i]);\n                        i++;\n                    }i--;\n                    post.push_back('#');\n                }\n                else if(s[i]=='(')\n                {\n                    stack.push_back('(');top++;\n                }               \n                else if(s[i]==')')\n                {\n                    \n                    while(top>0&&stack[top-1]!='(')\n                    {\n                        post.push_back(stack[top-1]);\n                        stack.pop_back();\n                        top--;\n                    }\n                }  \n                else if(s[i]=='+'||s[i]=='-')\n                {\n                    while(top>0&&stack[top-1]!='(')\n                    {\n                        post.push_back(stack[top-1]);\n                        stack.pop_back();\n                        top--;\n                    }\n                    stack.push_back(s[i]);top++;\n                }  \n                else if(s[i]=='/'||s[i]=='*')\n                {\n                    while(top>0&&stack[top-1]!='('&&stack[top-1]!='+'&&stack[top-1]!='-')\n                    {\n                        post.push_back(stack[top-1]);\n                        stack.pop_back();\n                        top--;\n                    }\n                    stack.push_back(s[i]);top++;\n                }\n            }\n            while(top>0)\n            {\n                post.push_back(stack[top-1]);\n                stack.pop_back();\n                top--;\n            }\n            vector<double>num;\n            top=0;\n            n=post.size();\n            for(int i=0;i<n;i++)\n            {\n                if(post[i]<='9'&&post[i]>='0')\n                {\n                    double sum=0;\n                    while(i<n&&post[i]<='9'&&post[i]>='0')\n                    {\n                        sum=sum*10+post[i]-'0';i++;\n                    }i--;\n                    num.push_back(sum);\n                    top++;\n                }\n                else if(top>=2)\n                {\n                    if(post[i]=='+')\n                    {\n                        int a=num[top-1];num.pop_back();\n                        int b=num[top-2];num.pop_back();\n                        num.push_back(a+b);top--;\n                    }\n                    else if(post[i]=='-')\n                    {\n                        int a=num[top-1];num.pop_back();\n                        int b=num[top-2];num.pop_back();\n                        num.push_back(b-a);top--;\n                    }\n                    else if(post[i]=='*')\n                    {\n                        int a=num[top-1];num.pop_back();\n                        int b=num[top-2];num.pop_back();\n                        num.push_back(b*a);top--;\n                    }\n                    else if(post[i]=='/')\n                    {\n                        int a=num[top-1];num.pop_back();\n                        int b=num[top-2];num.pop_back();\n                        num.push_back(b/a);top--;\n                    }\n                }\n            }\n            return num[0];\n        }\n    };\n        "]
    },
    {
        "id":129,
        "description":"\n        You are given a sorted unique integer array nums.\n\nA range [a,b] is the set of all integers from a to b (inclusive).\n\nReturn the smallest sorted list of ranges that cover all the numbers in the array exactly. That is, each element of nums is covered by exactly one of the ranges, and there is no integer x such that x is in one of the ranges but not in nums.\n\nEach range [a,b] in the list should be output as:\n\n\"a->b\" if a != b\n\"a\" if a == b\n \n\nExample 1:\n\nInput: nums = [0,1,2,4,5,7]\nOutput: [\"0->2\",\"4->5\",\"7\"]\nExplanation: The ranges are:\n[0,2] --> \"0->2\"\n[4,5] --> \"4->5\"\n[7,7] --> \"7\"\nExample 2:\n\nInput: nums = [0,2,3,4,6,8,9]\nOutput: [\"0\",\"2->4\",\"6\",\"8->9\"]\nExplanation: The ranges are:\n[0,0] --> \"0\"\n[2,4] --> \"2->4\"\n[6,6] --> \"6\"\n[8,9] --> \"8->9\"\n \n\nConstraints:\n\n0 <= nums.length <= 20\n-2^31 <= nums[i] <= 2^31 - 1\nAll the values of nums are unique.\nnums is sorted in ascending order.\n        ",
        "tag":["Array"],
        "answer":["\n        class Solution {\n            public:\n                vector<string> summaryRanges(vector<int>& nums) {\n                    vector<string> ret;\n                    int i = 0;\n                    int n = nums.size();\n                    while (i < n) {\n                        int low = i;\n                        i++;\n                        while (i < n && nums[i] == nums[i - 1] + 1) {\n                            i++;\n                        }\n                        int high = i - 1;\n                        string temp = to_string(nums[low]);\n                        if (low < high) {\n                            temp.append(\"->\");\n                            temp.append(to_string(nums[high]));\n                        }\n                        ret.push_back(move(temp));\n                    }\n                    return ret;\n                }\n            };\n        ","\n        class Solution {\n            vector<string> summaryRanges(vector<int>& nums) {\n                int l = 0, r = 1;\n                vector<string> ans;\n                while(r < nums.size()) {\n                    while(r < nums.size() && (long long)nums[r] - nums[r-1] == 1) r++;\n                    if(r - l == 1) ans.push_back({to_string(nums[l])});\n                    else ans.push_back({to_string(nums[l])+\"->\"+to_string(nums[r-1])});\n                    l = r++;\n                }\n                if(nums.size() == r) ans.push_back({to_string(nums[l])});\n                return ans;\n            }\n        };\n        ","\n        \nclass Solution {\n    public:\n        vector<string> summaryRanges(vector<int>& nums) {\n            int n = nums.size();\n            vector<string> ans;\n            if(n == 0) {\n                return {};\n            }\n            int l = 0;\n            while(l < n) {\n                string s;\n                int r = l + 1;\n                if(r == n) {\n                    s = to_string(nums[l]);\n                    ans.push_back(s);\n                    break;\n                }\n                while(r < n && nums[r] == nums[r - 1] + 1) {\n                    ++r;\n                }\n                if(r == l + 1) {\n                    s = to_string(nums[l]);\n                } \n                if(r > l + 1) {\n                    s += to_string(nums[l]) + \"->\" + to_string(nums[r - 1]);\n                }\n                l = r;\n                ans.push_back(s);\n            }\n            return ans;\n        }\n    };\n        "]
    },
    {
        "id":130,
        "description":"\n        Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.\n\n \n\nExample 1:\n\nInput: nums = [3,2,3]\nOutput: [3]\nExample 2:\n\nInput: nums = [1]\nOutput: [1]\nExample 3:\n\nInput: nums = [1,2]\nOutput: [1,2]\n \n\nConstraints:\n\n1 <= nums.length <= 5 * 10^4\n-10^9 <= nums[i] <= 10^9\n        ",
        "tag":["Array","Hash Table","Counting","Sorting"],
        "answer":["\n        class Solution {\n            public:\n                vector<int> majorityElement(vector<int>& nums) {\n                    int n = nums.size();\n                    vector<int> ans;\n                    unordered_map<int, int> cnt;\n            \n                    for (auto & v : nums) {\n                        cnt[v]++;\n                    }\n                    for (auto & v : cnt) {\n                        if (v.second > n / 3) {\n                            ans.push_back(v.first);\n                        }\n                    }\n            \n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<int> majorityElement(vector<int>& nums) {\n                    vector<int> ans;\n                    int element1 = 0;\n                    int element2 = 0;\n                    int vote1 = 0;\n                    int vote2 = 0;\n            \n                    for (auto & num : nums) {\n                        if (vote1 > 0 && num == element1) { //如果该元素为第一个元素，则计数加1\n                            vote1++;\n                        } else if (vote2 > 0 && num == element2) { //如果该元素为第二个元素，则计数加1\n                            vote2++;\n                        } else if (vote1 == 0) { // 选择第一个元素\n                            element1 = num;\n                            vote1++;\n                        } else if (vote2 == 0) { // 选择第二个元素\n                            element2 = num;\n                            vote2++;\n                        } else { //如果三个元素均不相同，则相互抵消1次\n                            vote1--;\n                            vote2--;\n                        }\n                    }\n            \n                    int cnt1 = 0;\n                    int cnt2 = 0;\n                    for (auto & num : nums) {\n                        if (vote1 > 0 && num == element1) {\n                            cnt1++;\n                        }\n                        if (vote2 > 0 && num == element2) {\n                            cnt2++;\n                        }\n                    }\n                    // 检测元素出现的次数是否满足要求\n                    if (vote1 > 0 && cnt1 > nums.size() / 3) {\n                        ans.push_back(element1);\n                    }\n                    if (vote2 > 0 && cnt2 > nums.size() / 3) {\n                        ans.push_back(element2);\n                    }\n            \n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int cnt_a = 0;\n                int cnt_b = 0;\n                int a = INT_MIN;\n                int b = INT_MIN;\n            \n                inline bool check(vector<int>& nums, int target) {\n                    int cnt = 0;\n                    for (auto n: nums) {\n                        if (target == n) {\n                            cnt++;\n                        }\n                    }\n                    if (cnt > nums.size()/3 ) return true;\n                    return false;\n                }\n            \n                vector<int> majorityElement(vector<int>& nums) {\n                    for (auto n: nums) {\n                        if (a == n) { cnt_a++; continue; }\n                        if (b == n) { cnt_b++; continue; }\n                        if (a == INT_MIN) { cnt_a++; a = n; continue; }\n                        if (b == INT_MIN) { cnt_b++; b = n; continue; }\n                        cnt_a--;\n                        cnt_b--;\n                        if (cnt_a == 0) { a = INT_MIN; }\n                        if (cnt_b == 0) { b = INT_MIN; }\n                    }\n                    cout << a << \" \" << cnt_a << endl;\n                    cout << b << \" \" << cnt_b << endl;\n            \n                    vector<int> ans;\n                    if (check(nums, a)) ans.push_back(a);\n                    if (check(nums, b)) ans.push_back(b);\n            \n                    return ans;\n                }\n            };\n        "]
    },
    {
        "id":131,
        "description":"\n        Given an integer n, return true if it is a power of two. Otherwise, return false.\n\nAn integer n is a power of two, if there exists an integer x such that n == 2^x.\n\n \n\nExample 1:\n\nInput: n = 1\nOutput: true\nExplanation: 2^0 = 1\nExample 2:\n\nInput: n = 16\nOutput: true\nExplanation: 2^4 = 16\nExample 3:\n\nInput: n = 3\nOutput: false\n \n\nConstraints:\n\n-2^31 <= n <= 2^31 - 1\n        ",
        "tag":["Bit Manipulation","Recursion","Math"],
        "answer":["\n        class Solution {\n            public:\n                bool isPowerOfTwo(int n) {\n                    return n > 0 && (n & (n - 1)) == 0;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool isPowerOfTwo(int n) {\n                    return n > 0 && (n & -n) == n;\n                }\n            };\n        ","\n        class Solution {\n            private:\n                static constexpr int BIG = 1 << 30;\n            \n            public:\n                bool isPowerOfTwo(int n) {\n                    return n > 0 && BIG % n == 0;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool isPowerOfTwo(int n) {\n                    return n > 0 && __builtin_popcount(n) == 1;\n                }\n            };\n        "]
    },
    {
        "id":132,
        "description":"\n        Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).\n\nImplement the MyQueue class:\n\nvoid push(int x) Pushes element x to the back of the queue.\nint pop() Removes the element from the front of the queue and returns it.\nint peek() Returns the element at the front of the queue.\nboolean empty() Returns true if the queue is empty, false otherwise.\nNotes:\n\nYou must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid.\nDepending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations.\n \n\nExample 1:\n\nInput\n[\"MyQueue\", \"push\", \"push\", \"peek\", \"pop\", \"empty\"]\n[[], [1], [2], [], [], []]\nOutput\n[null, null, null, 1, 1, false]\n\nExplanation\nMyQueue myQueue = new MyQueue();\nmyQueue.push(1); // queue is: [1]\nmyQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)\nmyQueue.peek(); // return 1\nmyQueue.pop(); // return 1, queue is [2]\nmyQueue.empty(); // return false\n \n\nConstraints:\n\n1 <= x <= 9\nAt most 100 calls will be made to push, pop, peek, and empty.\nAll the calls to pop and peek are valid.\n        ",
        "tag":["Stack","Design","Queue"],
        "answer":["\n        class MyQueue {\n            private:\n                stack<int> inStack, outStack;\n            \n                void in2out() {\n                    while (!inStack.empty()) {\n                        outStack.push(inStack.top());\n                        inStack.pop();\n                    }\n                }\n            \n            public:\n                MyQueue() {}\n            \n                void push(int x) {\n                    inStack.push(x);\n                }\n            \n                int pop() {\n                    if (outStack.empty()) {\n                        in2out();\n                    }\n                    int x = outStack.top();\n                    outStack.pop();\n                    return x;\n                }\n            \n                int peek() {\n                    if (outStack.empty()) {\n                        in2out();\n                    }\n                    return outStack.top();\n                }\n            \n                bool empty() {\n                    return inStack.empty() && outStack.empty();\n                }\n            };\n        ","\n        class MyQueue {\n            private:\n                stack<int> inStack, outStack;\n            \n                void in2out() {\n                    while (!inStack.empty()) {\n                        outStack.push(inStack.top());\n                        inStack.pop();\n                    }\n                }\n            \n            public:\n                MyQueue() {}\n            \n                void push(int x) {\n                    inStack.push(x);\n                }\n            \n                int pop() {\n                    if (outStack.empty()) {\n                        in2out();\n                    }\n                    int x = outStack.top();\n                    outStack.pop();\n                    return x;\n                }\n            \n                int peek() {\n                    if (outStack.empty()) {\n                        in2out();\n                    }\n                    return outStack.top();\n                }\n            \n                bool empty() {\n                    return inStack.empty() && outStack.empty();\n                }\n            };\n        ","\n        class CQueue {\n            public:\n                /* 定义两个栈用于模拟队列 */\n                stack<int> stIn;\n                stack<int> stOut;\n                /* 构造函数清空栈 */\n                CQueue() {\n                    while(!stIn.empty()) {\n                        stIn.pop();        \n                    }\n                    while(!stOut.empty()) {\n                        stOut.pop();        \n                    }\n                }\n                \n                void appendTail(int value) {\n                    stIn.push(value);\n                }\n                \n                int deleteHead() {\n                    /* 只有当输出栈为空的情况下才将输入栈的数据全部导入到输出栈 */\n                    if(stOut.empty()) {\n                        while(!stIn.empty()) {\n                            stOut.push(stIn.top());\n                            stIn.pop();\n                        }\n                    }\n                    /* 如果栈为空输出-1 */\n                    if (stOut.empty()) {\n                        return -1;\n                    }\n                    else {\n                        /* 输出栈获取输出的元素值 */\n                        int result = stOut.top();\n                        /* 获取值后将此元素弹出 */\n                        stOut.pop();\n                        return result;\n                    }\n                }\n            };\n        ","\n        class MyQueue {\n            public:\n                stack<int> stIn;\n                stack<int> stOut;\n                /** Initialize your data structure here. */\n                MyQueue() {\n            \n                }\n                /** Push element x to the back of queue. */\n                void push(int x) {\n                    stIn.push(x);\n                }\n            \n                /** Removes the element from in front of queue and returns that element. */\n                int pop() {\n                    // 只有当stOut为空的时候，再从stIn里导入数据（导入stIn全部数据）\n                    if (stOut.empty()) {\n                        // 从stIn导入数据直到stIn为空\n                        while(!stIn.empty()) {\n                            stOut.push(stIn.top());\n                            stIn.pop();\n                        }\n                    }\n                    int result = stOut.top();\n                    stOut.pop();\n                    return result;\n                }\n            \n                /** Get the front element. */\n                int peek() {\n                    int res = this->pop(); // 直接使用已有的pop函数\n                    stOut.push(res); // 因为pop函数弹出了元素res，所以再添加回去\n                    return res;\n                }\n            \n                /** Returns whether the queue is empty. */\n                bool empty() {\n                    return stIn.empty() && stOut.empty();\n                }\n            };\n        "]
    },
    {
        "id":133,
        "description":"\n        Given an integer n, count the total number of digit 1 appearing in all non-negative integers less than or equal to n.\n\n \n\nExample 1:\n\nInput: n = 13\nOutput: 6\nExample 2:\n\nInput: n = 0\nOutput: 0\n \n\nConstraints:\n\n0 <= n <= 10^9\n        ",
        "tag":["Recursion","Math","Dynamic Programming"],
        "answer":["\n        class Solution {\n            public:\n                int countDigitOne(int n) {\n                    // mulk 表示 10^k\n                    // 在下面的代码中，可以发现 k 并没有被直接使用到（都是使用 10^k）\n                    // 但为了让代码看起来更加直观，这里保留了 k\n                    long long mulk = 1;\n                    int ans = 0;\n                    for (int k = 0; n >= mulk; ++k) {\n                        ans += (n / (mulk * 10)) * mulk + min(max(n % (mulk * 10) - mulk + 1, 0LL), mulk);\n                        mulk *= 10;\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int countDigitOne(int n) {\n                    auto s = to_string(n);\n                    int m = s.length(), dp[m][m];\n                    memset(dp, -1, sizeof(dp));\n                    function<int(int, int, bool)> f = [&](int i, int cnt1, bool is_limit) -> int {\n                        if (i == m) return cnt1;\n                        if (!is_limit && dp[i][cnt1] >= 0) return dp[i][cnt1];\n                        int res = 0;\n                        for (int d = 0, up = is_limit ? s[i] - '0' : 9; d <= up; ++d) // 枚举要填入的数字 d\n                            res += f(i + 1, cnt1 + (d == 1), is_limit && d == up);\n                        if (!is_limit) dp[i][cnt1] = res;\n                        return res;\n                    };\n                    return f(0, 0, true);\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int countDigitOne(int n) {\n                    unsigned i = 1, ans = 0, befor = 0; //i表示记录到了第几位，ans是总和，befor身后的数字\n                    while(n){\n                        int tmp = n % 10;  //记录这个位置是什么\n                        n /= 10;    //n此时是这个位置前面的数字\n                        if(tmp > 1) ans += (n + 1) * i; //如果这个位置大于1，前面的位置有n+1种取法\n                        else if(tmp == 1) ans += n * i + befor + 1; //等于1，前面的位置有n+1种取法，\n                        else ans += n * i;  //这个位置是0，则只有n种取法\n                        befor += tmp * i;  //记录身后的数字\n                        i *= 10;   //往下一位\n                    }\n                    return ans;\n                }\n            };\n        "]
    },
    {
        "id":134,
        "description":"\n        Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\n\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\n\nYou must write an algorithm that runs in O(n) time and without using the division operation.\n\n \n\nExample 1:\n\nInput: nums = [1,2,3,4]\nOutput: [24,12,8,6]\nExample 2:\n\nInput: nums = [-1,1,0,-3,3]\nOutput: [0,0,9,0,0]\n \n\nConstraints:\n\n2 <= nums.length <= 10^5\n-30 <= nums[i] <= 30\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\n        ",
        "tag":["Array","Prefix Sum"],
        "answer":["\n        class Solution {\n            public:\n                vector<int> productExceptSelf(vector<int>& nums) {\n                    int length = nums.size();\n            \n                    // L 和 R 分别表示左右两侧的乘积列表\n                    vector<int> L(length, 0), R(length, 0);\n            \n                    vector<int> answer(length);\n            \n                    // L[i] 为索引 i 左侧所有元素的乘积\n                    // 对于索引为 '0' 的元素，因为左侧没有元素，所以 L[0] = 1\n                    L[0] = 1;\n                    for (int i = 1; i < length; i++) {\n                        L[i] = nums[i - 1] * L[i - 1];\n                    }\n            \n                    // R[i] 为索引 i 右侧所有元素的乘积\n                    // 对于索引为 'length-1' 的元素，因为右侧没有元素，所以 R[length-1] = 1\n                    R[length - 1] = 1;\n                    for (int i = length - 2; i >= 0; i--) {\n                        R[i] = nums[i + 1] * R[i + 1];\n                    }\n            \n                    // 对于索引 i，除 nums[i] 之外其余各元素的乘积就是左侧所有元素的乘积乘以右侧所有元素的乘积\n                    for (int i = 0; i < length; i++) {\n                        answer[i] = L[i] * R[i];\n                    }\n            \n                    return answer;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<int> productExceptSelf(vector<int>& nums) {\n                    int length = nums.size();\n                    vector<int> answer(length);\n            \n                    // answer[i] 表示索引 i 左侧所有元素的乘积\n                    // 因为索引为 '0' 的元素左侧没有元素， 所以 answer[0] = 1\n                    answer[0] = 1;\n                    for (int i = 1; i < length; i++) {\n                        answer[i] = nums[i - 1] * answer[i - 1];\n                    }\n            \n                    // R 为右侧所有元素的乘积\n                    // 刚开始右边没有元素，所以 R = 1\n                    int R = 1;\n                    for (int i = length - 1; i >= 0; i--) {\n                        // 对于索引 i，左边的乘积为 answer[i]，右边的乘积为 R\n                        answer[i] = answer[i] * R;\n                        // R 需要包含右边所有的乘积，所以计算下一个结果时需要将当前值乘到 R 上\n                        R *= nums[i];\n                    }\n                    return answer;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<int> productExceptSelf(vector<int>& nums) {\n                    vector<int> before(nums.size());\n                    before[0] = nums[0];\n                    vector<int> after(nums.size());\n                    after[nums.size()-1] = nums[nums.size()-1];\n                    for(int i = 1;i < nums.size();++i){\n                        before[i] = before[i-1]*nums[i];\n                    }\n                    for(int j = nums.size()-2;j >= 0;--j){\n                        after[j] = after[j+1]*nums[j];\n                    }\n                    vector<int> res(nums.size());\n                    res[0] = after[1];\n                    res[nums.size()-1] = before[nums.size()-2];\n                    for(int i = 1;i < nums.size()-1;++i){\n                        res[i] = before[i-1]*after[i+1];\n                    }\n                    return res;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<int> productExceptSelf(vector<int>& nums) {\n                    vector<int> res(nums.size(), 1);\n                    int left = 1, right = 1;\n                    for (int i = 0, j = nums.size() - 1; i < nums.size(); i ++, j --) {\n                        res[i] *= left; res[j] *= right;\n                        left *= nums[i]; right *= nums[j];\n                    }\n                    return res;\n                }\n            };\n        "]
    },
    {
        "id":135,
        "description":"\n        You are given an array of integers nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position.\n\nReturn the max sliding window.\n\n \n\nExample 1:\n\nInput: nums = [1,3,-1,-3,5,3,6,7], k = 3\nOutput: [3,3,5,5,6,7]\nExplanation: \nWindow position                Max\n---------------               -----\n[1  3  -1] -3  5  3  6  7       3\n 1 [3  -1  -3] 5  3  6  7       3\n 1  3 [-1  -3  5] 3  6  7       5\n 1  3  -1 [-3  5  3] 6  7       5\n 1  3  -1  -3 [5  3  6] 7       6\n 1  3  -1  -3  5 [3  6  7]      7\nExample 2:\n\nInput: nums = [1], k = 1\nOutput: [1]\n \n\nConstraints:\n\n1 <= nums.length <= 10^5\n-10^4 <= nums[i] <= 10^4\n1 <= k <= nums.length\n        ",
        "tag":["Queue","Array","Sliding Window","Monotonic Queue","Heap (Priority Queue)"],
        "answer":["\n        class Solution {\n            public:\n                vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n                    int n = nums.size();\n                    priority_queue<pair<int, int>> q;\n                    for (int i = 0; i < k; ++i) {\n                        q.emplace(nums[i], i);\n                    }\n                    vector<int> ans = {q.top().first};\n                    for (int i = k; i < n; ++i) {\n                        q.emplace(nums[i], i);\n                        while (q.top().second <= i - k) {\n                            q.pop();\n                        }\n                        ans.push_back(q.top().first);\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n                    int n = nums.size();\n                    deque<int> q;\n                    for (int i = 0; i < k; ++i) {\n                        while (!q.empty() && nums[i] >= nums[q.back()]) {\n                            q.pop_back();\n                        }\n                        q.push_back(i);\n                    }\n            \n                    vector<int> ans = {nums[q.front()]};\n                    for (int i = k; i < n; ++i) {\n                        while (!q.empty() && nums[i] >= nums[q.back()]) {\n                            q.pop_back();\n                        }\n                        q.push_back(i);\n                        while (q.front() <= i - k) {\n                            q.pop_front();\n                        }\n                        ans.push_back(nums[q.front()]);\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<int> maxSlidingWindow(vector<int>& nums, int k) {\n                    int n = nums.size();\n                    vector<int> prefixMax(n), suffixMax(n);\n                    for (int i = 0; i < n; ++i) {\n                        if (i % k == 0) {\n                            prefixMax[i] = nums[i];\n                        }\n                        else {\n                            prefixMax[i] = max(prefixMax[i - 1], nums[i]);\n                        }\n                    }\n                    for (int i = n - 1; i >= 0; --i) {\n                        if (i == n - 1 || (i + 1) % k == 0) {\n                            suffixMax[i] = nums[i];\n                        }\n                        else {\n                            suffixMax[i] = max(suffixMax[i + 1], nums[i]);\n                        }\n                    }\n            \n                    vector<int> ans;\n                    for (int i = 0; i <= n - k; ++i) {\n                        ans.push_back(max(suffixMax[i], prefixMax[i + k - 1]));\n                    }\n                    return ans;\n                }\n            };\n        "]
    },
    {
        "id":136,
        "description":"\n        Given a string expression of numbers and operators, return all possible results from computing all the different possible ways to group numbers and operators. You may return the answer in any order.\n\nThe test cases are generated such that the output values fit in a 32-bit integer and the number of different results does not exceed 10^4.\n\n \n\nExample 1:\n\nInput: expression = \"2-1-1\"\nOutput: [0,2]\nExplanation:\n((2-1)-1) = 0 \n(2-(1-1)) = 2\nExample 2:\n\nInput: expression = \"2*3-4*5\"\nOutput: [-34,-14,-10,-10,10]\nExplanation:\n(2*(3-(4*5))) = -34 \n((2*3)-(4*5)) = -14 \n((2*(3-4))*5) = -10 \n(2*((3-4)*5)) = -10 \n(((2*3)-4)*5) = 10\n \n\nConstraints:\n\n1 <= expression.length <= 20\nexpression consists of digits and the operator '+', '-', and '*'.\nAll the integer values in the input expression are in the range [0, 99].\n        ",
        "tag":["Recursion","Memoization","Math","String","Dynamic Programming"],
        "answer":["\n        class Solution {\n            public:\n                const int ADDITION = -1;\n                const int SUBTRACTION = -2;\n                const int MULTIPLICATION = -3;\n            \n                vector<int> dfs(vector<vector<vector<int>>>& dp, int l, int r, const vector<int>& ops) {\n                    if (dp[l][r].empty()) {\n                        if (l == r) {\n                            dp[l][r].push_back(ops[l]);\n                        } else {\n                            for (int i = l; i < r; i += 2) {\n                                auto left = dfs(dp, l, i, ops);\n                                auto right = dfs(dp, i + 2, r, ops);\n                                for (auto& lv : left) {\n                                    for (auto& rv : right) {\n                                        if (ops[i + 1] == ADDITION) {\n                                            dp[l][r].push_back(lv + rv);\n                                        } else if (ops[i + 1] == SUBTRACTION) {\n                                            dp[l][r].push_back(lv - rv);\n                                        } else {\n                                            dp[l][r].push_back(lv * rv);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    return dp[l][r];\n                }\n            \n                vector<int> diffWaysToCompute(string expression) {\n                    vector<int> ops;\n                    for (int i = 0; i < expression.size();) {\n                        if (!isdigit(expression[i])) {\n                            if (expression[i] == '+') {\n                                ops.push_back(ADDITION);\n                            } else if (expression[i] == '-') {\n                                ops.push_back(SUBTRACTION);\n                            } else {\n                                ops.push_back(MULTIPLICATION);\n                            }\n                            i++;\n                        } else {\n                            int t = 0;\n                            while (i < expression.size() && isdigit(expression[i])) {\n                                t = t * 10 + expression[i] - '0';\n                                i++;\n                            }\n                            ops.push_back(t);\n                        }\n                    }\n                    vector<vector<vector<int>>> dp((int) ops.size(), vector<vector<int>>((int) ops.size()));\n                    return dfs(dp, 0, ops.size() - 1, ops);\n                }\n            };\n        ","\n        class Solution {\n            public:\n                const int ADDITION = -1;\n                const int SUBTRACTION = -2;\n                const int MULTIPLICATION = -3;\n            \n                vector<int> diffWaysToCompute(string expression) {\n                    vector<int> ops;\n                    for (int i = 0; i < expression.size();) {\n                        if (!isdigit(expression[i])) {\n                            if (expression[i] == '+') {\n                                ops.push_back(ADDITION);\n                            } else if (expression[i] == '-') {\n                                ops.push_back(SUBTRACTION);\n                            } else {\n                                ops.push_back(MULTIPLICATION);\n                            }\n                            i++;\n                        } else {\n                            int t = 0;\n                            while (i < expression.size() && isdigit(expression[i])) {\n                                t = t * 10 + expression[i] - '0';\n                                i++;\n                            }\n                            ops.push_back(t);\n                        }\n                    }\n                    vector<vector<vector<int>>> dp((int) ops.size(), vector<vector<int>>((int) ops.size()));\n                    for (int i = 0; i < ops.size(); i += 2) {\n                        dp[i][i] = {ops[i]};\n                    }\n                    for (int i = 3; i <= ops.size(); i++) {\n                        for (int j = 0; j + i <= ops.size(); j += 2) {\n                            int l = j;\n                            int r = j + i - 1;\n                            for (int k = j + 1; k < r; k += 2) {\n                                auto& left = dp[l][k - 1];\n                                auto& right = dp[k + 1][r];\n                                for (auto& num1 : left) {\n                                    for (auto& num2 : right) {\n                                        if (ops[k] == ADDITION) {\n                                            dp[l][r].push_back(num1 + num2);\n                                        }\n                                        else if (ops[k] == SUBTRACTION) {\n                                            dp[l][r].push_back(num1 - num2);\n                                        }\n                                        else if (ops[k] == MULTIPLICATION) {\n                                            dp[l][r].push_back(num1 * num2);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    return dp[0][(int) ops.size() - 1];\n                }\n            };\n        ","\n        class Solution {\n            public:\n                unordered_map<string,vector<int>> memo; \n                vector<int> diffWaysToCompute(string s) {\n                    if(memo.find(s)!=memo.end())//之前计算过这个算式了,直接返回\n                        return memo[s];\n                    if(s.find_first_of(\"+-*\")==s.npos)//字符串是纯数字,直接转化返回\n                        return {stoi(s)};\n                    vector<int> ans;\n                    int pos=0;\n                    while((pos=s.find_first_of(\"+-*\",pos+1))!=s.npos)//找到所有运算符并分左右进行计算\n                    {\n                        vector<int> left=diffWaysToCompute(s.substr(0,pos)),right=diffWaysToCompute(s.substr(pos+1));\n                        for(int l:left)//左右两侧结果排列组合\n                            for(int r:right)\n                                ans.push_back(s[pos]=='+'?l+r:s[pos]=='-'?l-r:l*r);//根据运算符存结果\n                    }\n                    memo[s]=ans;//存备忘录\n                    return memo[s];//返回结果\n                }\n            };\n        "]
    },
    {
        "id":137,
        "description":"\n        Given two strings s and t, return true if t is an anagram of s, and false otherwise.\n\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\n \n\nExample 1:\n\nInput: s = \"anagram\", t = \"nagaram\"\nOutput: true\nExample 2:\n\nInput: s = \"rat\", t = \"car\"\nOutput: false\n \n\nConstraints:\n\n1 <= s.length, t.length <= 5 * 10^4\ns and t consist of lowercase English letters.\n        ",
        "tag":["Hash Table","String","Sorting"],
        "answer":["\n        class Solution {\n            public:\n                bool isAnagram(string s, string t) {\n                    if (s.length() != t.length()) {\n                        return false;\n                    }\n                    sort(s.begin(), s.end());\n                    sort(t.begin(), t.end());\n                    return s == t;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool isAnagram(string s, string t) {\n                    if (s.length() != t.length()) {\n                        return false;\n                    }\n                    vector<int> table(26, 0);\n                    for (auto& ch: s) {\n                        table[ch - 'a']++;\n                    }\n                    for (auto& ch: t) {\n                        table[ch - 'a']--;\n                        if (table[ch - 'a'] < 0) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool isAnagram(string s, string t) {\n                    int diffs[26] = {0};    // 统计s中每个字符的待匹配数量\n                    int charDiffs = 0;      // 统计s有多少种字符\n                    int chId;\n                    for(auto ch: s){\n                        chId = ch - 'a';    // 获取s当前字符对应的编号\n                        if(diffs[chId] == 0)charDiffs++;    // 当前字符首次出现，即是一种新字符，种数累加\n                        diffs[chId]++;  // 当前字符个数加一\n                    }\n                    for(auto ch: t){\n                        chId = ch - 'a';    // 获取t当前字符对应的编号\n                        if(diffs[chId] == 0)return false;   // 当前字符在s中已经匹配完了，再出现这个字符说明t中的这个字符多了，即不匹配\n                        diffs[chId]--;      // 当前字符待匹配数量减一\n                        if(diffs[chId] == 0)charDiffs--;    // 如果一个字符的待匹配数量变为0，说明完成了一种字符的匹配，待匹配字符数量减一\n                    }\n                    return charDiffs == 0;      // 待匹配字符为0说明s中的所有字符匹配完，二者为异位词\n                }\n            };\n        "]
    },
    {
        "id":138,
        "description":"\n        Given an integer num, repeatedly add all its digits until the result has only one digit, and return it.\n\n \n\nExample 1:\n\nInput: num = 38\nOutput: 2\nExplanation: The process is\n38 --> 3 + 8 --> 11\n11 --> 1 + 1 --> 2 \nSince 2 has only one digit, return it.\nExample 2:\n\nInput: num = 0\nOutput: 0\n \n\nConstraints:\n\n0 <= num <= 2^31 - 1\n        ",
        "tag":["Math","Number Theory","Simulation"],
        "answer":["\n        class Solution {\n            public:\n                int addDigits(int num) {\n                    while (num >= 10) {\n                        int sum = 0;\n                        while (num > 0) {\n                            sum += num % 10;\n                            num /= 10;\n                        }\n                        num = sum;\n                    }\n                    return num;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int addDigits(int num) {\n                    return (num - 1) % 9 + 1;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int addDigits(int num) {\n                    // method1:\n                    return (num-1)%9+1;\n            \n                    // method2:\n                    if (num == 0) return 0;\n                    int sum = 0;\n                    while (num) {\n                        sum += num % 10;\n                        num /= 10;\n                    }\n                    return sum % 9 != 0 ? sum % 9 : 9;\n                }\n            };\n        "]
    },
    {
        "id":139,
        "description":"\n        Given an integer array nums, in which exactly two elements appear only once and all the other elements appear exactly twice. Find the two elements that appear only once. You can return the answer in any order.\n\nYou must write an algorithm that runs in linear runtime complexity and uses only constant extra space.\n\n \n\nExample 1:\n\nInput: nums = [1,2,1,3,2,5]\nOutput: [3,5]\nExplanation:  [5, 3] is also a valid answer.\nExample 2:\n\nInput: nums = [-1,0]\nOutput: [-1,0]\nExample 3:\n\nInput: nums = [0,1]\nOutput: [1,0]\n \n\nConstraints:\n\n2 <= nums.length <= 3 * 10^4\n-2^31 <= nums[i] <= 2^31 - 1\nEach integer in nums will appear twice, only two integers will appear once.\n        ",
        "tag":["Bit Manipulation","Array"],
        "answer":["\n        class Solution {\n            public:\n                vector<int> singleNumber(vector<int>& nums) {\n                    unordered_map<int, int> freq;\n                    for (int num: nums) {\n                        ++freq[num];\n                    }\n                    vector<int> ans;\n                    for (const auto& [num, occ]: freq) {\n                        if (occ == 1) {\n                            ans.push_back(num);\n                        }\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<int> singleNumber(vector<int>& nums) {\n                    int xorsum = 0;\n                    for (int num: nums) {\n                        xorsum ^= num;\n                    }\n                    // 防止溢出\n                    int lsb = (xorsum == INT_MIN ? xorsum : xorsum & (-xorsum));\n                    int type1 = 0, type2 = 0;\n                    for (int num: nums) {\n                        if (num & lsb) {\n                            type1 ^= num;\n                        }\n                        else {\n                            type2 ^= num;\n                        }\n                    }\n                    return {type1, type2};\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<int> singleNumber(vector<int>& nums) {\n                    int diff = 0;\n                    for(int num : nums) diff ^= num;\n                    // 防止溢出\n                    diff = (diff == INT_MIN) ? 1 : diff & (-diff);//得到最低那一位1\n                    vector<int> ans(2);\n                    for(int num : nums){\n                        if((num & diff) == diff){\n                            ans[0] ^= num;\n                        }else{\n                            ans[1] ^= num;\n                        }\n                    }\n                    return ans;\n                }\n            };\n        "]
    },
    {
        "id":140,
        "description":"\n        An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\n\nGiven an integer n, return true if n is an ugly number.\n\n \n\nExample 1:\n\nInput: n = 6\nOutput: true\nExplanation: 6 = 2 × 3\nExample 2:\n\nInput: n = 1\nOutput: true\nExplanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.\nExample 3:\n\nInput: n = 14\nOutput: false\nExplanation: 14 is not ugly since it includes the prime factor 7.\n \n\nConstraints:\n\n-2^31 <= n <= 2^31 - 1\n        ",
        "tag":["Math"],
        "answer":["\n        class Solution {\n            public:\n                bool isUgly(int n) {\n                    if (n <= 0) {\n                        return false;\n                    }\n                    vector<int> factors = {2, 3, 5};\n                    for (int factor : factors) {\n                        while (n % factor == 0) {\n                            n /= factor;\n                        }\n                    }\n                    return n == 1;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool isUgly(int n) {\n                    while(n)\n                    {\n                        if(n%2 == 0) n /= 2;\n                        else if(n%3 == 0) n /= 3;\n                        else if(n%5 == 0) n /= 5;\n                        else break;\n                    }\n                    return n == 1;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool isUgly(int num) {\n                    if (num == 0) return false; // 特别判断\n                    while (true) {\n                        if (num == 1) return true; // 当num等于1时，代表这个数的质因数只包含2,3,5。那么为true\n                        if (num % 2 == 0) num /= 2; // 如果num中含有2的质因数，那么把它抽出来\n                        else if (num % 3 == 0) num /= 3; // 如果num中含有3的质因数，那么把它抽出来\n                        else if (num % 5 == 0) num /= 5; // 如果num中含有5的质因数，那么把它抽出来\n                        else return false; // 不是丑数，返回false\n                    }\n                }\n            };\n        "]
    },
    {
        "id":141,
        "description":"\n        An ugly number is a positive integer whose prime factors are limited to 2, 3, and 5.\n\nGiven an integer n, return the n^th ugly number.\n\n \n\nExample 1:\n\nInput: n = 10\nOutput: 12\nExplanation: [1, 2, 3, 4, 5, 6, 8, 9, 10, 12] is the sequence of the first 10 ugly numbers.\nExample 2:\n\nInput: n = 1\nOutput: 1\nExplanation: 1 has no prime factors, therefore all of its prime factors are limited to 2, 3, and 5.\n \n\nConstraints:\n\n1 <= n <= 1690\n        ",
        "tag":["Hash Table","Math","Dynamic Programming","Heap (Priority Queue)"],
        "answer":["\n        class Solution {\n            public:\n                int nthUglyNumber(int n) {\n                    vector<int> factors = {2, 3, 5};\n                    unordered_set<long> seen;\n                    priority_queue<long, vector<long>, greater<long>> heap;\n                    seen.insert(1L);\n                    heap.push(1L);\n                    int ugly = 0;\n                    for (int i = 0; i < n; i++) {\n                        long curr = heap.top();\n                        heap.pop();\n                        ugly = (int)curr;\n                        for (int factor : factors) {\n                            long next = curr * factor;\n                            if (!seen.count(next)) {\n                                seen.insert(next);\n                                heap.push(next);\n                            }\n                        }\n                    }\n                    return ugly;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int nthUglyNumber(int n) {\n                    vector<int> dp(n + 1);\n                    dp[1] = 1;\n                    int p2 = 1, p3 = 1, p5 = 1;\n                    for (int i = 2; i <= n; i++) {\n                        int num2 = dp[p2] * 2, num3 = dp[p3] * 3, num5 = dp[p5] * 5;\n                        dp[i] = min(min(num2, num3), num5);\n                        if (dp[i] == num2) {\n                            p2++;\n                        }\n                        if (dp[i] == num3) {\n                            p3++;\n                        }\n                        if (dp[i] == num5) {\n                            p5++;\n                        }\n                    }\n                    return dp[n];\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int nthUglyNumber(int n) {\n                    vector<int> v;\n                    for (long long a=1;a<=INT_MAX;a=a*2)\n                        for (long long b=a;b<=INT_MAX;b=b*3)\n                            for (long long c=b;c<=INT_MAX;c=c*5)\n                                v.push_back(c);\n                    sort(v.begin(),v.end());\n                    return v.at(n-1);\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int nthUglyNumber(int n) {\n                    priority_queue <double,vector<double>,greater<double> > q;\n                    double answer=1;\n                    for (int i=1;i<n;++i)\n                    {\n                        q.push(answer*2);\n                        q.push(answer*3);\n                        q.push(answer*5);\n                        answer=q.top();\n                        q.pop();\n                        while (!q.empty() && answer==q.top())\n                            q.pop();\n                    }\n                    return answer;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int nthUglyNumber(int n) {\n                    vector<int> dp(n);\n                    dp.at(0)=1;\n                    int p_2,p_3,p_5;\n                    p_2=p_3=p_5=0;\n                    for (int i=1;i<n;++i)\n                    {\n                        dp.at(i)=min(min(2*dp.at(p_2),3*dp.at(p_3)),5*dp.at(p_5));\n                        if (dp.at(i)==2*dp.at(p_2))\n                            ++p_2;\n                        if (dp.at(i)==3*dp.at(p_3))\n                            ++p_3;\n                        if (dp.at(i)==5*dp.at(p_5))\n                            ++p_5;\n                    }\n                    return dp.at(n-1);\n                }\n            };\n        "]
    },
    {
        "id":142,
        "description":"\n        Convert a non-negative integer num to its English words representation.\n\n \n\nExample 1:\n\nInput: num = 123\nOutput: \"One Hundred Twenty Three\"\nExample 2:\n\nInput: num = 12345\nOutput: \"Twelve Thousand Three Hundred Forty Five\"\nExample 3:\n\nInput: num = 1234567\nOutput: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"\n \n\nConstraints:\n\n0 <= num <= 2^31 - 1\n        ",
        "tag":["Recursion","Math","String"],
        "answer":["\n        class Solution {\n            public:\n                vector<string> singles = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n                vector<string> teens = {\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\n                vector<string> tens = {\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\n                vector<string> thousands = {\"\", \"Thousand\", \"Million\", \"Billion\"};\n            \n                string numberToWords(int num) {\n                    if (num == 0) {\n                        return \"Zero\";\n                    }\n                    string sb;\n                    for (int i = 3, unit = 1000000000; i >= 0; i--, unit /= 1000) {\n                        int curNum = num / unit;\n                        if (curNum != 0) {\n                            num -= curNum * unit;\n                            string curr;\n                            recursion(curr, curNum);\n                            curr = curr + thousands[i] + \" \";\n                            sb = sb + curr;\n                        }\n                    }\n                    while (sb.back() == ' ') {\n                        sb.pop_back();\n                    }\n                    return sb;\n                }\n            \n                void recursion(string & curr, int num) {\n                    if (num == 0) {\n                        return;\n                    } else if (num < 10) {\n                        curr = curr + singles[num] + \" \";\n                    } else if (num < 20) {\n                        curr = curr + teens[num - 10] + \" \";\n                    } else if (num < 100) {\n                        curr = curr + tens[num / 10] + \" \";\n                        recursion(curr, num % 10);\n                    } else {\n                        curr = curr + singles[num / 100] + \" Hundred \";\n                        recursion(curr, num % 100);\n                    }\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<string> singles = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n                vector<string> teens = {\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\n                vector<string> tens = {\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\n                vector<string> thousands = {\"\", \"Thousand\", \"Million\", \"Billion\"};\n                \n                string numberToWords(int num) {\n                    if (num == 0) {\n                        return \"Zero\";\n                    }\n                    string sb;\n                    for (int i = 3, unit = 1000000000; i >= 0; i--, unit /= 1000) {\n                        int curNum = num / unit;\n                        if (curNum != 0) {\n                            num -= curNum * unit;\n                            sb = sb + toEnglish(curNum) + thousands[i] + \" \";\n                        }\n                    }\n                    while (sb.back() == ' ') {\n                        sb.pop_back();\n                    }\n                    return sb;\n                }\n            \n                string toEnglish(int num) {\n                    string curr;\n                    int hundred = num / 100;\n                    num %= 100;\n                    if (hundred != 0) {\n                        curr = curr + singles[hundred] + \" Hundred \";\n                    }\n                    int ten = num / 10;\n                    if (ten >= 2) {\n                        curr = curr + tens[ten] + \" \";\n                        num %= 10;\n                    }\n                    if (num > 0 && num < 10) {\n                        curr = curr + singles[num] + \" \";\n                    } else if (num >= 10) {\n                        curr = curr + teens[num - 10] + \" \";\n                    }\n                    return curr;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<string> singles = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\"};\n                vector<string> teens = {\"Ten\", \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\n                vector<string> tens = {\"\", \"Ten\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\n            \n                string comma(int n) {\n                    string ans = \"\";\n            \n                    int hundred = n / 100;\n                    if (hundred) {\n                        ans += singles[hundred] + \" Hundred \";\n                    }\n                    n = n % 100;\n                    if (n < 20 && n >= 10) {\n                        ans += teens[n%10] + \" \";\n                        return ans;\n                    }\n                    if (n >= 20) {\n                        ans += tens[n/10] + \" \";\n                    }\n                    n = n % 10;\n                    if (n == 0) return ans;\n            \n                    ans += singles[n%10] + \" \";\n                    return ans;\n                }\n            \n                string recur(int n) {\n                    int billion = n / 1000000000;\n                    n %= 1000000000;\n                    int million = n / 1000000;\n                    n %= 1000000;\n                    int thousand = n / 1000;\n                    n %= 1000;\n                    string ans = \"\";\n            \n                    if (billion) {\n                        ans += recur(billion) + \"Billion \";\n                    }\n                    if (million) {\n                        ans += recur(million) + \"Million \";\n                    }\n                    if (thousand) {\n                        ans += recur(thousand) + \"Thousand \";\n                    }\n            \n                    ans += comma(n);\n            \n                    return ans;\n                }\n            \n                string numberToWords(int num) {\n                    if (num == 0) return \"Zero\";\n                    string ans = recur(num);\n                    ans.pop_back();\n                    return ans;\n                }\n            };\n        "]
    },
    {
        "id":143,
        "description":"\n        Given an array of integers citations where citations[i] is the number of citations a researcher received for their i^th paper, return the researcher's h-index.\n\nAccording to the definition of h-index on Wikipedia: The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times.\n\n \n\nExample 1:\n\nInput: citations = [3,0,6,1,5]\nOutput: 3\nExplanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively.\nSince the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.\nExample 2:\n\nInput: citations = [1,3,1]\nOutput: 1\n \n\nConstraints:\n\nn == citations.length\n1 <= n <= 5000\n0 <= citations[i] <= 1000\n        ",
        "tag":["Array","Counting Sort","Sorting"],
        "answer":["\n        class Solution {\n            public:\n                int hIndex(vector<int>& citations) {\n                    sort(citations.begin(), citations.end());\n                    int h = 0, i = citations.size() - 1;\n                    while (i >= 0 && citations[i] > h) {\n                        h++;\n                        i--;\n                    }\n                    return h;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int hIndex(vector<int>& citations) {\n                    int n = citations.size(), tot = 0;\n                    vector<int> counter(n + 1);\n                    for (int i = 0; i < n; i++) {\n                        if (citations[i] >= n) {\n                            counter[n]++;\n                        } else {\n                            counter[citations[i]]++;\n                        }\n                    }\n                    for (int i = n; i >= 0; i--) {\n                        tot += counter[i];\n                        if (tot >= i) {\n                            return i;\n                        }\n                    }\n                    return 0;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int hIndex(vector<int>& citations) {\n                    int n=citations.size();\n                    sort(citations.begin(),citations.end(),greater<int>());\n                    for(int i=0;i<n;i++){\n                        if(citations[i]<i+1) return i;\n                    }\n                    return n;\n                }\n            };\n        "]
    },
    {
        "id":144,
        "description":"\n        Given an array of integers citations where citations[i] is the number of citations a researcher received for their i^th paper and citations is sorted in ascending order, return the researcher's h-index.\n\nAccording to the definition of h-index on Wikipedia: The h-index is defined as the maximum value of h such that the given researcher has published at least h papers that have each been cited at least h times.\n\nYou must write an algorithm that runs in logarithmic time.\n\n \n\nExample 1:\n\nInput: citations = [0,1,3,5,6]\nOutput: 3\nExplanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had received 0, 1, 3, 5, 6 citations respectively.\nSince the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, their h-index is 3.\nExample 2:\n\nInput: citations = [1,2,100]\nOutput: 2\n \n\nConstraints:\n\nn == citations.length\n1 <= n <= 10^5\n0 <= citations[i] <= 1000\ncitations is sorted in ascending order.\n        ",
        "tag":["Array","Binary Search"],
        "answer":["\n        class Solution {\n            public:\n                int hIndex(vector<int>& citations) {\n                    int n = citations.size();\n                    int left = 0, right = n - 1;\n                    while (left <= right) {\n                        int mid = left + (right - left) / 2;\n                        if (citations[mid] >= n - mid) {\n                            right = mid - 1;\n                        } else {\n                            left = mid + 1;\n                        }\n                    }\n                    return n - left;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int hIndex(vector<int>& citations) {\n                    int n = citations.size();\n                    for (int i = 0; i < n; i++) {\n                        if (citations[i] >= n - i) {\n                            return n - i;\n                        }\n                    }\n                    return 0;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int hIndex(vector<int>& citations) {\n                    int n = citations.size();\n                    int l = 0, r = n;\n                    while (l < r) {\n                        int mid = (l + r) >> 1;\n                        if (citations[mid] >= n - mid) {\n                            r = mid;\n                        }\n                        else {\n                            l = mid + 1;\n                        }\n                    }\n                    return n - l;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int hIndex(vector<int>& citations) {\n                    //显然二分法\n                    int left=0;\n                    int right=citations.size()-1;\n                    int mid=0;\n                    int h=0;\n                    while( left<=right ){\n                        mid = (right-left)/2+left;\n                        \n                        if( citations.size()-mid <= citations[mid] ){\n                            h = citations.size()-mid;\n                            right=mid-1;\n                        }\n                        else{\n                            left=mid+1;\n                        }\n                    }\n                    return h;\n                }\n            };\n        "]
    },
    {
        "id":145,
        "description":"\n        You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\n\nSuppose you have n versions [1, 2, ..., n] and you want to find out the first bad one, which causes all the following ones to be bad.\n\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\n\n \n\nExample 1:\n\nInput: n = 5, bad = 4\nOutput: 4\nExplanation:\ncall isBadVersion(3) -> false\ncall isBadVersion(5) -> true\ncall isBadVersion(4) -> true\nThen 4 is the first bad version.\nExample 2:\n\nInput: n = 1, bad = 1\nOutput: 1\n \n\nConstraints:\n\n1 <= bad <= n <= 2^31 - 1\n        ",
        "tag":["Binary Search","Interactive"],
        "answer":["\n        class Solution {\n            public:\n                int firstBadVersion(int n) {\n                    int left = 1, right = n;\n                    while (left < right) { // 循环直至区间左右端点相同\n                        int mid = left + (right - left) / 2; // 防止计算时溢出\n                        if (isBadVersion(mid)) {\n                            right = mid; // 答案在区间 [left, mid] 中\n                        } else {\n                            left = mid + 1; // 答案在区间 [mid+1, right] 中\n                        }\n                    }\n                    // 此时有 left == right，区间缩为一个点，即为答案\n                    return left;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int firstBadVersion(int n) {\n                    int i = 1, j = n;\n                    while (i <= j) {\n                        // 向下取整除法计算中点 m \n                        int m = i + (j - i) / 2;\n                        // 若 m 是错误版本，则最后一个正确版本一定在闭区间 [i, m - 1]\n                        if (isBadVersion(m)) j = m - 1;\n                        // 若 m 是正确版本，则首个错误版本一定在闭区间 [m + 1, j]\n                        else i = m + 1;\n                    }\n                    // i 指向首个错误版本，j 指向最后一个正确版本\n                    return i;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int firstBadVersion(int n) {\n                    int left = 1;\n                    int right = n;\n                    \n                    int ans = -1;\n                    while (left <= right) {\n                        int mid = (right-left)/2 + left;\n                        if (isBadVersion(mid)) {\n                            ans = mid;\n                            right = mid - 1;\n                        } else {\n                            left = mid + 1;\n                        }\n                    }\n                    \n                    return ans;\n                }\n            };\n        "]
    },
    {
        "id":146,
        "description":"\n        Given an integer n, return the least number of perfect square numbers that sum to n.\n\nA perfect square is an integer that is the square of an integer; in other words, it is the product of some integer with itself. For example, 1, 4, 9, and 16 are perfect squares while 3 and 11 are not.\n\n \n\nExample 1:\n\nInput: n = 12\nOutput: 3\nExplanation: 12 = 4 + 4 + 4.\nExample 2:\n\nInput: n = 13\nOutput: 2\nExplanation: 13 = 4 + 9.\n \n\nConstraints:\n\n1 <= n <= 10^4\n        ",
        "tag":["Breadth-First Search","Math","Dynamic Programming"],
        "answer":["\n        class Solution {\n            public:\n                int numSquares(int n) {\n                    vector<int> f(n + 1);\n                    for (int i = 1; i <= n; i++) {\n                        int minn = INT_MAX;\n                        for (int j = 1; j * j <= i; j++) {\n                            minn = min(minn, f[i - j * j]);\n                        }\n                        f[i] = minn + 1;\n                    }\n                    return f[n];\n                }\n            };\n        ","\n        class Solution {\n            public:\n                // 判断是否为完全平方数\n                bool isPerfectSquare(int x) {\n                    int y = sqrt(x);\n                    return y * y == x;\n                }\n            \n                // 判断是否能表示为 4^k*(8m+7)\n                bool checkAnswer4(int x) {\n                    while (x % 4 == 0) {\n                        x /= 4;\n                    }\n                    return x % 8 == 7;\n                }\n            \n                int numSquares(int n) {\n                    if (isPerfectSquare(n)) {\n                        return 1;\n                    }\n                    if (checkAnswer4(n)) {\n                        return 4;\n                    }\n                    for (int i = 1; i * i <= n; i++) {\n                        int j = n - i * i;\n                        if (isPerfectSquare(j)) {\n                            return 2;\n                        }\n                    }\n                    return 3;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int numSquares(int n) {\n                    vector<int> dp(n + 1, INT_MAX);\n                    // 完全背包问题\n                    dp[0] = 0; // 边界\n                    for (int i = 1; i * i <= n; i++) { // 遍历物品\n                        for (int j = i * i; j <= n; j++) { // 遍历背包\n                            dp[j] = min(dp[j - i * i] + 1, dp[j]);\n                        }\n                    }\n                    return dp[n];\n                }\n            };\n        "]
    },
    {
        "id":147,
        "description":"\n        Given a string num that contains only digits and an integer target, return all possibilities to insert the binary operators '+', '-', and/or '*' between the digits of num so that the resultant expression evaluates to the target value.\n\nNote that operands in the returned expressions should not contain leading zeros.\n\n \n\nExample 1:\n\nInput: num = \"123\", target = 6\nOutput: [\"1*2*3\",\"1+2+3\"]\nExplanation: Both \"1*2*3\" and \"1+2+3\" evaluate to 6.\nExample 2:\n\nInput: num = \"232\", target = 8\nOutput: [\"2*3+2\",\"2+3*2\"]\nExplanation: Both \"2*3+2\" and \"2+3*2\" evaluate to 8.\nExample 3:\n\nInput: num = \"3456237490\", target = 9191\nOutput: []\nExplanation: There are no expressions that can be created from \"3456237490\" to evaluate to 9191.\n \n\nConstraints:\n\n1 <= num.length <= 10\nnum consists of only digits.\n-2^31 <= target <= 2^31 - 1\n        ",
        "tag":["Math","String","Backtracking"],
        "answer":["\n        class Solution {\n            public:\n                vector<string> addOperators(string num, int target) {\n                    int n = num.length();\n                    vector<string> ans;\n            \n                    function<void(string&, int, long, long)> backtrack = [&](string &expr, int i, long res, long mul) {\n                        if (i == n) {\n                            if (res == target) {\n                                ans.emplace_back(expr);\n                            }\n                            return;\n                        }\n                        int signIndex = expr.size();\n                        if (i > 0) {\n                            expr.push_back(0); // 占位，下面填充符号\n                        }\n                        long val = 0;\n                        // 枚举截取的数字长度（取多少位），注意数字可以是单个 0 但不能有前导零\n                        for (int j = i; j < n && (j == i || num[i] != '0'); ++j) {\n                            val = val * 10 + num[j] - '0';\n                            expr.push_back(num[j]);\n                            if (i == 0) { // 表达式开头不能添加符号\n                                backtrack(expr, j + 1, val, val);\n                            } else { // 枚举符号\n                                expr[signIndex] = '+'; backtrack(expr, j + 1, res + val, val);\n                                expr[signIndex] = '-'; backtrack(expr, j + 1, res - val, -val);\n                                expr[signIndex] = '*'; backtrack(expr, j + 1, res - mul + mul * val, mul * val);\n                            }\n                        }\n                        expr.resize(signIndex);\n                    };\n            \n                    string expr;\n                    backtrack(expr, 0, 0, 0);\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            using ll = long long;\n        public:\n            // 判断是否出现了前导 0 \n            bool check(string s) {\n                int n = s.size();\n                for(int i = 0; i < n - 1; ++i) {\n                    if(s[i] == '0') {\n                        // 如果前面没有数字，且后面有数字，则为前导 0\n                        if( (i && !isdigit(s[i - 1])) || i == 0 ) {\n                            if(isdigit(s[i + 1])) {\n                                return false;\n                            }\n                        }\n                    }\n                }\n                return true;\n            }\n        \n            // 计算表达式的值\n            ll calculate(string s) {\n                vector<ll> stk;\n                char preSign = '+';\n                ll num = 0;\n                int n = s.length();\n                for (int i = 0; i < n; ++i) {\n                    if (isdigit(s[i])) {\n                        num = num * 10 + int(s[i] - '0');\n                    }\n                    if (!isdigit(s[i]) && s[i] != ' ' || i == n - 1) {\n                        switch (preSign) {\n                            case '+':\n                                stk.push_back(num);\n                                break;\n                            case '-':\n                                stk.push_back(-num);\n                                break;\n                            case '*':\n                                stk.back() *= num;\n                                break;\n                            default:\n                                stk.back() /= num;\n                        }\n                        preSign = s[i];\n                        num = 0;\n                    }\n                }\n                return accumulate(stk.begin(), stk.end(), 0);\n            }\n        \n            vector<string> addOperators(string s, int target) {\n                int n = s.size();\n                vector<string> ret;\n        \n                for(int mask = 1; mask < (1 << (2 * n - 2)); ++mask) {\n                    // mask 从 1 开始：至少有一个运算符\n                    string cur;\n                    cur += s[0];\n                    for(int j = 1; j < n; ++j) {\n                        // [2 * j - 2, 2 * j - 1] 两个位置的二进制数表示选用哪一个运算符\n                        // c 为高位，d 为低位\n                        int c = mask & (1 << (2 * j - 1));\n                        int d = mask & (1 << (2 * j - 2));\n                        if(c == 0 && d == 0) {\n                            // op = 0, 不选用运算符\n                            cur += s[j];\n                        } else if(c == 0) {\n                            // op = 1, 加法\n                            cur += \"+\";\n                            cur += s[j];\n                        } else if(d == 0) {\n                            // op = 2，减法\n                            cur += \"-\";\n                            cur += s[j];\n                        } else {\n                            // op = 3, 乘法\n                            cur += \"*\";\n                            cur += s[j];\n                        }\n                    }\n                    \n                    if(check(cur) && calculate(cur) == target) {\n                        // 如果计算结果正确，则将当前表达式 cur 加入结果数组\n                        ret.push_back(cur);\n                    }\n                }\n        \n                sort(ret.begin(), ret.end());\n                return ret;\n            }\n        };\n        ","\n        class Solution {\n            using ll = long long;\n        public:\n            string num;\n            vector<string> ret;\n            int n, target;\n        \n            void dfs(string &s, int index, ll res, ll mul) {\n                // 当前已达到字符串末尾，若结果正确，则加入结果数组\n                // 不论正确与否，都应返回\n                if (index == n) {\n                    if (res == target) {\n                        ret.emplace_back(s);\n                    }\n                    return;\n                }\n        \n                // 当前表达式长度\n                int m = s.size();\n                if (index > 0) {\n                    s.push_back(0); // 占位，下面填充符号\n                }\n                ll val = 0;\n                // 枚举截取的数字长度（取多少位），注意数字可以是单个 0 但不能有前导零\n                for (int j = index; j < n && (j == index || num[index] != '0'); ++j) {\n                    val = val * 10 + num[j] - '0';\n                    s.push_back(num[j]);\n                    if (index == 0) { // 表达式开头不能添加符号\n                        dfs(s, j + 1, val, val);\n                    } else { // 枚举符号\n                        // 加法\n                        s[m] = '+'; dfs(s, j + 1, res + val, val);\n                        // 减法\n                        s[m] = '-'; dfs(s, j + 1, res - val, -val);\n                        // 乘法\n                        s[m] = '*'; dfs(s, j + 1, res - mul + mul * val, mul * val);\n                    }\n                }\n                s.resize(m);\n            };\n        \n            vector<string> addOperators(string _num, int _target) {\n                num = _num;\n                n = _num.length();\n                target = _target;\n                string s;\n                dfs(s, 0, 0, 0);\n                return ret;\n            }\n        };\n        "]
    },
    {
        "id":148,
        "description":"\n        Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.\n\nNote that you must do this in-place without making a copy of the array.\n\n \n\nExample 1:\n\nInput: nums = [0,1,0,3,12]\nOutput: [1,3,12,0,0]\nExample 2:\n\nInput: nums = [0]\nOutput: [0]\n \n\nConstraints:\n\n1 <= nums.length <= 10^4\n-2^31 <= nums[i] <= 2^31 - 1\n ",
        "tag":["Array","Two Pointers"],
        "answer":["\n        class Solution {\n            public:\n                void moveZeroes(vector<int>& nums) {\n                    int n = nums.size(), left = 0, right = 0;\n                    while (right < n) {\n                        if (nums[right]) {\n                            swap(nums[left], nums[right]);\n                            left++;\n                        }\n                        right++;\n                    }\n                }\n            };\n        ","\n        class Solution {\n            public:\n                void moveZeroes(vector<int>& nums) {\n                    vector<int> temp;\n                    int len = nums.size();\n                    int timer = 0;\n            \n            \n                    for(auto e : nums){\n                        if(e){\n                            temp.push_back(e);\n                            ++timer;\n                        }\n                    }\n                    for(int i = 0 ; i < len - timer ; ++i){\n                        temp.push_back(0);\n                    }\n                    nums = temp;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                void moveZeroes(vector<int>& nums) {\n                    int slow=0;\n                    for(int fast=0;fast<nums.size();fast++)\n                    {\n                        if(nums[fast]!=0)\n                        nums[slow++]=nums[fast];\n                    }\n                    for(int i=slow;i<nums.size();i++) nums[i]=0;\n                }\n            };\n        "]
    },
    {
        "id":149,
        "description":"\n        Design an iterator that supports the peek operation on an existing iterator in addition to the hasNext and the next operations.\n\nImplement the PeekingIterator class:\n\nPeekingIterator(Iterator<int> nums) Initializes the object with the given integer iterator iterator.\nint next() Returns the next element in the array and moves the pointer to the next element.\nboolean hasNext() Returns true if there are still elements in the array.\nint peek() Returns the next element in the array without moving the pointer.\nNote: Each language may have a different implementation of the constructor and Iterator, but they all support the int next() and boolean hasNext() functions.\n\n \n\nExample 1:\n\nInput\n[\"PeekingIterator\", \"next\", \"peek\", \"next\", \"next\", \"hasNext\"]\n[[[1, 2, 3]], [], [], [], [], []]\nOutput\n[null, 1, 2, 2, 3, false]\n\nExplanation\nPeekingIterator peekingIterator = new PeekingIterator([1, 2, 3]); // [1,2,3]\npeekingIterator.next();    // return 1, the pointer moves to the next element [1,2,3].\npeekingIterator.peek();    // return 2, the pointer does not move [1,2,3].\npeekingIterator.next();    // return 2, the pointer moves to the next element [1,2,3]\npeekingIterator.next();    // return 3, the pointer moves to the next element [1,2,3]\npeekingIterator.hasNext(); // return False\n \n\nConstraints:\n\n1 <= nums.length <= 1000\n1 <= nums[i] <= 1000\nAll the calls to next and peek are valid.\nAt most 1000 calls will be made to next, hasNext, and peek.\n        ",
        "tag":["Design","Array","Iterator"],
        "answer":["\n        class PeekingIterator : public Iterator {\n            public:\n                PeekingIterator(const vector<int>& nums) : Iterator(nums) {\n                    flag = Iterator::hasNext();\n                    if (flag) {\n                        nextElement = Iterator::next();\n                    }\n                }\n                \n                int peek() {\n                    return nextElement;\n                }\n                \n                int next() {\n                    int ret = nextElement;\n                    flag = Iterator::hasNext();\n                    if (flag) {\n                        nextElement = Iterator::next();\n                    }\n                    return ret;\n                }\n                \n                bool hasNext() const {\n                    return flag;\n                }\n            private:\n                int nextElement;\n                bool flag;\n            };\n        ","\n        class PeekingIterator : public Iterator {\n            public:\n                // 声明哑节点及指针\n                ListNode *dummyHead;\n                ListNode *pointer;\n            \n                PeekingIterator(const vector<int>& nums) : Iterator(nums) {\n                    // 构建链表\n            \n                    dummyHead = new ListNode();\n                    // 最初指针指向哑结点\n                    pointer = dummyHead;\n            \n                    // 为了遍历数组方便，且不改变哑节点，额外设置一个局部变量\n                    ListNode* p = dummyHead;\n                    for(int x : nums) {\n                        // 遍历数组元素构建链表\n                        ListNode *newnode = new ListNode(x);\n                        p->next = newnode;\n                        p = p->next;\n                    }\n                }\n                \n                // Returns the next element in the iteration without advancing the iterator.\n                int peek() {\n                    // 指针不动，所以根据其 next 指针找到下一个节点\n                    return pointer->next->val;\n                }\n                \n                // hasNext() and next() should behave the same as in the Iterator interface.\n                // Override them if needed.\n                int next() {\n                    // 指针也随之后移，所以先后移，再返回元素\n                    pointer = pointer->next;\n                    return pointer->val;\n                }\n                \n                bool hasNext() const {\n                    // 根据 next 指针是否指向空节点 nullptr 判断是否还有下一个节点\n                    if(pointer->next != nullptr) return true;\n                    return false;\n                }\n            };\n        ","\n        class PeekingIterator : public Iterator {\n            public:\n                int nextValue;\n                bool exist;\n                PeekingIterator(const vector<int>& nums) : Iterator(nums) {\n                    exist = Iterator::hasNext();\n                    if (exist)\n                        nextValue = Iterator::next();\n                }\n            \n                int peek() {\n                    return nextValue;\n                }\n            \n                int next() {\n                    int tmpValue = nextValue;\n                    exist = Iterator::hasNext();\n                    if (exist)\n                        nextValue = Iterator::next();\n                    return tmpValue;\n                }\n            \n                bool hasNext() const {\n                    return exist;\n                }\n            };\n        "]
    },
    {
        "id":150,
        "description":"\n        Given an array of integers nums containing n + 1 integers where each integer is in the range [1, n] inclusive.\n\nThere is only one repeated number in nums, return this repeated number.\n\nYou must solve the problem without modifying the array nums and uses only constant extra space.\n\n \n\nExample 1:\n\nInput: nums = [1,3,4,2,2]\nOutput: 2\nExample 2:\n\nInput: nums = [3,1,3,4,2]\nOutput: 3\n \n\nConstraints:\n\n1 <= n <= 10^5\nnums.length == n + 1\n1 <= nums[i] <= n\nAll the integers in nums appear only once except for precisely one integer which appears two or more times.\n        ",
        "tag":["Bit Manipulation","Array","Two Pointers","Binary Search"],
        "answer":["\n        class Solution {\n            public:\n                int findDuplicate(vector<int>& nums) {\n                    int n = nums.size();\n                    int l = 1, r = n - 1, ans = -1;\n                    while (l <= r) {\n                        int mid = (l + r) >> 1;\n                        int cnt = 0;\n                        for (int i = 0; i < n; ++i) {\n                            cnt += nums[i] <= mid;\n                        }\n                        if (cnt <= mid) {\n                            l = mid + 1;\n                        } else {\n                            r = mid - 1;\n                            ans = mid;\n                        }\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int findDuplicate(vector<int>& nums) {\n                    int n = nums.size(), ans = 0;\n                    // 确定二进制下最高位是多少\n                    int bit_max = 31;\n                    while (!((n - 1) >> bit_max)) {\n                        bit_max -= 1;\n                    }\n                    for (int bit = 0; bit <= bit_max; ++bit) {\n                        int x = 0, y = 0;\n                        for (int i = 0; i < n; ++i) {\n                            if (nums[i] & (1 << bit)) {\n                                x += 1;\n                            }\n                            if (i >= 1 && (i & (1 << bit))) {\n                                y += 1;\n                            }\n                        }\n                        if (x > y) {\n                            ans |= 1 << bit;\n                        }\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int findDuplicate(vector<int>& nums) {\n                    int slow = 0, fast = 0;\n                    do {\n                        slow = nums[slow];\n                        fast = nums[nums[fast]];\n                    } while (slow != fast);\n                    slow = 0;\n                    while (slow != fast) {\n                        slow = nums[slow];\n                        fast = nums[fast];\n                    }\n                    return slow;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int findDuplicate(vector<int>& nums) {\n                    \n                    int fast = 0, slow = 0;\n                    while(true){\n                        fast = nums[nums[fast]];\n                        slow = nums[slow];\n                        if(fast == slow)\n                            break;\n                    }\n                    int finder = 0;\n                    while(true){\n                        finder = nums[finder];\n                        slow = nums[slow];\n                        if(slow == finder)\n                            break;        \n                    }\n                    return slow;\n                }\n            };\n        "]
    },
    {
        "id":151,
        "description":"\n        Given a pattern and a string s, find if s follows the same pattern.\n\nHere follow means a full match, such that there is a bijection between a letter in pattern and a non-empty word in s.\n\n \n\nExample 1:\n\nInput: pattern = \"abba\", s = \"dog cat cat dog\"\nOutput: true\nExample 2:\n\nInput: pattern = \"abba\", s = \"dog cat cat fish\"\nOutput: false\nExample 3:\n\nInput: pattern = \"aaaa\", s = \"dog cat cat dog\"\nOutput: false\n \n\nConstraints:\n\n1 <= pattern.length <= 300\npattern contains only lower-case English letters.\n1 <= s.length <= 3000\ns contains only lowercase English letters and spaces ' '.\ns does not contain any leading or trailing spaces.\nAll the words in s are separated by a single space.\n        ",
        "tag":["Hash Table","String"],
        "answer":["\n        class Solution {\n            public:\n                bool wordPattern(string pattern, string str) {\n                    unordered_map<string, char> str2ch;\n                    unordered_map<char, string> ch2str;\n                    int m = str.length();\n                    int i = 0;\n                    for (auto ch : pattern) {\n                        if (i >= m) {\n                            return false;\n                        }\n                        int j = i;\n                        while (j < m && str[j] != ' ') j++;\n                        const string &tmp = str.substr(i, j - i);\n                        if (str2ch.count(tmp) && str2ch[tmp] != ch) {\n                            return false;\n                        }\n                        if (ch2str.count(ch) && ch2str[ch] != tmp) {\n                            return false;\n                        }\n                        str2ch[tmp] = ch;\n                        ch2str[ch] = tmp;\n                        i = j + 1;\n                    }\n                    return i >= m;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool wordPattern(string pattern, string s) {\n                    int k=0,i=0;\n                    string temp;\n                    unordered_set<char> num;\n                    unordered_map<string,char> m;\n                    for(;i<s.size()&&k<pattern.size();i++,k++){\n                        num.insert(pattern[k]);//统计B的元素个数\n                        while(i<s.size() && s[i]!=' ')temp+=s[i++];//提取元素\n                        if(m.count(temp)==0){//新元素，插入\n                            m[temp]=pattern[k];\n                        }\n                        else if(pattern[k]!=m[temp])return false;//唯一性判断\n                        temp=\"\";\n                    }\n                    return k==pattern.size()&&i==s.size()+1&&num.size()==m.size();\n                }\n            };\n        ","\n        \nclass Solution {\n    public:\n        bool wordPattern(string pattern, string s) {\n            vector<int> q1;\n            vector<int> q2;\n            \n            int num = 1;\n            map<string, int> mp1;\n            map<char, int> mp2;\n            //转化s\n            int i = 0, j = 0;\n            for( ; j < s.size(); j++){\n                if(s[j] == ' '){\n                    string x = s.substr(i, j - i);\n                    if(mp1.find(x) != mp1.end()){\n                        q1.emplace_back(mp1[x]);\n                    }\n                    else{\n                        mp1[x] = num;\n                        q1.emplace_back(num++);\n                    }\n                    i = j + 1;\n                }\n            }\n            //s的最后一个单词并没有在for循环转化为对应的数字，所以我们单独在\n            //最后进行转化\n            string x = s.substr(i, j - i);\n            if(mp1.find(x) != mp1.end()){\n                q1.emplace_back(mp1[x]);\n            }\n            else{\n                mp1[x] = num;\n                q1.emplace_back(num++);\n            }\n    \n            num = 1;\n            //转化pattern\n            for(int a = 0; a < pattern.size(); a++){\n                if(mp2.find(pattern[a]) != mp2.end()){\n                    q2.emplace_back(mp2[pattern[a]]);\n                }\n                else{\n                    mp2[pattern[a]] = num;\n                    q2.emplace_back(num++);\n                }\n            }\n    \n            if(q1.size() != q2.size()) return false;\n            for(int n = 0; n < q1.size(); n++){\n                if(q1[n] != q2[n]) return false;\n            }\n    \n            return true;\n        }\n    };\n        "]
    },
    {
        "id":152,
        "description":"\n        You are playing the following Nim Game with your friend:\n\nInitially, there is a heap of stones on the table.\nYou and your friend will alternate taking turns, and you go first.\nOn each turn, the person whose turn it is will remove 1 to 3 stones from the heap.\nThe one who removes the last stone is the winner.\nGiven n, the number of stones in the heap, return true if you can win the game assuming both you and your friend play optimally, otherwise return false.\n\n \n\nExample 1:\n\nInput: n = 4\nOutput: false\nExplanation: These are the possible outcomes:\n1. You remove 1 stone. Your friend removes 3 stones, including the last stone. Your friend wins.\n2. You remove 2 stones. Your friend removes 2 stones, including the last stone. Your friend wins.\n3. You remove 3 stones. Your friend removes the last stone. Your friend wins.\nIn all outcomes, your friend wins.\nExample 2:\n\nInput: n = 1\nOutput: true\nExample 3:\n\nInput: n = 2\nOutput: true\n \n\nConstraints:\n\n1 <= n <= 2^31 - 1\n        ",
        "tag":["Brainteaser","Math","Game Theory"],
        "answer":["\n        class Solution {\n            public:\n                bool canWinNim(int n) {\n                    return n % 4 != 0;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool canWinNim(int n) {\n                    return n % 4 != 0;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool canWinNim(int n) {\n                    return n % 4;\n                }\n            };\n        "]
    },
    {
        "id":153,
        "description":"\n        The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.\n\nFor example, for arr = [2,3,4], the median is 3.\nFor example, for arr = [2,3], the median is (2 + 3) / 2 = 2.5.\nImplement the MedianFinder class:\n\nMedianFinder() initializes the MedianFinder object.\nvoid addNum(int num) adds the integer num from the data stream to the data structure.\ndouble findMedian() returns the median of all elements so far. Answers within 10-5 of the actual answer will be accepted.\n \n\nExample 1:\n\nInput\n[\"MedianFinder\", \"addNum\", \"addNum\", \"findMedian\", \"addNum\", \"findMedian\"]\n[[], [1], [2], [], [3], []]\nOutput\n[null, null, null, 1.5, null, 2.0]\n\nExplanation\nMedianFinder medianFinder = new MedianFinder();\nmedianFinder.addNum(1);    // arr = [1]\nmedianFinder.addNum(2);    // arr = [1, 2]\nmedianFinder.findMedian(); // return 1.5 (i.e., (1 + 2) / 2)\nmedianFinder.addNum(3);    // arr[1, 2, 3]\nmedianFinder.findMedian(); // return 2.0\n \n\nConstraints:\n\n-10^5 <= num <= 10^5\nThere will be at least one element in the data structure before calling findMedian.\nAt most 5 * 10^4 calls will be made to addNum and findMedian.\n        ",
        "tag":["Design","Two Pointers","Data Stream","Sorting","Heap (Priority Queue)"],
        "answer":["\n        class MedianFinder {\n            public:\n                priority_queue<int, vector<int>, less<int>> queMin;\n                priority_queue<int, vector<int>, greater<int>> queMax;\n            \n                MedianFinder() {}\n            \n                void addNum(int num) {\n                    if (queMin.empty() || num <= queMin.top()) {\n                        queMin.push(num);\n                        if (queMax.size() + 1 < queMin.size()) {\n                            queMax.push(queMin.top());\n                            queMin.pop();\n                        }\n                    } else {\n                        queMax.push(num);\n                        if (queMax.size() > queMin.size()) {\n                            queMin.push(queMax.top());\n                            queMax.pop();\n                        }\n                    }\n                }\n            \n                double findMedian() {\n                    if (queMin.size() > queMax.size()) {\n                        return queMin.top();\n                    }\n                    return (queMin.top() + queMax.top()) / 2.0;\n                }\n            };\n        ","\n        class MedianFinder {\n            multiset<int> nums;\n            multiset<int>::iterator left, right;\n        \n        public:\n            MedianFinder() : left(nums.end()), right(nums.end()) {}\n        \n            void addNum(int num) {\n                const size_t n = nums.size();\n        \n                nums.insert(num);\n                if (!n) {\n                    left = right = nums.begin();\n                } else if (n & 1) {\n                    if (num < *left) {\n                        left--;\n                    } else {\n                        right++;\n                    }\n                } else {\n                    if (num > *left && num < *right) {\n                        left++;\n                        right--;\n                    } else if (num >= *right) {\n                        left++;\n                    } else {\n                        right--;\n                        left = right;\n                    }\n                }\n            }\n        \n            double findMedian() {\n                return (*left + *right) / 2.0;\n            }\n        };\n        ","\n        \nclass MedianFinder {\n    public:\n        priority_queue<int> l;\n        priority_queue<int,vector<int>,greater<int>> r;\n    \n        MedianFinder() {}\n    \n        void addNum(int num) {\n            int s1=l.size(),s2=r.size();\n    \n            //先不管大不大，先插入另一side再把多余的插到该插的本side\n            //草稿纸划划再想想\n            if(s1==s2){\n                r.emplace(num);\n                l.emplace(r.top());\n                r.pop();\n            }\n            else {\n                l.emplace(num);\n                r.emplace(l.top());\n                l.pop();\n            }\n        }\n        \n        double findMedian() {\n            int s1=l.size(),s2=r.size();\n    \n            if(s1==s2)return (l.top()+r.top())/2.0;\n            else return l.top();\n        }\n    };\n        "]
    },
    {
        "id":154,
        "description":"\n        You are playing the Bulls and Cows game with your friend.\n\nYou write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info:\n\nThe number of \"bulls\", which are digits in the guess that are in the correct position.\nThe number of \"cows\", which are digits in the guess that are in your secret number but are located in the wrong position. Specifically, the non-bull digits in the guess that could be rearranged such that they become bulls.\nGiven the secret number secret and your friend's guess guess, return the hint for your friend's guess.\n\nThe hint should be formatted as \"xAyB\", where x is the number of bulls and y is the number of cows. Note that both secret and guess may contain duplicate digits.\n\n \n\nExample 1:\n\nInput: secret = \"1807\", guess = \"7810\"\nOutput: \"1A3B\"\nExplanation: Bulls are connected with a '|' and cows are underlined:\n\"1807\"\n  |\n\"7810\"\nExample 2:\n\nInput: secret = \"1123\", guess = \"0111\"\nOutput: \"1A1B\"\nExplanation: Bulls are connected with a '|' and cows are underlined:\n\"1123\"        \"1123\"\n  |      or     |\n\"0111\"        \"0111\"\nNote that only one of the two unmatched 1s is counted as a cow since the non-bull digits can only be rearranged to allow one 1 to be a bull.\n \n\nConstraints:\n\n1 <= secret.length, guess.length <= 1000\nsecret.length == guess.length\nsecret and guess consist of digits only.\n        ",
        "tag":["Hash Table","String","Counting"],
        "answer":["\n        class Solution {\n            public:\n                string getHint(string secret, string guess) {\n                    int bulls = 0;\n                    vector<int> cntS(10), cntG(10);\n                    for (int i = 0; i < secret.length(); ++i) {\n                        if (secret[i] == guess[i]) {\n                            ++bulls;\n                        } else {\n                            ++cntS[secret[i] - '0'];\n                            ++cntG[guess[i] - '0'];\n                        }\n                    }\n                    int cows = 0;\n                    for (int i = 0; i < 10; ++i) {\n                        cows += min(cntS[i], cntG[i]);\n                    }\n                    return to_string(bulls) + \"A\" + to_string(cows) + \"B\";\n                }\n            };\n        ","\n        class Solution {\n            public:\n                string getHint(string secret, string guess) {\n                    int n = secret.size();\n                    int A = 0;\n                    int B = 0;\n                    \n                    int CA[10];\n                    int CB[10];\n                    memset(CA, 0, sizeof(CA));\n                    memset(CB, 0, sizeof(CB));\n            \n                    for (int i = 0; i < n; i++) {\n                        if (secret[i] == guess[i]) A++;\n                        CA[secret[i] - '0']++;\n                        CB[guess[i] - '0']++;\n                    }\n            \n                    for (int i = 0; i < 10; i++) {\n                        B += min(CA[i], CB[i]);\n                    }\n                    B -= A;\n            \n                    string ans = \"\";\n                    ans = to_string(A) + \"A\" + to_string(B) + \"B\";\n            \n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                string getHint(string secret, string guess) {\n                    unordered_map<int, int> secretMp, guessMp;\n                    int bulls = 0, cows = 0;\n            \n                    for (int i = 0; i < secret.size(); i++) {\n                        if (secret[i] == guess[i])\n                            ++bulls;\n                        else {\n                            secretMp[secret[i] - '0']++;\n                            guessMp[guess[i] - '0']++;\n                        }\n                    }\n            \n                    for (int i = 0; i < 10; i++)\n                        cows += min(secretMp[i], guessMp[i]);\n            \n                    string ans  = to_string(bulls) + \"A\" + to_string(cows) + \"B\";\n                    return ans;\n                }\n            };\n        "]
    },
    {
        "id":155,
        "description":"\n        Given an integer array nums, return the length of the longest strictly increasing \nsubsequence\n.\n\n \n\nExample 1:\n\nInput: nums = [10,9,2,5,3,7,101,18]\nOutput: 4\nExplanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.\nExample 2:\n\nInput: nums = [0,1,0,3,2,3]\nOutput: 4\nExample 3:\n\nInput: nums = [7,7,7,7,7,7,7]\nOutput: 1\n \n\nConstraints:\n\n1 <= nums.length <= 2500\n-10^4 <= nums[i] <= 10^4\n        ",
        "tag":["Arrayz","Binary Search","Dynamic Programming"],
        "answer":["\n        class Solution {\n            public:\n                int lengthOfLIS(vector<int>& nums) {\n                    int n = (int)nums.size();\n                    if (n == 0) {\n                        return 0;\n                    }\n                    vector<int> dp(n, 0);\n                    for (int i = 0; i < n; ++i) {\n                        dp[i] = 1;\n                        for (int j = 0; j < i; ++j) {\n                            if (nums[j] < nums[i]) {\n                                dp[i] = max(dp[i], dp[j] + 1);\n                            }\n                        }\n                    }\n                    return *max_element(dp.begin(), dp.end());\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int lengthOfLIS(vector<int>& nums) {\n                    int len = 1, n = (int)nums.size();\n                    if (n == 0) {\n                        return 0;\n                    }\n                    vector<int> d(n + 1, 0);\n                    d[len] = nums[0];\n                    for (int i = 1; i < n; ++i) {\n                        if (nums[i] > d[len]) {\n                            d[++len] = nums[i];\n                        } else {\n                            int l = 1, r = len, pos = 0; // 如果找不到说明所有的数都比 nums[i] 大，此时要更新 d[1]，所以这里将 pos 设为 0\n                            while (l <= r) {\n                                int mid = (l + r) >> 1;\n                                if (d[mid] < nums[i]) {\n                                    pos = mid;\n                                    l = mid + 1;\n                                } else {\n                                    r = mid - 1;\n                                }\n                            }\n                            d[pos + 1] = nums[i];\n                        }\n                    }\n                    return len;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int lengthOfLIS(vector<int> &nums) {\n                    int n = nums.size(), memo[n];\n                    memset(memo, 0, sizeof(memo)); // 本题可以初始化成 0，表示没有计算过\n                    function<int(int)> dfs = [&](int i) -> int {\n                        int &res = memo[i];\n                        if (res) return res;\n                        for (int j = 0; j < i; ++j)\n                            if (nums[j] < nums[i])\n                                res = max(res, dfs(j));\n                        return ++res;\n                    };\n                    int ans = 0;\n                    for (int i = 0; i < n; ++i)\n                        ans = max(ans, dfs(i));\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int lengthOfLIS(vector<int> &nums) {\n                    int n = nums.size(), f[n];\n                    for (int i = 0; i < n; ++i) {\n                        f[i] = 0;\n                        for (int j = 0; j < i; ++j)\n                            if (nums[j] < nums[i])\n                                f[i] = max(f[i], f[j]);\n                        ++f[i];\n                    }\n                    return *max_element(f, f + n);\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int lengthOfLIS(vector<int> &nums) {\n                    vector<int> g;\n                    for (int x : nums) {\n                        auto it = lower_bound(g.begin(), g.end(), x);\n                        if (it == g.end()) g.push_back(x); // >=x 的 g[j] 不存在\n                        else *it = x;\n                    }\n                    return g.size();\n                }\n            };\n        "]
    },
    {
        "id":156,
        "description":"\n        Given a string s that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.\n\nReturn a list of unique strings that are valid with the minimum number of removals. You may return the answer in any order.\n\n \n\nExample 1:\n\nInput: s = \"()())()\"\nOutput: [\"(())()\",\"()()()\"]\nExample 2:\n\nInput: s = \"(a)())()\"\nOutput: [\"(a())()\",\"(a)()()\"]\nExample 3:\n\nInput: s = \")(\"\nOutput: [\"\"]\n \n\nConstraints:\n\n1 <= s.length <= 25\ns consists of lowercase English letters and parentheses '(' and ')'.\nThere will be at most 20 parentheses in s.\n        ",
        "tag":["Breadth-First Search","String","Backtracking"],
        "answer":["\n        class Solution {\n            public:\n                vector<string> res;\n                vector<string> removeInvalidParentheses(string s) {\n                    int lremove = 0;\n                    int rremove = 0;\n            \n                    for (char c : s) {\n                        if (c == '(') {\n                            lremove++;\n                        } else if (c == ')') {\n                            if (lremove == 0) {\n                                rremove++;\n                            } else {\n                                lremove--;\n                            }\n                        }\n                    }\n                    helper(s, 0, lremove, rremove);\n                    return res;\n                }\n            \n                void helper(string str, int start, int lremove, int rremove) {\n                    if (lremove == 0 && rremove == 0) {\n                        if (isValid(str)) {\n                            res.push_back(str);\n                        }\n                        return;\n                    }\n                    for (int i = start; i < str.size(); i++) {\n                        if (i != start && str[i] == str[i - 1]) {\n                            continue;\n                        }\n                        // 如果剩余的字符无法满足去掉的数量要求，直接返回\n                        if (lremove + rremove > str.size() - i) {\n                            return;\n                        } \n                        // 尝试去掉一个左括号\n                        if (lremove > 0 && str[i] == '(') {\n                            helper(str.substr(0, i) + str.substr(i + 1), i, lremove - 1, rremove);\n                        }\n                        // 尝试去掉一个右括号\n                        if (rremove > 0 && str[i] == ')') {\n                            helper(str.substr(0, i) + str.substr(i + 1), i, lremove, rremove - 1);\n                        }\n                    }\n                }\n            \n                inline bool isValid(const string & str) {\n                    int cnt = 0;\n            \n                    for (int i = 0; i < str.size(); i++) {\n                        if (str[i] == '(') {\n                            cnt++;\n                        } else if (str[i] == ')') {\n                            cnt--;\n                            if (cnt < 0) {\n                                return false;\n                            }\n                        }\n                    }\n            \n                    return cnt == 0;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool isValid(string str) {\n                    int count = 0;\n            \n                    for (char c : str) {\n                        if (c == '(') {\n                            count++;\n                        } else if (c == ')') {\n                            count--;\n                            if (count < 0) {\n                                return false;\n                            }\n                        }\n                    }\n            \n                    return count == 0;\n                }\n            \n                vector<string> removeInvalidParentheses(string s) {\n                    vector<string> ans;\n                    unordered_set<string> currSet;\n            \n                    currSet.insert(s);\n                    while (true) {\n                        for (auto & str : currSet) {\n                            if (isValid(str))\n                                ans.emplace_back(str);\n                        }\n                        if (ans.size() > 0) {\n                            return ans;\n                        }\n                        unordered_set<string> nextSet;\n                        for (auto & str : currSet) {\n                            for (int i = 0; i < str.size(); i++) {\n                                if (i > 0 && str[i] == str[i - 1]) {\n                                    continue;\n                                }\n                                if (str[i] == '(' || str[i] == ')') {\n                                    nextSet.insert(str.substr(0, i) + str.substr(i + 1, str.size()));\n                                }\n                            }\n                        }\n                        currSet = nextSet;\n                    }\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool checkValid(const string & str, int lmask, vector<int> & left, int rmask, vector<int> & right) {\n                    int pos1 = 0;\n                    int pos2 = 0;\n                    int cnt = 0;\n            \n                    for (int i = 0; i < str.size(); i++) {\n                        if (pos1 < left.size() && i == left[pos1]) {\n                            if (!(lmask & (1 << pos1))) {\n                                cnt++;\n                            }\n                            pos1++;\n                        } else if (pos2 < right.size() && i == right[pos2]) {\n                            if (!(rmask & (1 << pos2))) {\n                                cnt--;\n                                if (cnt < 0) {\n                                    return false;\n                                }\n                            }\n                            pos2++;\n                        }\n                    }\n            \n                    return cnt == 0;\n                }\n            \n                string recoverStr(const string & str, int lmask, vector<int> & left, int rmask, vector<int> & right){\n                    string ans;\n                    int pos1 = 0;\n                    int pos2 = 0;\n            \n                    for (int i = 0; i < str.size(); i++) {\n                        if (pos1 < left.size() && i == left[pos1]) {\n                            if (!(lmask & (1 << pos1))){\n                                ans.push_back(str[i]);\n                            }\n                            pos1++;\n                        } else if (pos2 < right.size() && i == right[pos2]) {\n                            if (!(rmask & (1 << pos2))) {\n                                ans.push_back(str[i]);\n                            }\n                            pos2++;\n                        } else {\n                            ans.push_back(str[i]);\n                        }\n                    }\n            \n                    return ans;\n                }\n            \n                vector<string> removeInvalidParentheses(string s) {\n                    int lremove = 0;\n                    int rremove = 0;\n                    vector<int> left;\n                    vector<int> right;\n                    vector<string> ans;\n                    unordered_set<string> cnt;\n            \n                    for (int i = 0; i < s.size(); i++) {\n                        if (s[i] == '(') {\n                            left.push_back(i);\n                            lremove++;\n                        } else if (s[i] == ')') {\n                            right.push_back(i);\n                            if (lremove == 0) {\n                                rremove++;\n                            } else {\n                                lremove--;\n                            }\n                        }\n                    }\n            \n                    int m = left.size();\n                    int n = right.size();\n                    vector<int> maskArr1;\n                    vector<int> maskArr2;\n                    for (int i = 0; i < (1 << m); i++) {\n                        if (__builtin_popcount(i) != lremove) {\n                            continue;\n                        }\n                        maskArr1.push_back(i);\n                    }\n                    for (int j = 0; j < (1 << n); j++) {\n                        if (__builtin_popcount(j) != rremove) {\n                            continue;\n                        }\n                        maskArr2.push_back(j);\n                    }\n                    for (auto mask1 : maskArr1) {\n                        for (auto mask2 : maskArr2) {\n                            if (checkValid(s, mask1, left, mask2, right)) {\n                                cnt.insert(recoverStr(s, mask1, left, mask2, right));\n                            }\n                        }\n                    }\n                    for (auto v : cnt) {\n                        ans.emplace_back(v);\n                    }\n            \n                    return ans;\n                }\n            };\n        "]
    },
    {
        "id":157,
        "description":"\n        Given an integer array nums, handle multiple queries of the following type:\n\nCalculate the sum of the elements of nums between indices left and right inclusive where left <= right.\nImplement the NumArray class:\n\nNumArray(int[] nums) Initializes the object with the integer array nums.\nint sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive (i.e. nums[left] + nums[left + 1] + ... + nums[right]).\n \n\nExample 1:\n\nInput\n[\"NumArray\", \"sumRange\", \"sumRange\", \"sumRange\"]\n[[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]\nOutput\n[null, 1, -1, -3]\n\nExplanation\nNumArray numArray = new NumArray([-2, 0, 3, -5, 2, -1]);\nnumArray.sumRange(0, 2); // return (-2) + 0 + 3 = 1\nnumArray.sumRange(2, 5); // return 3 + (-5) + 2 + (-1) = -1\nnumArray.sumRange(0, 5); // return (-2) + 0 + 3 + (-5) + 2 + (-1) = -3\n \n\nConstraints:\n\n1 <= nums.length <= 10^4\n-10^5 <= nums[i] <= 10^5\n0 <= left <= right < nums.length\nAt most 10^4 calls will be made to sumRange.\n        ",
        "tag":["Design","Array","Prefix Sum"],
        "answer":["\n        class NumArray {\n            public:\n                vector<int> sums;\n            \n                NumArray(vector<int>& nums) {\n                    int n = nums.size();\n                    sums.resize(n + 1);\n                    for (int i = 0; i < n; i++) {\n                        sums[i + 1] = sums[i] + nums[i];\n                    }\n                }\n            \n                int sumRange(int i, int j) {\n                    return sums[j + 1] - sums[i];\n                }\n            };\n        ","\n        class NumArray {\n            private:\n                static constexpr int block_size = 100;\n                vector<int> nums;\n                vector<int> block_sum;\n            \n            public:\n                NumArray(vector<int>& nums) {\n                    this->nums = nums;\n            \n                    int i = 0;\n                    while (i + block_size <= nums.size()) {\n                        block_sum.push_back(accumulate(nums.begin() + i, nums.begin() + i + block_size, 0));\n                        i += block_size;\n                    }\n                }\n                \n                int sumRange(int i, int j) {\n                    int k = i, ans = 0;\n                    while (k <= j) {\n                        if (k % block_size == 0 && k + block_size - 1 <= j) {\n                            ans += block_sum[k / block_size];\n                            k += block_size;\n                        }\n                        else {\n                            ans += nums[k];\n                            ++k;\n                        }\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class NumArray {\n            public:\n                vector<int> res;\n                NumArray(vector<int>& nums) {\n                    res.clear();\n                    res=nums;\n                }\n                \n                int sumRange(int left, int right) {\n                    int sum = 0;\n                    for(int i=left;i<=right;i++){\n                        sum+=res[i];\n                    }\n                    return sum;\n                }\n            };\n        "]
    },
    {
        "id":158,
        "description":"\n        Given an integer array nums, handle multiple queries of the following types:\n\nUpdate the value of an element in nums.\nCalculate the sum of the elements of nums between indices left and right inclusive where left <= right.\nImplement the NumArray class:\n\nNumArray(int[] nums) Initializes the object with the integer array nums.\nvoid update(int index, int val) Updates the value of nums[index] to be val.\nint sumRange(int left, int right) Returns the sum of the elements of nums between indices left and right inclusive (i.e. nums[left] + nums[left + 1] + ... + nums[right]).\n \n\nExample 1:\n\nInput\n[\"NumArray\", \"sumRange\", \"update\", \"sumRange\"]\n[[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]\nOutput\n[null, 9, null, 8]\n\nExplanation\nNumArray numArray = new NumArray([1, 3, 5]);\nnumArray.sumRange(0, 2); // return 1 + 3 + 5 = 9\nnumArray.update(1, 2);   // nums = [1, 2, 5]\nnumArray.sumRange(0, 2); // return 1 + 2 + 5 = 8\n \n\nConstraints:\n\n1 <= nums.length <= 3 * 10^4\n-100 <= nums[i] <= 100\n0 <= index < nums.length\n-100 <= val <= 100\n0 <= left <= right < nums.length\nAt most 3 * 10^4 calls will be made to update and sumRange.\n        ",
        "tag":["Design","Binary Indexed Tree","Segment Tree","Array"],
        "answer":["\n        class NumArray {\n            private:\n                vector<int> sum; // sum[i] 表示第 i 个块的元素和\n                int size; // 块的大小\n                vector<int> &nums;\n            public:\n                NumArray(vector<int>& nums) : nums(nums) {\n                    int n = nums.size();\n                    size = sqrt(n);\n                    sum.resize((n + size - 1) / size); // n/size 向上取整\n                    for (int i = 0; i < n; i++) {\n                        sum[i / size] += nums[i];\n                    }\n                }\n            \n                void update(int index, int val) {\n                    sum[index / size] += val - nums[index];\n                    nums[index] = val;\n                }\n            \n                int sumRange(int left, int right) {\n                    int b1 = left / size, i1 = left % size, b2 = right / size, i2 = right % size;\n                    if (b1 == b2) { // 区间 [left, right] 在同一块中\n                        return accumulate(nums.begin() + b1 * size + i1, nums.begin() + b1 * size + i2 + 1, 0);\n                    }\n                    int sum1 = accumulate(nums.begin() + b1 * size + i1, nums.begin() + b1 * size + size, 0);\n                    int sum2 = accumulate(nums.begin() + b2 * size, nums.begin() + b2 * size + i2 + 1, 0);\n                    int sum3 = accumulate(sum.begin() + b1 + 1, sum.begin() + b2, 0);\n                    return sum1 + sum2 + sum3;\n                }\n            };\n        ","\n        class NumArray {\n            private:\n                vector<int> segmentTree;\n                int n;\n            \n                void build(int node, int s, int e, vector<int> &nums) {\n                    if (s == e) {\n                        segmentTree[node] = nums[s];\n                        return;\n                    }\n                    int m = s + (e - s) / 2;\n                    build(node * 2 + 1, s, m, nums);\n                    build(node * 2 + 2, m + 1, e, nums);\n                    segmentTree[node] = segmentTree[node * 2 + 1] + segmentTree[node * 2 + 2];\n                }\n            \n                void change(int index, int val, int node, int s, int e) {\n                    if (s == e) {\n                        segmentTree[node] = val;\n                        return;\n                    }\n                    int m = s + (e - s) / 2;\n                    if (index <= m) {\n                        change(index, val, node * 2 + 1, s, m);\n                    } else {\n                        change(index, val, node * 2 + 2, m + 1, e);\n                    }\n                    segmentTree[node] = segmentTree[node * 2 + 1] + segmentTree[node * 2 + 2];\n                }\n            \n                int range(int left, int right, int node, int s, int e) {\n                    if (left == s && right == e) {\n                        return segmentTree[node];\n                    }\n                    int m = s + (e - s) / 2;\n                    if (right <= m) {\n                        return range(left, right, node * 2 + 1, s, m);\n                    } else if (left > m) {\n                        return range(left, right, node * 2 + 2, m + 1, e);\n                    } else {\n                        return range(left, m, node * 2 + 1, s, m) + range(m + 1, right, node * 2 + 2, m + 1, e);\n                    }\n                }\n            \n            public:\n                NumArray(vector<int>& nums) : n(nums.size()), segmentTree(nums.size() * 4) {\n                    build(0, 0, n - 1, nums);\n                }\n            \n                void update(int index, int val) {\n                    change(index, val, 0, 0, n - 1);\n                }\n            \n                int sumRange(int left, int right) {\n                    return range(left, right, 0, 0, n - 1);\n                }\n            };\n        ","\n        class NumArray {\n            private:\n                vector<int> tree;\n                vector<int> &nums;\n            \n                int lowBit(int x) {\n                    return x & -x;\n                }\n            \n                void add(int index, int val) {\n                    while (index < tree.size()) {\n                        tree[index] += val;\n                        index += lowBit(index);\n                    }\n                }\n            \n                int prefixSum(int index) {\n                    int sum = 0;\n                    while (index > 0) {\n                        sum += tree[index];\n                        index -= lowBit(index);\n                    }\n                    return sum;\n                }\n            \n            public:\n                NumArray(vector<int>& nums) : tree(nums.size() + 1), nums(nums) {\n                    for (int i = 0; i < nums.size(); i++) {\n                        add(i + 1, nums[i]);\n                    }\n                }\n            \n                void update(int index, int val) {\n                    add(index + 1, val - nums[index]);\n                    nums[index] = val;\n                }\n            \n                int sumRange(int left, int right) {\n                    return prefixSum(right + 1) - prefixSum(left);\n                }\n            };\n        "]
    },
    {
        "id":159,
        "description":"\n        An additive number is a string whose digits can form an additive sequence.\n\nA valid additive sequence should contain at least three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.\n\nGiven a string containing only digits, return true if it is an additive number or false otherwise.\n\nNote: Numbers in the additive sequence cannot have leading zeros, so sequence 1, 2, 03 or 1, 02, 3 is invalid.\n\n \n\nExample 1:\n\nInput: \"112358\"\nOutput: true\nExplanation: \nThe digits can form an additive sequence: 1, 1, 2, 3, 5, 8. \n1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8\nExample 2:\n\nInput: \"199100199\"\nOutput: true\nExplanation: \nThe additive sequence is: 1, 99, 100, 199. \n1 + 99 = 100, 99 + 100 = 199\n \n\nConstraints:\n\n1 <= num.length <= 35\nnum consists only of digits.\n        ",
        "tag":["String","Backtracking"],
        "answer":["\n        class Solution {\n            public:\n                bool isAdditiveNumber(string num) {\n                    int n = num.size();\n                    for (int secondStart = 1; secondStart < n - 1; ++secondStart) {\n                        if (num[0] == '0' && secondStart != 1) {\n                            break;\n                        }\n                        for (int secondEnd = secondStart; secondEnd < n - 1; ++secondEnd) {\n                            if (num[secondStart] == '0' && secondStart != secondEnd) {\n                                break;\n                            }\n                            if (valid(secondStart, secondEnd, num)) {\n                                return true;\n                            }\n                        }\n                    }\n                    return false;\n                }\n            \n                bool valid(int secondStart, int secondEnd, string num) {\n                    int n = num.size();\n                    int firstStart = 0, firstEnd = secondStart - 1;\n                    while (secondEnd <= n - 1) {\n                        string third = stringAdd(num, firstStart, firstEnd, secondStart, secondEnd);\n                        int thirdStart = secondEnd + 1;\n                        int thirdEnd = secondEnd + third.size();\n                        if (thirdEnd >= n || !(num.substr(thirdStart, thirdEnd - thirdStart + 1) == third)) {\n                            break;\n                        }\n                        if (thirdEnd == n - 1) {\n                            return true;\n                        }\n                        firstStart = secondStart;\n                        firstEnd = secondEnd;\n                        secondStart = thirdStart;\n                        secondEnd = thirdEnd;\n                    }\n                    return false;\n                }\n            \n                string stringAdd(string s, int firstStart, int firstEnd, int secondStart, int secondEnd) {\n                    string third;\n                    int carry = 0, cur = 0;\n                    while (firstEnd >= firstStart || secondEnd >= secondStart || carry != 0) {\n                        cur = carry;\n                        if (firstEnd >= firstStart) {\n                            cur += s[firstEnd] - '0';\n                            --firstEnd;\n                        }\n                        if (secondEnd >= secondStart) {\n                            cur += s[secondEnd] - '0';\n                            --secondEnd;\n                        }\n                        carry = cur / 10;\n                        cur %= 10;\n                        third.push_back(cur + '0');\n                    }\n                    reverse(third.begin(), third.end());\n                    return third;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                // 大数加法模板\n                string add(string& a,string& b){\n                    int n1 = a.size()-1;\n                    int n2 = b.size()-1;\n                    int carry = 0;\n                    string ans;\n            \n                    while(n1>=0||n2>=0||carry>0){\n                        int t1=n1>=0?a[n1--]-'0':0;\n                        int t2=n2>=0?b[n2--]-'0':0;\n                        ans+=(t1+t2+carry)%10+'0';\n                        carry=(t1+t2+carry)/10;\n                    }\n            \n                    reverse(ans.begin(),ans.end());\n                    return ans;\n                }\n            \n                // num1: [i, j) + num2: [j, k) = sum: [k, ..)\n                bool valid(string& num, int i, int j, int k) {\n                    if (num[i] == '0' && j != i+1) return false;\n                    if (num[j] == '0' && k != j+1) return false;\n            \n                    string a = num.substr(i, j-i);\n                    string b = num.substr(j, k-j);\n            \n                    string sum = add(a, b);\n                    if (sum.size() + k > num.size()) return false;\n            \n            \n                    for (int s = 0; s <= sum.size() - 1; s++) {\n                        if (sum[s] != num[s+k]) return false;\n                    }\n                    if (sum.size() + k == num.size()) return true;\n            \n                    return valid(num, j, k, sum.size()+k);\n                }\n            \n                bool isAdditiveNumber(string num) {\n                    for (int i = 1; i < num.size(); i++) {\n                        for (int j = i+1; j < num.size(); j++) {\n                            if (valid(num, 0, i, j)) return true;\n                        }\n                    }\n                    return false;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool isAdditiveNumber(string num) {\n                    int i=0;\n                    for(int j=i+1;j<=num.size()-1;j++){\n                        for(int k=j+1;k<=num.size()-1;k++){\n                            if(dfs(num,i,j,k)) return true;\n                        }\n                    }\n                    return false;\n                }\n            \n                bool dfs(string& s,int i,int j,int k){\n                    if((s[i]=='0'&&j-i>1)||(s[j]=='0'&&k-j>1)) return false;\n                    string a=s.substr(i,j-i);\n                    string b=s.substr(j,k-j);\n                    string sum=add(a,b);\n                    int n=sum.size();\n                    if(k+n-1>s.size()-1||sum!=s.substr(k,n)) return false;\n                    if(k+n-1==s.size()-1) return true;\n                    return dfs(s,j,k,k+n);    \n                }\n            \n                string add(string& a,string& b){\n                    int n1=a.size()-1;\n                    int n2=b.size()-1;\n                    int carry=0;\n                    string ans;\n                    while(n1>=0||n2>=0||carry>0){\n                        int t1=n1>=0?a[n1--]-'0':0;\n                        int t2=n2>=0?b[n2--]-'0':0;\n                        ans+=(t1+t2+carry)%10+'0';\n                        carry=(t1+t2+carry)>=10?1:0;\n                    }\n                    reverse(ans.begin(),ans.end());\n                    return ans;\n                }\n            };\n        "]
    },
    {
        "id":160,
        "description":"\n        You are given an array prices where prices[i] is the price of a given stock on the i^th day.\n\nFind the maximum profit you can achieve. You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times) with the following restrictions:\n\nAfter you sell your stock, you cannot buy stock on the next day (i.e., cooldown one day).\nNote: You may not engage in multiple transactions simultaneously (i.e., you must sell the stock before you buy again).\n\n \n\nExample 1:\n\nInput: prices = [1,2,3,0,2]\nOutput: 3\nExplanation: transactions = [buy, sell, cooldown, buy, sell]\nExample 2:\n\nInput: prices = [1]\nOutput: 0\n \n\nConstraints:\n\n1 <= prices.length <= 5000\n0 <= prices[i] <= 1000\n        ",
        "tag":["Array","Dynamic Programming"],
        "answer":["\n        class Solution {\n            public:\n                int maxProfit(vector<int>& prices) {\n                    if (prices.empty()) {\n                        return 0;\n                    }\n            \n                    int n = prices.size();\n                    // f[i][0]: 手上持有股票的最大收益\n                    // f[i][1]: 手上不持有股票，并且处于冷冻期中的累计最大收益\n                    // f[i][2]: 手上不持有股票，并且不在冷冻期中的累计最大收益\n                    vector<vector<int>> f(n, vector<int>(3));\n                    f[0][0] = -prices[0];\n                    for (int i = 1; i < n; ++i) {\n                        f[i][0] = max(f[i - 1][0], f[i - 1][2] - prices[i]);\n                        f[i][1] = f[i - 1][0] + prices[i];\n                        f[i][2] = max(f[i - 1][1], f[i - 1][2]);\n                    }\n                    return max(f[n - 1][1], f[n - 1][2]);\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int maxProfit(vector<int>& prices) {\n                    if (prices.empty()) {\n                        return 0;\n                    }\n            \n                    int n = prices.size();\n                    int f0 = -prices[0];\n                    int f1 = 0;\n                    int f2 = 0;\n                    for (int i = 1; i < n; ++i) {\n                        int newf0 = max(f0, f2 - prices[i]);\n                        int newf1 = f0 + prices[i];\n                        int newf2 = max(f1, f2);\n                        f0 = newf0;\n                        f1 = newf1;\n                        f2 = newf2;\n                    }\n            \n                    return max(f1, f2);\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int maxProfit(vector<int> &prices) {\n                    int n = prices.size(), memo[n][2];\n                    memset(memo, -1, sizeof(memo)); // -1 表示还没有计算过\n                    function<int(int, bool)> dfs = [&](int i, bool hold) -> int {\n                        if (i < 0) return hold ? INT_MIN : 0;\n                        int &res = memo[i][hold];\n                        if (res != -1) return res;\n                        if (hold) return res = max(dfs(i - 1, true), dfs(i - 2, false) - prices[i]);\n                        return res = max(dfs(i - 1, false), dfs(i - 1, true) + prices[i]);\n                    };\n                    return dfs(n - 1, false);\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int maxProfit(vector<int> &prices) {\n                    int n = prices.size(), f[n + 2][2];\n                    memset(f, 0, sizeof(f));\n                    f[1][1] = INT_MIN;\n                    for (int i = 0; i < n; ++i) {\n                        f[i + 2][0] = max(f[i + 1][0], f[i + 1][1] + prices[i]);\n                        f[i + 2][1] = max(f[i + 1][1], f[i][0] - prices[i]);\n                    }\n                    return f[n + 1][0];\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int maxProfit(vector<int> &prices) {\n                    int pre0 = 0, f0 = 0, f1 = INT_MIN;\n                    for (int p: prices) {\n                        int new_f0 = max(f0, f1 + p); // f[i+2][0]\n                        f1 = max(f1, pre0 - p); // f[i+2][1]\n                        pre0 = f0;\n                        f0 = new_f0;\n                    }\n                    return f0;\n                }\n            };\n        "]
    },
    {
        "id":161,
        "description":"\n        You are given n balloons, indexed from 0 to n - 1. Each balloon is painted with a number on it represented by an array nums. You are asked to burst all the balloons.\n\nIf you burst the i^th balloon, you will get nums[i - 1] * nums[i] * nums[i + 1] coins. If i - 1 or i + 1 goes out of bounds of the array, then treat it as if there is a balloon with a 1 painted on it.\n\nReturn the maximum coins you can collect by bursting the balloons wisely.\n\n \n\nExample 1:\n\nInput: nums = [3,1,5,8]\nOutput: 167\nExplanation:\nnums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []\ncoins =  3*1*5    +   3*5*8   +  1*3*8  + 1*8*1 = 167\nExample 2:\n\nInput: nums = [1,5]\nOutput: 10\n \n\nConstraints:\n\nn == nums.length\n1 <= n <= 300\n0 <= nums[i] <= 100\n        ",
        "tag":["Array","Dynamic Programming"],
        "answer":["\n        class Solution {\n            public:\n                vector<vector<int>> rec;\n                vector<int> val;\n            \n            public:\n                int solve(int left, int right) {\n                    if (left >= right - 1) {\n                        return 0;\n                    }\n                    if (rec[left][right] != -1) {\n                        return rec[left][right];\n                    }\n                    for (int i = left + 1; i < right; i++) {\n                        int sum = val[left] * val[i] * val[right];\n                        sum += solve(left, i) + solve(i, right);\n                        rec[left][right] = max(rec[left][right], sum);\n                    }\n                    return rec[left][right];\n                }\n            \n                int maxCoins(vector<int>& nums) {\n                    int n = nums.size();\n                    val.resize(n + 2);\n                    for (int i = 1; i <= n; i++) {\n                        val[i] = nums[i - 1];\n                    }\n                    val[0] = val[n + 1] = 1;\n                    rec.resize(n + 2, vector<int>(n + 2, -1));\n                    return solve(0, n + 1);\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int maxCoins(vector<int>& nums) {\n                    int n = nums.size();\n                    vector<vector<int>> rec(n + 2, vector<int>(n + 2));\n                    vector<int> val(n + 2);\n                    val[0] = val[n + 1] = 1;\n                    for (int i = 1; i <= n; i++) {\n                        val[i] = nums[i - 1];\n                    }\n                    for (int i = n - 1; i >= 0; i--) {\n                        for (int j = i + 2; j <= n + 1; j++) {\n                            for (int k = i + 1; k < j; k++) {\n                                int sum = val[i] * val[k] * val[j];\n                                sum += rec[i][k] + rec[k][j];\n                                rec[i][j] = max(rec[i][j], sum);\n                            }\n                        }\n                    }\n                    return rec[0][n + 1];\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int maxCoins(vector<int>& nums) {\n                    // dp(i, j): 开区间(i, j)所能取得的最大硬币数量\n                    nums.insert(nums.begin(), 1);\n                    nums.push_back(1);\n                    int len = nums.size();\n                    vector<vector<int>> dp(len, vector<int>(len, 0));\n                    for(int i = len-1; i >=0; --i){ // i逆序：dp[k][j]中的k大于i\n                        for(int j = i+2; j <= len-1; ++j){ // j-i <= 1时区间为空，所以j从i+2开始\n                            for(int k = i+1; k < j; ++k){ // k取不到边界值，因为是空区间\n                                dp[i][j] = max(dp[i][j], dp[i][k] + nums[i] * nums[k] * nums[j] + dp[k][j]);\n                            }\n                            \n                        }\n                    }\n                    return dp[0][len-1];\n                }\n            };\n        "]
    },
    {
        "id":162,
        "description":"\n        A super ugly number is a positive integer whose prime factors are in the array primes.\n\nGiven an integer n and an array of integers primes, return the n^th super ugly number.\n\nThe n^th super ugly number is guaranteed to fit in a 32-bit signed integer.\n\n \n\nExample 1:\n\nInput: n = 12, primes = [2,7,13,19]\nOutput: 32\nExplanation: [1,2,4,7,8,13,14,16,19,26,28,32] is the sequence of the first 12 super ugly numbers given primes = [2,7,13,19].\nExample 2:\n\nInput: n = 1, primes = [2,3,5]\nOutput: 1\nExplanation: 1 has no prime factors, therefore all of its prime factors are in the array primes = [2,3,5].\n \n\nConstraints:\n\n1 <= n <= 10^5\n1 <= primes.length <= 100\n2 <= primes[i] <= 1000\nprimes[i] is guaranteed to be a prime number.\nAll the values of primes are unique and sorted in ascending order.\n        ",
        "tag":["Array","Math","Dynamic Programming"],
        "answer":["\n        class Solution {\n            public:\n                int nthSuperUglyNumber(int n, vector<int>& primes) {\n                    vector<long> dp(n + 1);\n                    int m = primes.size();\n                    vector<int> pointers(m, 0);\n                    vector<long> nums(m, 1);\n                    for (int i = 1; i <= n; i++) {\n                        long minNum = INT_MAX;\n                        for (int j = 0; j < m; j++) {\n                            minNum = min(minNum, nums[j]);\n                        }\n                        dp[i] = minNum;\n                        for (int j = 0; j < m; j++) {\n                            if (nums[j] == minNum) {\n                                pointers[j]++;\n                                nums[j] = dp[pointers[j]] * primes[j];\n                            }\n                        }\n                    }\n                    return dp[n];\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int nthSuperUglyNumber(int n, vector<int>& primes) {\n                    vector<int> dp(n + 1);  //用来存储丑数序列\n                    dp[1] = 1;          //第一个丑数是1\n                    int m = primes.size();\n                    vector<int> nums(m);     //记录新丑数序列\n                    vector<int> pointers(m, 1); //记录质数该与哪一位丑数做乘积\n                    for (int i = 2; i <= n; i++) {\n                        int minn = INT_MAX;\n                        for (int j = 0; j < m; j++) {\n                            nums[j] = dp[pointers[j]] * primes[j]; //旧丑数 * 质数序列 = 新丑数序列\n                            minn = min(minn, nums[j]);  //寻找所有新丑数中最小的丑数\n                        }\n                        dp[i] = minn;\n                        for (int j = 0; j < m; j++)\n                            if (minn == nums[j])        //如果此位置已经诞生过最小丑数\n                                pointers[j]++;          //让此位置所取旧丑数向后推一位\n                    }\n                    return dp[n];\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int nthSuperUglyNumber(int n, vector<int>& primes) {\n                    int length=primes.size();\n                    int dp[length];\n                    int a[n+1];\n                    for(int i=0;i<length;i++){\n                        dp[i]=1;\n                    }\n                    for(int i=1;i<=n;i++){\n                        a[n]=INT_MAX;\n                    }\n                    a[1]=1;\n                    int index;\n                    int min;\n                    for(int i=2;i<=n;i++){\n                        min=INT_MAX;\n                        for(int j=0;j<length;j++){\n                            if((long long)min>(long long)(primes[j]*(long long)a[dp[j]])){\n                                min=primes[j]*a[dp[j]];\n                                index=j;\n                            }\n                        }\n                        if(a[i-1]!=min){\n                            a[i]=min;\n                            dp[index]++;\n                        }\n                        else{\n                            dp[index]++;\n                            i--;\n                        }\n                    }\n                    return a[n];\n                }\n            };\n        "]
    },
    {
        "id":163,
        "description":"\n        Given an integer array nums, return an integer array counts where counts[i] is the number of smaller elements to the right of nums[i].\n\n \n\nExample 1:\n\nInput: nums = [5,2,6,1]\nOutput: [2,1,1,0]\nExplanation:\nTo the right of 5 there are 2 smaller elements (2 and 1).\nTo the right of 2 there is only 1 smaller element (1).\nTo the right of 6 there is 1 smaller element (1).\nTo the right of 1 there is 0 smaller element.\nExample 2:\n\nInput: nums = [-1]\nOutput: [0]\nExample 3:\n\nInput: nums = [-1,-1]\nOutput: [0,0]\n \n\nConstraints:\n\n1 <= nums.length <= 10^5\n-10^4 <= nums[i] <= 10^4\n        ",
        "tag":["Binary Indexed Tree","Segment Tree","Array","Binary Search","Divide and Conquer","Ordered Set","Merge Sort"],
        "answer":["\n        class Solution {\n            private:\n                vector<int> c;\n                vector<int> a;\n            \n                void Init(int length) {\n                    c.resize(length, 0);\n                }\n            \n                int LowBit(int x) {\n                    return x & (-x);\n                }\n            \n                void Update(int pos) {\n                    while (pos < c.size()) {\n                        c[pos] += 1;\n                        pos += LowBit(pos);\n                    }\n                }\n            \n                int Query(int pos) {\n                    int ret = 0;\n            \n                    while (pos > 0) {\n                        ret += c[pos];\n                        pos -= LowBit(pos);\n                    }\n            \n                    return ret;\n                }\n            \n                void Discretization(vector<int>& nums) {\n                    a.assign(nums.begin(), nums.end());\n                    sort(a.begin(), a.end());\n                    a.erase(unique(a.begin(), a.end()), a.end());\n                }\n                \n                int getId(int x) {\n                    return lower_bound(a.begin(), a.end(), x) - a.begin() + 1;\n                }\n            public:\n                vector<int> countSmaller(vector<int>& nums) {\n                    vector<int> resultList;\n            \n                    Discretization(nums);\n            \n                    Init(nums.size() + 5);\n                    \n                    for (int i = (int)nums.size() - 1; i >= 0; --i) {\n                        int id = getId(nums[i]);\n                        resultList.push_back(Query(id - 1));\n                        Update(id);\n                    }\n            \n                    reverse(resultList.begin(), resultList.end());\n            \n                    return resultList;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int lowbit(int x){\n                    return x & (-x);\n                }\n                void update(int i, vector<int>&C){\n                    while (i < C.size()) {\n                        C[i]++;\n                        i += lowbit(i);\n                    }\n                }\n                void query(int i, int j, vector<int>&C, vector<int>&counts){\n                    while (i >= 1) {\n                        counts[j] += C[i];\n                        i -= lowbit(i);\n                    }\n                }\n                vector<int> countSmaller(vector<int>& nums) {\n                    vector<int>counts(nums.size(), 0);\n                    if (nums.size() < 1) {\n                        return counts;\n                    }\n                    \n                    vector<int>N(nums);\n                    // Sort and unique\n                    sort(N.begin(), N.end());\n                    int slow = 1;\n                    int fast = 1;\n                    while(fast< N.size()) {\n                        if (N[fast] != N[slow - 1]) {\n                            N[slow] = N[fast];\n                            slow++;\n                            fast++;\n                        }else{\n                            fast++;\n                        }\n                    }\n                    N.resize(slow);\n                    \n                    // key: number, value: i\n                    map<int, int>m;\n                    for (int j = 1; j < 1 + N.size(); ++j) {\n                        m[N[j - 1]] = j;\n                    }\n                    \n                    // traverse\n                    vector<int>C(N.size() + 1, 0); //  C[i] is necessary, but A[i] not\n                    int i;\n                    for (int j = nums.size() - 1; j >= 0; --j) {\n                        i = m[nums[j]];\n                        update(i, C);\n                        if (i != 1) {\n                            query(i - 1, j, C, counts);\n                        }else{\n                            counts[j] = 0;\n                        }\n                    }\n                    return counts;\n                }\n            };\n        ","\n        \nclass Solution {\n    public:\n        vector<int> countSmaller(vector<int>& nums) {\n            vector<int>count;//保存结果\n            vector<pair<int,int> > num;//关联每个数和它的序号\n            for(int i =0;i<nums.size();++i)\n            {\n                count.push_back(0);\n                num.push_back(make_pair(nums[i],i));//保存每个数和它在原数组中的序号，以免在排序过程中打乱顺序\n            }\n            merge_sort(num,count);\n            return count;\n        }\n        \n        //归并排序\n        void merge_sort(vector<pair<int,int> >& vec, vector<int>& count)\n        {\n            if(vec.size()<2)\n                return;\n            \n            int mid = vec.size()/2;\n            vector<pair<int,int> > sub_vec1;\n            vector<pair<int,int> > sub_vec2;\n            for(int i =0;i<mid;++i)\n                sub_vec1.push_back(vec[i]);\n            for(int i =mid;i< vec.size();++i)\n                sub_vec2.push_back(vec[i]);\n            \n            merge_sort(sub_vec1,count);\n            merge_sort(sub_vec2,count);\n            vec.clear();\n            merge(sub_vec1,sub_vec2,vec,count);\n        }\n        \n        //合并两数组\n        void merge(vector<pair<int,int> >& sub_vec1,vector<pair<int,int> >& sub_vec2, vector<pair<int,int> >& vec, vector<int>& count)\n        {\n            int i =0;\n            int j =0;\n            while(i < sub_vec1.size() && j < sub_vec2.size())\n            {\n                if(sub_vec1[i].first <= sub_vec2[j].first )\n                {\n                    vec.push_back(sub_vec1[i]);\n                    count[sub_vec1[i].second] += j;//这句话和下面注释的地方就是这道题和归并排序的主要不同之处\n                    i++;\n                }else{\n                    vec.push_back(sub_vec2[j]);\n                    j++;\n                }\n            }\n            \n            for(;i<sub_vec1.size();++i)\n            {\n                vec.push_back(sub_vec1[i]);\n                count[sub_vec1[i].second] += j;// -。-\n            }\n            for(;j<sub_vec2.size();++j)\n            {\n                vec.push_back(sub_vec2[j]);           \n            }\n        }\n    };\n        "]
    },
    {
        "id":164,
        "description":"\n        Given a string s, remove duplicate letters so that every letter appears once and only once. You must make sure your result is \nthe smallest in lexicographical order\n among all possible results.\n\n \n\nExample 1:\n\nInput: s = \"bcabc\"\nOutput: \"abc\"\nExample 2:\n\nInput: s = \"cbacdcbc\"\nOutput: \"acdb\"\n \n\nConstraints:\n\n1 <= s.length <= 10^4\ns consists of lowercase English letters.\n        ",
        "tag":["Stack","Greedy","String","Monotonic Stack"],
        "answer":["\n        class Solution {\n            public:\n                string removeDuplicateLetters(string s) {\n                    vector<int> vis(26), num(26);\n                    for (char ch : s) {\n                        num[ch - 'a']++;\n                    }\n            \n                    string stk;\n                    for (char ch : s) {\n                        if (!vis[ch - 'a']) {\n                            while (!stk.empty() && stk.back() > ch) {\n                                if (num[stk.back() - 'a'] > 0) {\n                                    vis[stk.back() - 'a'] = 0;\n                                    stk.pop_back();\n                                } else {\n                                    break;\n                                }\n                            }\n                            vis[ch - 'a'] = 1;\n                            stk.push_back(ch);\n                        }\n                        num[ch - 'a'] -= 1;\n                    }\n                    return stk;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                string removeDuplicateLetters(string s) {\n                    vector<int> map(26, 0); // 记录字符串元素出现个数(为了保住最后一个元素不被弹出)\n                    vector<bool> visited(26, false); // 入栈登记表\n                    string result; // 栈本体 这里可以直接用string作为栈体\n                    for (char c : s) map[c - 'a']++; // 准备入栈各元素数量登记\n                    for (char c : s) {\n                        // 如果该元素进去过了 就不给进了 别忘了进不去的元素也要把数量减一\n                        if (visited[c - 'a']) { \n                            map[c - 'a']--;\n                            continue;\n                        }\n                        // 如果栈不空 栈顶大于准备压入的元素 栈顶元素不是最后一个幸存者 就要把栈顶弹出来\n                        while (!result.empty() && result.back() > c && map[result.back() - 'a'] > 0) {\n                            visited[result.back() - 'a'] = false; // 做好访客登记\n                            result.pop_back();               \n                        }\n                        result.push_back(c); // 新客入栈\n                        visited[c - 'a'] = true;       \n                        map[c - 'a']--;\n                    }\n                    return result;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                string removeDuplicateLetters(string s) {\n                    string stk;\n                    size_t i = 0;\n                    for(size_t i = 0;i < s.size(); ++i)\n                    {\n                        if(stk.find(s[i]) != string::npos) continue;\n                        while(!stk.empty()&& stk.back() > s[i]&& \n                            s.find(stk.back(), i) != string::npos)\n                            stk.pop_back();\n                        stk.push_back(s[i]);\n                    }\n                    return stk;\n                }\n            };\n        "]
    },
    {
        "id":165,
        "description":"\n        Given a string array words, return the maximum value of length(word[i]) * length(word[j]) where the two words do not share common letters. If no such two words exist, return 0.\n\n \n\nExample 1:\n\nInput: words = [\"abcw\",\"baz\",\"foo\",\"bar\",\"xtfn\",\"abcdef\"]\nOutput: 16\nExplanation: The two words can be \"abcw\", \"xtfn\".\nExample 2:\n\nInput: words = [\"a\",\"ab\",\"abc\",\"d\",\"cd\",\"bcd\",\"abcd\"]\nOutput: 4\nExplanation: The two words can be \"ab\", \"cd\".\nExample 3:\n\nInput: words = [\"a\",\"aa\",\"aaa\",\"aaaa\"]\nOutput: 0\nExplanation: No such pair of words.\n \n\nConstraints:\n\n2 <= words.length <= 1000\n1 <= words[i].length <= 1000\nwords[i] consists only of lowercase English letters.\n        ",
        "tag":["Bit Manipulation","Array","String"],
        "answer":["\n        class Solution {\n            public:\n                int maxProduct(vector<string>& words) {\n                    int length = words.size();\n                    vector<int> masks(length);\n                    for (int i = 0; i < length; i++) {\n                        string word = words[i];\n                        int wordLength = word.size();\n                        for (int j = 0; j < wordLength; j++) {\n                            masks[i] |= 1 << (word[j] - 'a');\n                        }\n                    }\n                    int maxProd = 0;\n                    for (int i = 0; i < length; i++) {\n                        for (int j = i + 1; j < length; j++) {\n                            if ((masks[i] & masks[j]) == 0) {\n                                maxProd = max(maxProd, int(words[i].size() * words[j].size()));\n                            }\n                        }\n                    }\n                    return maxProd;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int maxProduct(vector<string>& words) {\n                    unordered_map<int,int> map;\n                    int length = words.size();\n                    for (int i = 0; i < length; i++) {\n                        int mask = 0;\n                        string word = words[i];\n                        int wordLength = word.size();\n                        for (int j = 0; j < wordLength; j++) {\n                            mask |= 1 << (word[j] - 'a');\n                        }\n                        if(map.count(mask)) {\n                            if (wordLength > map[mask]) {\n                                map[mask] = wordLength;\n                            }\n                        } else {\n                            map[mask] = wordLength;\n                        }\n                        \n                    }\n                    int maxProd = 0;\n                    for (auto [mask1, _] : map) {\n                        int wordLength1 = map[mask1];\n                        for (auto [mask2, _] : map) {\n                            if ((mask1 & mask2) == 0) {\n                                int wordLength2 = map[mask2];\n                                maxProd = max(maxProd, wordLength1 * wordLength2);\n                            }\n                        }\n                    }\n                    return maxProd;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int max(int a, int b) { return a > b ? a : b; }\n            \n                int maxProduct(vector<string>& words) {\n                    unordered_map<int, int> bits;\n            \n                    for (auto w: words) {\n                        int bit = 0;\n                        for (auto c: w) {\n                            bit |= 1 << (c - 'a');\n                        }\n                        bits[bit] = max(bits[bit], w.size());\n                    }\n            \n                    vector<int> length(bits.size());\n            \n                    int ans = 0;\n            \n                    for (auto p1: bits) {\n                        for (auto p2: bits) {\n                            if ((p1.first & p2.first) == 0) {\n                                ans = max(ans, p1.second * p2.second);\n                            }\n                        }\n                    }\n            \n                    return ans;\n                }\n            };\n        "]
    },
    {
        "id":166,
        "description":"\n        You are given two integer arrays nums1 and nums2 of lengths m and n respectively. nums1 and nums2 represent the digits of two numbers. You are also given an integer k.\n\nCreate the maximum number of length k <= m + n from digits of the two numbers. The relative order of the digits from the same array must be preserved.\n\nReturn an array of the k digits representing the answer.\n\n \n\nExample 1:\n\nInput: nums1 = [3,4,6,5], nums2 = [9,1,2,5,8,3], k = 5\nOutput: [9,8,6,5,3]\nExample 2:\n\nInput: nums1 = [6,7], nums2 = [6,0,4], k = 5\nOutput: [6,7,6,0,4]\nExample 3:\n\nInput: nums1 = [3,9], nums2 = [8,9], k = 3\nOutput: [9,8,9]\n \n\nConstraints:\n\nm == nums1.length\nn == nums2.length\n1 <= m, n <= 500\n0 <= nums1[i], nums2[i] <= 9\n1 <= k <= m + n\n        ",
        "tag":["Stack","Greedy","Monotonic Stack"],
        "answer":["\n        class Solution {\n            public:\n                vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\n                    int m = nums1.size(), n = nums2.size();\n                    vector<int> maxSubsequence(k, 0);\n                    int start = max(0, k - n), end = min(k, m);\n                    for (int i = start; i <= end; i++) {\n                        vector<int> subsequence1(MaxSubsequence(nums1, i));\n                        vector<int> subsequence2(MaxSubsequence(nums2, k - i));\n                        vector<int> curMaxSubsequence(merge(subsequence1, subsequence2));\n                        if (compare(curMaxSubsequence, 0, maxSubsequence, 0) > 0) {\n                            maxSubsequence.swap(curMaxSubsequence);\n                        }\n                    }\n                    return maxSubsequence;\n                }\n            \n                vector<int> MaxSubsequence(vector<int>& nums, int k) {\n                    int length = nums.size();\n                    vector<int> stack(k, 0);\n                    int top = -1;\n                    int remain = length - k;\n                    for (int i = 0; i < length; i++) {\n                        int num = nums[i];\n                        while (top >= 0 && stack[top] < num && remain > 0) {\n                            top--;\n                            remain--;\n                        }\n                        if (top < k - 1) {\n                            stack[++top] = num;\n                        } else {\n                            remain--;\n                        }\n                    }\n                    return stack;\n                }\n            \n                vector<int> merge(vector<int>& subsequence1, vector<int>& subsequence2) {\n                    int x = subsequence1.size(), y = subsequence2.size();\n                    if (x == 0) {\n                        return subsequence2;\n                    }\n                    if (y == 0) {\n                        return subsequence1;\n                    }\n                    int mergeLength = x + y;\n                    vector<int> merged(mergeLength);\n                    int index1 = 0, index2 = 0;\n                    for (int i = 0; i < mergeLength; i++) {\n                        if (compare(subsequence1, index1, subsequence2, index2) > 0) {\n                            merged[i] = subsequence1[index1++];\n                        } else {\n                            merged[i] = subsequence2[index2++];\n                        }\n                    }\n                    return merged;\n                }\n            \n                int compare(vector<int>& subsequence1, int index1, vector<int>& subsequence2, int index2) {\n                    int x = subsequence1.size(), y = subsequence2.size();\n                    while (index1 < x && index2 < y) {\n                        int difference = subsequence1[index1] - subsequence2[index2];\n                        if (difference != 0) {\n                            return difference;\n                        }\n                        index1++;\n                        index2++;\n                    }\n                    return (x - index1) - (y - index2);\n                }\n            };\n        ","\n        class Solution {\n            public:\n                //求单调栈\n                vector<int> GetMonStack(vector<int> &nums,int length){\n                    stack<int> s;\n                    int n=nums.size();\n                    int drop_num=n-length;\n                    for(int i=0;i<n;++i){\n                        while(!s.empty() && s.top()<nums[i] && drop_num>0){\n                            s.pop();\n                            --drop_num;\n                        }\n                        if(s.size()<length)s.push(nums[i]);\n                        else --drop_num;\n                    }\n                    return [](stack<int> ss){vector<int> res(ss.size(),0);int i=ss.size()-1;while(!ss.empty()){res[i--]=ss.top();ss.pop();}return res;}(s);\n                }\n                //合并两个vector\n                vector<int> MergeVector(vector<int> &one,vector<int> &two){\n                    int size_one=one.size(),size_two=two.size();\n                    if(!size_one) return two;\n                    if(!size_two) return one;\n                    int a=0,b=0;\n                    int n=size_one+size_two,i=0;\n                    vector<int> res(size_one+size_two,0);\n                    while(i<n){\n                        if(compare(one,a,two,b)>0) res[i++]=one[a++];\n                        else res[i++]=two[b++];\n                    }\n                    return res;\n                }\n                //比较函数\n                int compare(vector<int>& one, int index1, vector<int>& two, int index2) {\n                    int x = one.size(), y = two.size();\n                    while (index1 < x && index2 < y) {\n                        int tag = one[index1++] - two[index2++];\n                        if (tag != 0) return tag;\n                    }\n                    return (x - index1) - (y - index2);\n                }\n                vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\n                    int size_num1=nums1.size(),size_num2=nums2.size();\n                    int start=max(0,k-size_num2),end=min(size_num1,k);\n                    vector<int> res(k,0);\n                    for(int i=start;i<=end;i++){\n                        vector<int> one(GetMonStack(nums1,i));\n                        vector<int> two(GetMonStack(nums2,k-i));\n                        vector<int> temp(MergeVector(one,two));\n                        if(compare(temp,0,res,0)>0) res.swap(temp);\n                    }\n                    return res;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<int> maxNumber(vector<int>& nums1, vector<int>& nums2, int k) {\n                    vector<int> res(k, 0);\n                    int n = nums1.size(), m = nums2.size();\n                    // 假设有最大子序列中有s个元素来自nums1，对所有可能的s值遍历\n                    for (int s=max(0, k-m); s<=min(k, n); s++){\n                        vector<int> temp;\n                        int i = 0, j = 0;\n                        // nums1中长度为s的最大子序列\n                        vector<int> temp1 = maxKsequence(nums1, s);\n                        // nums2中长度为k-s的最大子序列\n                        vector<int> temp2 = maxKsequence(nums2, k-s);\n                        // 对两个子序列进行归并\n                        // lexicographical_compare：比较两个序列的字典序大小\n                        auto iter1 = temp1.begin(), iter2 = temp2.begin();\n                        while (iter1 != temp1.end() || iter2 != temp2.end()){\n                            temp.push_back(lexicographical_compare(iter1, temp1.end(), iter2, temp2.end()) ? *iter2++ : *iter1++);\n                        }\n                        // 如果归并后的最大子序列大于目前已找到的最大子序列，则更新解\n                        res = lexicographical_compare(res.begin(), res.end(), temp.begin(), temp.end()) ? temp : res;\n                    }\n                    return res;\n                }\n            \n                // 求数组v的长度为k的最大子序列\n                vector<int> maxKsequence(vector<int> v, int k){\n                    int n = v.size();\n                    if (n <= k)\n                        return v;\n                    vector<int> res;\n                    int pop = n-k;\n                    for (int i=0; i<n; i++){\n                        while(!res.empty() && v[i]>res.back() && pop-->0)\n                            res.pop_back();\n                        res.push_back(v[i]);\n                    }\n                    res.resize(k);\n                    return res;\n                }\n            };\n        "]
    },
    {
        "id":167,
        "description":"\n        You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.\n\nReturn the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.\n\nYou may assume that you have an infinite number of each kind of coin.\n\n \n\nExample 1:\n\nInput: coins = [1,2,5], amount = 11\nOutput: 3\nExplanation: 11 = 5 + 5 + 1\nExample 2:\n\nInput: coins = [2], amount = 3\nOutput: -1\nExample 3:\n\nInput: coins = [1], amount = 0\nOutput: 0\n \n\nConstraints:\n\n1 <= coins.length <= 12\n1 <= coins[i] <= 2^31 - 1\n0 <= amount <= 10^4\n        ",
        "tag":["Breadth-First Search","Array","Dynamic Programming"],
        "answer":["\n        class Solution {\n            vector<int>count;\n            int dp(vector<int>& coins, int rem) {\n                if (rem < 0) return -1;\n                if (rem == 0) return 0;\n                if (count[rem - 1] != 0) return count[rem - 1];\n                int Min = INT_MAX;\n                for (int coin:coins) {\n                    int res = dp(coins, rem - coin);\n                    if (res >= 0 && res < Min) {\n                        Min = res + 1;\n                    }\n                }\n                count[rem - 1] = Min == INT_MAX ? -1 : Min;\n                return count[rem - 1];\n            }\n        public:\n            int coinChange(vector<int>& coins, int amount) {\n                if (amount < 1) return 0;\n                count.resize(amount);\n                return dp(coins, amount);\n            }\n        };\n        ","\n        class Solution {\n            public:\n                int coinChange(vector<int>& coins, int amount) {\n                    int Max = amount + 1;\n                    vector<int> dp(amount + 1, Max);\n                    dp[0] = 0;\n                    for (int i = 1; i <= amount; ++i) {\n                        for (int j = 0; j < (int)coins.size(); ++j) {\n                            if (coins[j] <= i) {\n                                dp[i] = min(dp[i], dp[i - coins[j]] + 1);\n                            }\n                        }\n                    }\n                    return dp[amount] > amount ? -1 : dp[amount];\n                }\n            };\n        ","\n        class Solution {\n            public:\n                void coinChange(vector<int>& coins, int amount, int c_index, int count, int& ans) {\n                    if (amount == 0) {\n                        ans = min(ans, count);\n                        return;\n                    }\n                    if (c_index == coins.size()) return;\n                    if (vi[amount][c_index] <= count) return;\n            \n                    for (int k = amount / coins[c_index]; k >= 0 && k + count < ans; k--) {\n                        int nextAmount = amount - k * coins[c_index];\n                        coinChange(coins, nextAmount, c_index + 1, count + k, ans);\n                    }\n                    vi[amount][c_index] = min(vi[amount][c_index], count);\n                }\n            \n                int coinChange(vector<int>& coins, int amount) {\n                    if (amount == 0) return 0;\n                    sort(coins.rbegin(), coins.rend());\n                    int ans = INT_MAX;\n                    vi = vector<vector<int>>(amount + 1, vector<int>(coins.size(), INT_MAX));\n                    coinChange(coins, amount, 0, 0, ans);\n                    return ans == INT_MAX ? -1 : ans;\n                }\n            \n            private:\n                vector<vector<int>> vi;\n            };\n        "]
    },
    {
        "id":168,
        "description":"\n        Given an integer array nums, reorder it such that nums[0] < nums[1] > nums[2] < nums[3]....\n\nYou may assume the input array always has a valid answer.\n\n \n\nExample 1:\n\nInput: nums = [1,5,1,1,6,4]\nOutput: [1,6,1,5,1,4]\nExplanation: [1,4,1,5,1,6] is also accepted.\nExample 2:\n\nInput: nums = [1,3,2,2,3,1]\nOutput: [2,3,1,3,1,2]\n \n\nConstraints:\n\n1 <= nums.length <= 5 * 10^4\n0 <= nums[i] <= 5000\nIt is guaranteed that there will be an answer for the given input nums.\n        ",
        "tag":["Array","Divide and Conquer","Quickselect","Sorting"],
        "answer":["\n        class Solution {\n            public:\n                void wiggleSort(vector<int>& nums) {\n                    int n = nums.size();\n                    vector<int> arr = nums;\n                    sort(arr.begin(), arr.end());\n                    int x = (n + 1) / 2;\n                    for (int i = 0, j = x - 1, k = n - 1; i < n; i += 2, j--, k--) {\n                        nums[i] = arr[j];\n                        if (i + 1 < n) {\n                            nums[i + 1] = arr[k];\n                        }\n                    }\n                }\n            };\n        ","\n        class Solution {\n            public:\n                void wiggleSort(vector<int>& nums) {\n                    int n = nums.size();\n                    int x = (n + 1) / 2;\n                    int mid = x - 1;\n                    nth_element(nums.begin(), nums.begin() + mid, nums.end());\n                    for (int k = 0, i = 0, j = n - 1; k <= j; k++) {\n                        if (nums[k] > nums[mid]) {\n                            while (j > k && nums[j] > nums[mid]) {\n                                j--;\n                            }\n                            swap(nums[k], nums[j--]);\n                        }\n                        if (nums[k] < nums[mid]) {\n                            swap(nums[k], nums[i++]);\n                        }\n                    }\n                    vector<int> arr = nums;\n                    for (int i = 0, j = x - 1, k = n - 1; i < n; i += 2, j--, k--) {\n                        nums[i] = arr[j];\n                        if (i + 1 < n) {\n                            nums[i + 1] = arr[k];\n                        }\n                    }\n                }\n            };\n        ","\n        class Solution {\n            public:\n                inline int transAddress(int i, int n) {\n                    return (2 * n - 2 * i - 1) % (n | 1);\n                }\n            \n                void wiggleSort(vector<int>& nums) {\n                    int n = nums.size();\n                    int x = (n + 1) / 2;\n                    int mid = x - 1;\n                    nth_element(nums.begin(), nums.begin() + mid, nums.end());\n                    int target = nums[mid];\n                    for (int k = 0, i = 0, j = n - 1; k <= j; k++) {\n                        if (nums[transAddress(k, n)] > target) {\n                            while (j > k && nums[transAddress(j, n)] > target) {\n                                j--;\n                            }\n                            swap(nums[transAddress(k, n)], nums[transAddress(j--, n)]);\n                        }\n                        if (nums[transAddress(k, n)] < target) {\n                            swap(nums[transAddress(k, n)], nums[transAddress(i++, n)]);\n                        }\n                    }\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int partitionAroundPivot(int left, int right, int pivot, vector<int> &nums) {\n                    int pivotValue = nums[pivot];\n                    int newPivot = left;\n                    swap(nums[pivot], nums[right]);\n                    for (int i = left; i < right; ++i) {\n                        if (nums[i] > pivotValue) {\n                            swap(nums[i], nums[newPivot++]);\n                        }\n                    }\n                    swap(nums[right], nums[newPivot]);\n                    return newPivot;\n                }\n            \n                int findKthLargest(vector<int> &nums, int k) {\n                    int left = 0, right = nums.size() - 1;\n                    default_random_engine gen((random_device())());\n                    while (left <= right) {\n                        uniform_int_distribution<int> dis(left, right);\n                        int pivot = dis(gen);\n                        int newPivot = partitionAroundPivot(left, right, pivot, nums);\n                        if (newPivot == k - 1) {\n                            return nums[newPivot];\n                        } else if (newPivot > k - 1) {\n                            right = newPivot - 1;\n                        } else { \n                            left = newPivot + 1;\n                        }\n                    }\n                    return nums[k - 1];\n                }\n            \n                inline int transAddress(int i, int n) {\n                    return (2 * n - 2 * i - 1) % (n | 1);\n                }\n            \n                void wiggleSort(vector<int>& nums) {\n                    int n = nums.size();\n                    int x = (n + 1) / 2;\n                    int mid = x - 1;\n                    int target = findKthLargest(nums, n - mid);\n                    for (int k = 0, i = 0, j = n - 1; k <= j; k++) {\n                        if (nums[transAddress(k, n)] > target) {\n                            while (j > k && nums[transAddress(j, n)] > target) {\n                                j--;\n                            }\n                            swap(nums[transAddress(k, n)], nums[transAddress(j--, n)]);\n                        }\n                        if (nums[transAddress(k, n)] < target) {\n                            swap(nums[transAddress(k, n)], nums[transAddress(i++, n)]);\n                        }\n                    }\n                }\n            };\n        "]
    },
    {
        "id":169,
        "description":"\n        Given an integer n, return true if it is a power of three. Otherwise, return false.\n\nAn integer n is a power of three, if there exists an integer x such that n == 3^x.\n\n \n\nExample 1:\n\nInput: n = 27\nOutput: true\nExplanation: 27 = 3^3\nExample 2:\n\nInput: n = 0\nOutput: false\nExplanation: There is no x where 3^x = 0.\nExample 3:\n\nInput: n = -1\nOutput: false\nExplanation: There is no x where 3^x = (-1).\n \n\nConstraints:\n\n-2^31 <= n <= 2^31 - 1\n        ",
        "tag":["Recursion","Math"],
        "answer":["\n        class Solution {\n            public:\n                bool isPowerOfThree(int n) {\n                    while (n && n % 3 == 0) {\n                        n /= 3;\n                    }\n                    return n == 1;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool isPowerOfThree(int n) {\n                    return n > 0 && 1162261467 % n == 0;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool isPowerOfThree(int n) {\n                    while(n != 1) {\n                        if(n % 3 != 0 || n <= 0) {\n                            return false;\n                        }\n                        n /= 3;\n                    }\n                    return true;\n                }\n            };\n        "]
    },
    {
        "id":170,
        "description":"\n        Given an integer array nums and two integers lower and upper, return the number of range sums that lie in [lower, upper] inclusive.\n\nRange sum S(i, j) is defined as the sum of the elements in nums between indices i and j inclusive, where i <= j.\n\n \n\nExample 1:\n\nInput: nums = [-2,5,-1], lower = -2, upper = 2\nOutput: 3\nExplanation: The three ranges are: [0,0], [2,2], and [0,2] and their respective sums are: -2, -1, 2.\nExample 2:\n\nInput: nums = [0], lower = 0, upper = 0\nOutput: 1\n \n\nConstraints:\n\n1 <= nums.length <= 10^5\n-2^31 <= nums[i] <= 2^31 - 1\n-10^5 <= lower <= upper <= 10^5\nThe answer is guaranteed to fit in a 32-bit integer.\n        ",
        "tag":["Binary Indexed Tree","Segment Tree","Array","Binary Search","Divide and Conquer","Ordered Set","Merge Sort"],
        "answer":["\n        class Solution {\n            public:\n                int countRangeSumRecursive(vector<long>& sum, int lower, int upper, int left, int right) {\n                    if (left == right) {\n                        return 0;\n                    } else {\n                        int mid = (left + right) / 2;\n                        int n1 = countRangeSumRecursive(sum, lower, upper, left, mid);\n                        int n2 = countRangeSumRecursive(sum, lower, upper, mid + 1, right);\n                        int ret = n1 + n2;\n            \n                        // 首先统计下标对的数量\n                        int i = left;\n                        int l = mid + 1;\n                        int r = mid + 1;\n                        while (i <= mid) {\n                            while (l <= right && sum[l] - sum[i] < lower) l++;\n                            while (r <= right && sum[r] - sum[i] <= upper) r++;\n                            ret += (r - l);\n                            i++;\n                        }\n            \n                        // 随后合并两个排序数组\n                        vector<long> sorted(right - left + 1);\n                        int p1 = left, p2 = mid + 1;\n                        int p = 0;\n                        while (p1 <= mid || p2 <= right) {\n                            if (p1 > mid) {\n                                sorted[p++] = sum[p2++];\n                            } else if (p2 > right) {\n                                sorted[p++] = sum[p1++];\n                            } else {\n                                if (sum[p1] < sum[p2]) {\n                                    sorted[p++] = sum[p1++];\n                                } else {\n                                    sorted[p++] = sum[p2++];\n                                }\n                            }\n                        }\n                        for (int i = 0; i < sorted.size(); i++) {\n                            sum[left + i] = sorted[i];\n                        }\n                        return ret;\n                    }\n                }\n            \n                int countRangeSum(vector<int>& nums, int lower, int upper) {\n                    long s = 0;\n                    vector<long> sum{0};\n                    for(auto& v: nums) {\n                        s += v;\n                        sum.push_back(s);\n                    }\n                    return countRangeSumRecursive(sum, lower, upper, 0, sum.size() - 1);\n                }\n            };\n        ","\n        struct SegNode {\n            int lo, hi, add;\n            SegNode* lchild, *rchild;\n            SegNode(int left, int right): lo(left), hi(right), add(0), lchild(nullptr), rchild(nullptr) {}\n        };\n        \n        class Solution {\n        public:\n            SegNode* build(int left, int right) {\n                SegNode* node = new SegNode(left, right);\n                if (left == right) {\n                    return node;\n                }\n                int mid = (left + right) / 2;\n                node->lchild = build(left, mid);\n                node->rchild = build(mid + 1, right);\n                return node;\n            }\n        \n            void insert(SegNode* root, int val) {\n                root->add++;\n                if (root->lo == root->hi) {\n                    return;\n                }\n                int mid = (root->lo + root->hi) / 2;\n                if (val <= mid) {\n                    insert(root->lchild, val);\n                }\n                else {\n                    insert(root->rchild, val);\n                }\n            }\n        \n            int count(SegNode* root, int left, int right) const {\n                if (left > root->hi || right < root->lo) {\n                    return 0;\n                }\n                if (left <= root->lo && root->hi <= right) {\n                    return root->add;\n                }\n                return count(root->lchild, left, right) + count(root->rchild, left, right);\n            }\n        \n            int countRangeSum(vector<int>& nums, int lower, int upper) {\n                long long sum = 0;\n                vector<long long> preSum = {0};\n                for (int v: nums) {\n                    sum += v;\n                    preSum.push_back(sum);\n                }\n                \n                set<long long> allNumbers;\n                for (long long x: preSum) {\n                    allNumbers.insert(x);\n                    allNumbers.insert(x - lower);\n                    allNumbers.insert(x - upper);\n                }\n                // 利用哈希表进行离散化\n                unordered_map<long long, int> values;\n                int idx = 0;\n                for (long long x: allNumbers) {\n                    values[x] = idx;\n                    idx++;\n                }\n        \n                SegNode* root = build(0, values.size() - 1);\n                int ret = 0;\n                for (long long x: preSum) {\n                    int left = values[x - upper], right = values[x - lower];\n                    ret += count(root, left, right);\n                    insert(root, values[x]);\n                }\n                return ret;\n            }\n        };\n        ","\n        struct SegNode {\n            long long lo, hi;\n            int add;\n            SegNode* lchild, *rchild;\n            SegNode(long long left, long long right): lo(left), hi(right), add(0), lchild(nullptr), rchild(nullptr) {}\n        };\n        \n        class Solution {\n        public:\n            void insert(SegNode* root, long long val) {\n                root->add++;\n                if (root->lo == root->hi) {\n                    return;\n                }\n                long long mid = (root->lo + root->hi) >> 1;\n                if (val <= mid) {\n                    if (!root->lchild) {\n                        root->lchild = new SegNode(root->lo, mid);\n                    }\n                    insert(root->lchild, val);\n                }\n                else {\n                    if (!root->rchild) {\n                        root->rchild = new SegNode(mid + 1, root->hi);\n                    }\n                    insert(root->rchild, val);\n                }\n            }\n        \n            int count(SegNode* root, long long left, long long right) const {\n                if (!root) {\n                    return 0;\n                }\n                if (left > root->hi || right < root->lo) {\n                    return 0;\n                }\n                if (left <= root->lo && root->hi <= right) {\n                    return root->add;\n                }\n                return count(root->lchild, left, right) + count(root->rchild, left, right);\n            }\n        \n            int countRangeSum(vector<int>& nums, int lower, int upper) {\n                long long sum = 0;\n                vector<long long> preSum = {0};\n                for(int v: nums) {\n                    sum += v;\n                    preSum.push_back(sum);\n                }\n                \n                long long lbound = LLONG_MAX, rbound = LLONG_MIN;\n                for (long long x: preSum) {\n                    lbound = min({lbound, x, x - lower, x - upper});\n                    rbound = max({rbound, x, x - lower, x - upper});\n                }\n                \n                SegNode* root = new SegNode(lbound, rbound);\n                int ret = 0;\n                for (long long x: preSum) {\n                    ret += count(root, x - upper, x - lower);\n                    insert(root, x);\n                }\n                return ret;\n            }\n        };\n        ","\n        class BIT {\n            private:\n                vector<int> tree;\n                int n;\n            \n            public:\n                BIT(int _n): n(_n), tree(_n + 1) {}\n            \n                static constexpr int lowbit(int x) {\n                    return x & (-x);\n                }\n            \n                void update(int x, int d) {\n                    while (x <= n) {\n                        tree[x] += d;\n                        x += lowbit(x);\n                    }\n                }\n            \n                int query(int x) const {\n                    int ans = 0;\n                    while (x) {\n                        ans += tree[x];\n                        x -= lowbit(x);\n                    }\n                    return ans;\n                }\n            };\n            \n            class Solution {\n            public:\n                int countRangeSum(vector<int>& nums, int lower, int upper) {\n                    long long sum = 0;\n                    vector<long long> preSum = {0};\n                    for (int v: nums) {\n                        sum += v;\n                        preSum.push_back(sum);\n                    }\n                    \n                    set<long long> allNumbers;\n                    for (long long x: preSum) {\n                        allNumbers.insert(x);\n                        allNumbers.insert(x - lower);\n                        allNumbers.insert(x - upper);\n                    }\n                    // 利用哈希表进行离散化\n                    unordered_map<long long, int> values;\n                    int idx = 0;\n                    for (long long x: allNumbers) {\n                        values[x] = idx;\n                        idx++;\n                    }\n            \n                    int ret = 0;\n                    BIT bit(values.size());\n                    for (int i = 0; i < preSum.size(); i++) {\n                        int left = values[preSum[i] - upper], right = values[preSum[i] - lower];\n                        ret += bit.query(right + 1) - bit.query(left);\n                        bit.update(values[preSum[i]] + 1, 1);\n                    }\n                    return ret;\n                }\n            };\n        ","\n        class BalancedTree {\n            private:\n                struct BalancedNode {\n                    long long val;\n                    long long seed;\n                    int count;\n                    int size;\n                    BalancedNode* left;\n                    BalancedNode* right;\n            \n                    BalancedNode(long long _val, long long _seed): val(_val), seed(_seed), count(1), size(1), left(nullptr), right(nullptr) {}\n            \n                    BalancedNode* left_rotate() {\n                        int prev_size = size;\n                        int curr_size = (left ? left->size : 0) + (right->left ? right->left->size : 0) + count;\n                        BalancedNode* root = right;\n                        right = root->left;\n                        root->left = this;\n                        root->size = prev_size;\n                        size = curr_size;\n                        return root;\n                    }\n            \n                    BalancedNode* right_rotate() {\n                        int prev_size = size;\n                        int curr_size = (right ? right->size : 0) + (left->right ? left->right->size : 0) + count;\n                        BalancedNode* root = left;\n                        left = root->right;\n                        root->right = this;\n                        root->size = prev_size;\n                        size = curr_size;\n                        return root;\n                    }\n                };\n            \n            private:\n                BalancedNode* root;\n                int size;\n                mt19937 gen;\n                uniform_int_distribution<long long> dis;\n            \n            private:\n                BalancedNode* insert(BalancedNode* node, long long x) {\n                    if (!node) {\n                        return new BalancedNode(x, dis(gen));\n                    }\n                    ++node->size;\n                    if (x < node->val) {\n                        node->left = insert(node->left, x);\n                        if (node->left->seed > node->seed) {\n                            node = node->right_rotate();\n                        }\n                    }\n                    else if (x > node->val) {\n                        node->right = insert(node->right, x);\n                        if (node->right->seed > node->seed) {\n                            node = node->left_rotate();\n                        }\n                    }\n                    else {\n                        ++node->count;\n                    }\n                    return node;\n                }\n            \n            public:\n                BalancedTree(): root(nullptr), size(0), gen(random_device{}()), dis(LLONG_MIN, LLONG_MAX) {}\n            \n                long long get_size() const {\n                    return size;\n                }\n            \n                void insert(long long x) {\n                    ++size;\n                    root = insert(root, x);\n                }\n            \n                long long lower_bound(long long x) const {\n                    BalancedNode* node = root;\n                    long long ans = LLONG_MAX;\n                    while (node) {\n                        if (x == node->val) {\n                            return x;\n                        }\n                        if (x < node->val) {\n                            ans = node->val;\n                            node = node->left;\n                        }\n                        else {\n                            node = node->right;\n                        }\n                    }\n                    return ans;\n                }\n            \n                long long upper_bound(long long x) const {\n                    BalancedNode* node = root;\n                    long long ans = LLONG_MAX;\n                    while (node) {\n                        if (x < node->val) {\n                            ans = node->val;\n                            node = node->left;\n                        }\n                        else {\n                            node = node->right;\n                        }\n                    }\n                    return ans;\n                }\n            \n                pair<int, int> rank(long long x) const {\n                    BalancedNode* node = root;\n                    int ans = 0;\n                    while (node) {\n                        if (x < node->val) {\n                            node = node->left;\n                        }\n                        else {\n                            ans += (node->left ? node->left->size : 0) + node->count;\n                            if (x == node->val) {\n                                return {ans - node->count + 1, ans};\n                            }\n                            node = node->right;\n                        }\n                    }\n                    return {INT_MIN, INT_MAX};\n                }\n            };\n            \n            class Solution {\n            public:\n                int countRangeSum(vector<int>& nums, int lower, int upper) {\n                    long long sum = 0;\n                    vector<long long> preSum = {0};\n                    for (int v: nums) {\n                        sum += v;\n                        preSum.push_back(sum);\n                    }\n                    \n                    BalancedTree* treap = new BalancedTree();\n                    int ret = 0;\n                    for (long long x: preSum) {\n                        long long numLeft = treap->lower_bound(x - upper);\n                        int rankLeft = (numLeft == LLONG_MAX ? treap->get_size() + 1 : treap->rank(numLeft).first);\n                        long long numRight = treap->upper_bound(x - lower);\n                        int rankRight = (numRight == LLONG_MAX ? treap->get_size() : treap->rank(numRight).first - 1);\n                        ret += (rankRight - rankLeft + 1);\n                        treap->insert(x);\n                    }\n                    return ret;\n                }\n            };\n        "]
    },
    {
        "id":171,
        "description":"\n        Given a sorted integer array nums and an integer n, add/patch elements to the array such that any number in the range [1, n] inclusive can be formed by the sum of some elements in the array.\n\nReturn the minimum number of patches required.\n\n \n\nExample 1:\n\nInput: nums = [1,3], n = 6\nOutput: 1\nExplanation:\nCombinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.\nNow if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].\nPossible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].\nSo we only need 1 patch.\nExample 2:\n\nInput: nums = [1,5,10], n = 20\nOutput: 2\nExplanation: The two patches can be [2, 4].\nExample 3:\n\nInput: nums = [1,2,2], n = 5\nOutput: 0\n \n\nConstraints:\n\n1 <= nums.length <= 1000\n1 <= nums[i] <= 10^4\nnums is sorted in ascending order.\n1 <= n <= 2^31 - 1\n        ",
        "tag":["Greedy","Array"],
        "answer":["\n        class Solution {\n            public:\n                int minPatches(vector<int>& nums, int n) {\n                    int patches = 0;\n                    long long x = 1;\n                    int length = nums.size(), index = 0;\n                    while (x <= n) {\n                        if (index < length && nums[index] <= x) {\n                            x += nums[index];\n                            index++;\n                        } else {\n                            x <<= 1;\n                            patches++;\n                        }\n                    }\n                    return patches;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int minPatches(vector<int>& nums, int n) {\n                    long long maxi = 1, res = 0, i = 0;\n                    while (maxi <= n) \n                        if (i < nums.size() && nums[i] <= maxi)\n                            maxi += nums[i++];\n                        else \n                            maxi += maxi, ++res;\n                    return res;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int minPatches(vector<int>& nums, int n) {\n                    int i=0, rt=0;\n                    long cur=1;\n                    while (cur<=n)\n                    {\n                        if (i<nums.size() && nums[i]<=cur)\n                        {\n                            cur += nums[i];\n                            i++;\n                        }\n                        else\n                        {\n                            cur = cur*2;\n                            rt++;\n                        }\n                    }\n                    return rt;\n                }\n            };\n        "]
    },
    {
        "id":172,
        "description":"\n        Given an integer array nums, return true if there exists a triple of indices (i, j, k) such that i < j < k and nums[i] < nums[j] < nums[k]. If no such indices exists, return false.\n\n \n\nExample 1:\n\nInput: nums = [1,2,3,4,5]\nOutput: true\nExplanation: Any triplet where i < j < k is valid.\nExample 2:\n\nInput: nums = [5,4,3,2,1]\nOutput: false\nExplanation: No triplet exists.\nExample 3:\n\nInput: nums = [2,1,5,0,4,6]\nOutput: true\nExplanation: The triplet (3, 4, 5) is valid because nums[3] == 0 < nums[4] == 4 < nums[5] == 6.\n \n\nConstraints:\n\n1 <= nums.length <= 5 * 10^5\n-2^31 <= nums[i] <= 2^31 - 1\n        ",
        "tag":["Greedy","Array"],
        "answer":["\n        class Solution {\n            public:\n                bool increasingTriplet(vector<int>& nums) {\n                    int n = nums.size();\n                    if (n < 3) {\n                        return false;\n                    }\n                    vector<int> leftMin(n);\n                    leftMin[0] = nums[0];\n                    for (int i = 1; i < n; i++) {\n                        leftMin[i] = min(leftMin[i - 1], nums[i]);\n                    }\n                    vector<int> rightMax(n);\n                    rightMax[n - 1] = nums[n - 1];\n                    for (int i = n - 2; i >= 0; i--) {\n                        rightMax[i] = max(rightMax[i + 1], nums[i]);\n                    }\n                    for (int i = 1; i < n - 1; i++) {\n                        if (nums[i] > leftMin[i - 1] && nums[i] < rightMax[i + 1]) {\n                            return true;\n                        }\n                    }\n                    return false;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool increasingTriplet(vector<int>& nums) {\n                    int n = nums.size();\n                    if (n < 3) {\n                        return false;\n                    }\n                    int first = nums[0], second = INT_MAX;\n                    for (int i = 1; i < n; i++) {\n                        int num = nums[i];\n                        if (num > second) {\n                            return true;\n                        } else if (num > first) {\n                            second = num;\n                        } else {\n                            first = num;\n                        }\n                    }\n                    return false;\n                }\n            };\n        ","\n        class Solution {\n            public:\n              bool increasingTriplet(vector<int>& nums) {\n                int len = nums.size();\n                if (len < 3) return false;\n                int small = INT_MAX, mid = INT_MAX;\n                for (auto num : nums) {\n                  if (num <= small) {\n                    small = num;\n                  } else if (num <= mid) {\n                    mid = num;\n                  } \n                  else if (num > mid) {\n                    return true;\n                  }\n                }\n                return false;    \n              }\n            };\n        "]
    },
    {
        "id":173,
        "description":"\n        You are given a 0-indexed array of unique strings words.\n\nA palindrome pair is a pair of integers (i, j) such that:\n\n0 <= i, j < words.length,\ni != j, and\nwords[i] + words[j] (the concatenation of the two strings) is a \npalindrome\n.\nReturn an array of all the palindrome pairs of words.\n\n \n\nExample 1:\n\nInput: words = [\"abcd\",\"dcba\",\"lls\",\"s\",\"sssll\"]\nOutput: [[0,1],[1,0],[3,2],[2,4]]\nExplanation: The palindromes are [\"abcddcba\",\"dcbaabcd\",\"slls\",\"llssssll\"]\nExample 2:\n\nInput: words = [\"bat\",\"tab\",\"cat\"]\nOutput: [[0,1],[1,0]]\nExplanation: The palindromes are [\"battab\",\"tabbat\"]\nExample 3:\n\nInput: words = [\"a\",\"\"]\nOutput: [[0,1],[1,0]]\nExplanation: The palindromes are [\"a\",\"a\"]\n \n\nConstraints:\n\n1 <= words.length <= 5000\n0 <= words[i].length <= 300\nwords[i] consists of lowercase English letters.\n        ",
        "tag":["Trie","Array","Hash Table","String"],
        "answer":["\nclass Solution {\npublic:\nstruct trie3{\n    unordered_map<char, trie3*> children;\n    int isEnd; \n    string word; \n    trie3(): isEnd(-1), word(\"\") {};\n    ~trie3() {\n        children.erase(children.begin(), children.end());\n    };\n};\nunordered_map<trie3*, vector<pair<int, string>>> leaf; // 叶子结点的单词信息全村处在该leaf中\nvoid addWord(trie3* node, const string& w, const int& index) {\n    int count = 0; // 当count达到150时，前缀树不再存储\n    for(auto &&ch : w) {\n        if(node->children.find(ch) == node->children.end()) {\n            node->children[ch] = new trie3;\n        }\n        node = node->children[ch];\n        // 单词长度达到150时中断添加，作为叶子结点单独处理\n        if(++count == 150) {\n            node->isEnd = 5005; \n            leaf[node].emplace_back(index, w); \n            return;\n        }\n    }\n    node->isEnd = index;\n    node->word = w;\n}\n// 判别两单词 word + rev_w 能否形成回文\nbool bePalindrome(const string& word, const string& w, const string& rev_w) {\n    string rev_word = word;\n    reverse(rev_word.begin(), rev_word.end());\n    if(word + rev_w == w + rev_word) {\n        return true;\n    }\n    return false;\n}\n// 深搜查找从node节点开始的所有单词，并存入words数组中\nvoid dfsFindAllWords(trie3* node, const int& index, const string& w, const string& rev_w, vector<vector<int>>& result) {\n    for(auto &&[ch, child] : node->children) {\n        // 若当前孩子节点为深度150的叶子结点，则单独处理，跳到下一循环\n        if(child->isEnd == 5005) {\n            for(auto &&[idx, wd] : leaf[child]) {\n                if(bePalindrome(wd, w, rev_w)) {\n                    result.emplace_back(vector<int>{idx, index});\n                }\n            }\n            continue;\n        }\n        // 此时当前孩子节点为非叶子节点和单词末尾节点，且该单词与w形成回文，则加入words数组中\n        if(child->isEnd != -1 && bePalindrome(child->word, w, rev_w)) {\n            result.emplace_back(vector<int>{child->isEnd, index});\n        }\n        dfsFindAllWords(child, index, w, rev_w, result);\n    }\n}\nvoid matchWord(trie3* node, const int& index, string& w, vector<vector<int>>& result) {\n    string rev_w = w, rev_str; \n    reverse(rev_w.begin(), rev_w.end()); // 此时w就是翻转串，因此将w翻转回原串\n    // 检查根节点是否包含空串，再比较w是否为回文，若两条件成立，则空串和w组成回文，加入结果数组\n    if(node->isEnd != -1 && w == rev_w) {\n        result.emplace_back(vector<int>{node->isEnd, index});\n        result.emplace_back(vector<int>{index, node->isEnd});\n    }\n    bool flag = true; \n    int count = 0; \n    // 前缀树先匹配整个单词w，直至w的最后一个字符\n    for(auto &&ch : w) {\n        // 若找不到则说明匹配回文失败，出现了无法匹配的字符，则终止循环\n        if(node->children.find(ch) == node->children.end()) {\n            flag = false;\n            break;\n        }\n        node = node->children[ch];\n        // 当遍历到长度为150时，单独处理。此时单词w的长度 >= 150，node为叶子结点，可能存储多个前100位相同的前缀且长度 >= 150的单词\n        if(++count == 150) {\n            flag = false;\n            for(auto &&[idx, wd] : leaf[node]) {\n                if(idx != index && bePalindrome(wd, w, rev_w)) {\n                    result.emplace_back(vector<int>{idx, index});\n                }\n            }\n            break;\n        }\n        // 若当前孩子节点为单词末尾节点，且该单词下标不等于index，则判别该单词能否和w形成回文串\n        if(node->isEnd != -1 && node->isEnd != index && bePalindrome(node->word, w, rev_w)) {\n            result.emplace_back(vector<int>{node->isEnd, index});\n        }\n    }\n    // 此时匹配完了w的所有字符，则继续深搜匹配直至叶子结点，找出长度长于w的单词\n    if(flag) {\n        dfsFindAllWords(node, index, w, rev_w, result);\n    }\n}\nvector<vector<int>> palindromePairs(vector<string>& words) {\n    vector<vector<int>> result;\n    int n = words.size(); \n    trie3* root = new trie3; // 标识正序前缀树\n    // 遍历所有单词，将单词加入正序前缀树，包括空串也加入，空串在前缀树根节点保留\n    for(int i = 0; i < n; ++i) {\n        addWord(root, words[i], i);\n    }\n    string word1 = \"\"; // 记录第一个单词\n    // 查找正序前缀树\n    for(int i = 0; i < n; ++i) {\n        if(words[i] == \"\") continue;\n        word1 = words[i];\n        reverse(word1.begin(), word1.end());\n        // 查找word2 + word1，由word1的翻转串去查找正序前缀树；直至查到叶子结点为止\n        matchWord(root, i, word1, result);\n    }\n    return result;\n}\n};\n        ","\n        vector<string> w5 = {};\nunordered_set<int> lens;\nvector<vector<int>> result5 = {};\n// 实现数组前缀树\nstruct  Trie5 {\n    int isEnd; // 标志是否为单词终止节点，是则值大于-1，且 isEnd等于该单词对应words中的下标。否则标识到当前字符为止的子串长度的负数\n    unordered_map<char, Trie5*> children; // 用于保留该前缀树的所有孩子节点信息；若size为空则为叶子结点\n    Trie5() : isEnd(-1) {};\n    ~Trie5() {\n        children.erase(children.begin(), children.end());\n    }\n};\nunordered_map<Trie5*, vector<int>> wordsIdx;\n// 向两前缀树添加单词，并向沿路节点添加该单词在words中的下标i，最后添加终止标志\nvoid addWord(Trie5* trie, Trie5* rev_trie, const int& id, const string& word) {\n    int n = word.size(); // 存储英文字母映射成的下标\n    char ch;\n    for(int i = 0; i < n; ++i) {\n        // 添加到正序前缀树\n        ch = word[i];\n        if(trie->children.find(ch) == trie->children.end()) {\n            trie->children[ch] = new Trie5;\n        }\n        trie = trie->children[ch];\n\n        // 添加到翻转前缀树\n        ch = word[n - 1 - i];\n        if(rev_trie->children.find(ch) == rev_trie->children.end()) {\n            rev_trie->children[ch] = new Trie5;\n        }\n        rev_trie = rev_trie->children[ch];\n\n        // 此时存在该长度的单词，因此保留经过该节点的单词下标\n        if(lens.find(i) != lens.end()) {\n            wordsIdx[trie].emplace_back(id);\n            wordsIdx[rev_trie].emplace_back(id);\n        }\n    }\n    trie->isEnd = rev_trie->isEnd = id;\n}\n// 判别是否为回文串\nbool isPalindrome(const string& word, int i, int j) {\n    while(i < j) {\n        if(word[i++] != word[j--]) return false;\n    }\n    return true;\n}\n// 对比两前缀树，找出能形成回文的单词对。从根节点开始，其中保持两前缀树节点同步移动\nvoid dfsFindAllPalindromePair(Trie5* trie, Trie5* rev_trie) {\n    int idx = trie->isEnd;\n    // 若当前trie节点为单词的末尾终止字符，则在另一个树中查找经过该节点的所有单词，其剩余子串的能否形成前缀树\n    if(idx != -1) {\n        // 查找另一前缀树对应节点所经过的所有单词\n        for(auto &&j : wordsIdx[rev_trie]) {\n            // 与trie当前节点单词不为同一单词\n            if(j != idx) {\n                // 此时rev翻转串剩余字符构成回文，则将 {trie, j}单词对加入结果集。这个包括了正好为trie翻转串的情况\n                if(isPalindrome(w5[j], 0, w5[j].size() - w5[idx].size() - 1)) {\n                    result5.emplace_back(vector<int>{idx, j});\n                }\n            }\n        }\n    }\n    idx = rev_trie->isEnd;\n    // 若当前rev_trie节点为单词的末尾终止字符，则在另一个树中查找长度超过该节点的所有单词，其剩余子串的能否形成前缀树\n    if(idx != -1) {\n        // 查找另一前缀树对应节点所经过的所有单词\n        for(auto &&i : wordsIdx[trie]) {\n            // 正序前缀树中长度长于当前rev_trie节点的单词。该条件就已经同时筛去了不与trie或rev_trie为同一单词这两点\n            if(w5[i].size() > w5[idx].size()) {\n                // 此时rev翻转串剩余字符构成回文，则将 {trie, j}单词对加入结果集。这个包括了正好为trie翻转串的情况\n                if(isPalindrome(w5[i], w5[idx].size(), w5[i].size() - 1)) {\n                    result5.emplace_back(vector<int>{i, idx});\n                }\n            }\n        }\n    }\n    // 从正序前缀树找翻转前缀树。若正序前缀树遍历完了，那么trie此时一定为叶子结点也为单词末尾字符，无论此时翻转前缀树是否遍历到叶子结点，\n    // 其rev_trie后是否还有子节点，在上面第一个if就已经处理和判别了rev_trie剩余子串是否为回文这点，并加入了结果数组，因此不需重复考虑。\n    for(auto &&[ch, child] : trie->children) {\n        // 只有两个数同时存在相同节点才能往下找\n        if(rev_trie->children.find(ch) != rev_trie->children.end()) {\n            dfsFindAllPalindromePair(child, rev_trie->children[ch]);\n        }\n    }\n    delete trie; delete rev_trie;\n}\nvector<vector<int>> palindromePairs(vector<string>& words) {\n    int n = words.size(), null_idx = -1; // words大小、空串下标\n    w5 = words;\n    // 添加所有单词的长\n    for(auto &&word : words) {\n        lens.emplace(word.size() - 1);\n    }\n    vector<int> self_rev = {}; // 存储所有自回文串\n    Trie5* trie = new Trie5;\n    Trie5* rev_trie = new Trie5;\n    // 遍历所有单词生成正序前缀树、翻转前缀树，并判断是否为自回文串\n    for(int i = 0; i < n; ++i) {\n        // 判断是否为自回文，放在前面好不让空串加入前缀树\n        if(isPalindrome(words[i], 0, words[i].size() - 1)) {\n            if(words[i] == \"\") {\n                null_idx = i;\n                continue;\n            }\n            self_rev.emplace_back(i);\n        }\n        addWord(trie, rev_trie, i, words[i]);\n    }\n    result5 = {};\n    // 若存在空串，则先与所有自回文拼成单词对\n    if(null_idx != -1) {\n        for(auto && j : self_rev) {\n            result5.emplace_back(vector<int>{null_idx, j});\n            result5.emplace_back(vector<int>{j, null_idx});\n        }\n    }\n    // 遍历两个前缀树找出所有能拼接成回文串的单词对，屏蔽掉\n    dfsFindAllPalindromePair(trie, rev_trie);\n    return result5;\n}\n        ","\n        struct Tree {\n            int index, childs[26];\n        } rever[1500000], order[1500000];\n        int kids[1500000][27]; // 第一位存储孩子个数\n        unordered_map<int, vector<int>> nodes, rev_nodes;\n        \n        class Solution {\n        private:\n            unordered_set<int> lens;\n            vector<vector<int>> result;\n            int reverCnt = 0, orderCnt = 0;\n        public:\n            void insert(string &word, int index) {\n                int p1 = 0, p2 = 0, ch = 0;\n                int n = word.size();\n                for(int i = 0; i < n; ++i) {\n                    ch = word[i] - 'a';\n                    if(!order[p1].childs[ch]) {\n                        order[p1].childs[ch] = ++orderCnt;\n                        kids[p1][++kids[p1][0]] = ch;\n                    }\n                    p1 = order[p1].childs[ch];\n        \n                    ch = word[n - 1 - i] - 'a';\n                    if(!rever[p2].childs[ch]) {\n                        rever[p2].childs[ch] = ++reverCnt;\n                    }\n                    p2 = rever[p2].childs[ch];\n        \n                    // 若当前i为words中某个单词长度 - 1，则当前节点存储经过哪些单词\n                    if(lens.find(i) != lens.end()) {\n                        nodes[p1].emplace_back(index);\n                        rev_nodes[p2].emplace_back(index);\n                    }\n                }\n                order[p1].index = rever[p2].index = index;\n            }\n        \n            bool isPalindrome(const string& word, int i, int j) {\n                while(i < j) {\n                    if(word[i++] != word[j--]) return false;\n                }\n                return true;\n            }\n        \n            void dfsFindAllPalindromePair(const int& node1, const int& node2, const vector<string>& words) {\n                int idx = order[node1].index, len = 0;\n                // 若当前trie节点为单词的末尾终止字符，则在另一个树中查找经过该节点的所有单词，其剩余子串的能否形成前缀树\n                if(idx) {\n                    len = words[idx - 1].size() + 1;\n                    // 查找另一前缀树对应节点所经过的所有单词\n                    for(auto &&j : rev_nodes[node2]) {\n                        // 与trie当前节点单词不为同一单词\n                        if(j != idx) {\n                            // 此时rev翻转串剩余字符构成回文，则将 {trie, j}单词对加入结果集。这个包括了正好为trie翻转串的情况\n                            if(isPalindrome(words[j - 1], 0, words[j - 1].size() - len)) {\n                                result.emplace_back(vector<int>{idx - 1, j - 1});\n                            }\n                        }\n                    }\n                }\n                idx = rever[node2].index;\n                // 若当前rev_trie节点为单词的末尾终止字符，则在另一个树中查找长度超过该节点的所有单词，其剩余子串的能否形成前缀树\n                if(idx) {\n                    len = words[idx - 1].size();\n                    // 查找另一前缀树对应节点所经过的所有单词\n                    for(auto &&i : nodes[node1]) {\n                        // 正序前缀树中长度长于当前rev_trie节点的单词。该条件就已经同时筛去了不与trie或rev_trie为同一单词这两点\n                        if(words[i - 1].size() > len) {\n                            // 此时rev翻转串剩余字符构成回文，则将 {trie, j}单词对加入结果集。\n                            if(isPalindrome(words[i - 1], len, words[i - 1].size() - 1)) {\n                                result.emplace_back(vector<int>{i - 1, idx - 1});\n                            }\n                        }\n                    }\n                }\n                // 从正序前缀树找翻转前缀树。若正序前缀树遍历完了，那么trie此时一定为叶子结点也为单词末尾字符，无论此时翻转前缀树是否遍历到叶子结点，\n                // 其rev_trie后是否还有子节点，在上面第一个if就已经处理和判别了rev_trie剩余子串是否为回文这点，并加入了结果数组，因此不需重复考虑。\n                for(int i = 1; i <= kids[node1][0]; ++i) {\n                    // 只有两个数同时存在相同节点才能往下找\n                    if(rever[node2].childs[kids[node1][i]]) {\n                        dfsFindAllPalindromePair(order[node1].childs[kids[node1][i]], rever[node2].childs[kids[node1][i]], words);\n                    }\n                }\n            }\n        \n            vector<vector<int>> palindromePairs(vector<string>& words) {\n                int n = words.size(), null_idx = -1;\n        \n                for(auto &&word : words) {\n                    lens.emplace(word.size() - 1);\n                }\n                vector<int> self_rev = {}; // 存储所有自回文串\n                for(int i = 0; i < n; ++i) {\n                    // 判断是否为自回文，放在前面好不让空串加入前缀树\n                    if(isPalindrome(words[i], 0, words[i].size() - 1)) {\n                        if(words[i] == \"\") {\n                            null_idx = i;\n                            continue;\n                        }\n                        self_rev.emplace_back(i);\n                    }\n                    insert(words[i], i + 1);\n                }\n                // 若存在空串，则先与所有自回文拼成单词对\n                if(null_idx != -1) {\n                    for(auto && j : self_rev) {\n                        result.emplace_back(vector<int>{null_idx, j});\n                        result.emplace_back(vector<int>{j, null_idx});\n                    }\n                }\n                dfsFindAllPalindromePair(0, 0, words);\n                memset(rever, 0, (reverCnt + 1)*sizeof(Tree));\n                memset(order, 0, (orderCnt + 1)*sizeof(Tree));\n                memset(kids, 0, (orderCnt + 1)*sizeof(kids[0]));\n                nodes.erase(nodes.begin(), nodes.end());\n                rev_nodes.erase(rev_nodes.begin(), rev_nodes.end());\n                return result;\n            }\n        };\n        ","\n        struct Tree {\n            int index, childs[26];\n        } rever[1500000], order[1500000];\n        \n        class Solution {\n        private:\n            vector<vector<int>> ret = {};\n            int reverCnt = 0, orderCnt = 0;\n        public:\n            bool isPalindrome(const string& word, int i, int j) {\n                while(i < j) {\n                    if(word[i++] != word[j--]) return false;\n                }\n                return true;\n            }\n        \n            void insert(const string &word, const int& index) {\n                bool flag1 = true, flag2 = true;\n                // 正前缀树节点、反前缀树节点，反前缀树中与正前缀树匹配的节点、正前缀树中与反前缀树匹配的节点，前面字符、后面字符\n                int p1 = 0, p2 = 0, find1 = 0, find2 = 0, ch1 = 0, ch2 = 0;\n                int n = word.size();\n                for(int i = 0; i < n; ++i) {\n                    if(flag1 && rever[find1].index && isPalindrome(word, i, n - 1)) {\n                        ret.emplace_back(vector<int>{index - 1, rever[find1].index - 1});\n                    }\n                    if(flag2 && order[find2].index && isPalindrome(word, 0, n - 1 - i)) {\n                        ret.emplace_back(vector<int>{order[find2].index - 1, index - 1});\n                    }\n        \n                    ch1 = word[i] - 'a', ch2 = word[n - 1 - i] - 'a';\n        \n                    if(flag1) {\n                        if(rever[find1].childs[ch1]) {\n                            find1 = rever[find1].childs[ch1];\n                        } else {\n                            flag1 = false;\n                        }\n                    }\n                    if(flag2) {\n                        if(order[find2].childs[ch2]) {\n                            find2 = order[find2].childs[ch2];\n                        } else {\n                            flag2 = false;\n                        }\n                    }\n        \n                    if(!order[p1].childs[ch1]) {\n                        order[p1].childs[ch1] = ++orderCnt;\n                    }\n                    p1 = order[p1].childs[ch1];\n        \n                    if(!rever[p2].childs[ch2]) {\n                        rever[p2].childs[ch2] = ++reverCnt;\n                    }\n                    p2 = rever[p2].childs[ch2];\n                }\n                if(flag1 && rever[find1].index && rever[find1].index != index) {\n                    ret.emplace_back(vector<int>{rever[find1].index, index});\n                    ret.emplace_back(vector<int>{index, rever[find1].index});\n                }\n                order[p1].index = index;\n                rever[p2].index = index;\n            }\n        \n            vector<vector<int>> palindromePairs(vector<string>& words) {\n                int n = words.size();\n                vector<pair<string, int>> wordIdx(n); // 存储所有单词和对应下标\n                for(int i = 0; i < n; ++i) {\n                    wordIdx[i] = {words[i], i};\n                }\n                // 按单词长度升序\n                sort(wordIdx.begin(), wordIdx.end(), [](const pair<string, int>& a, const pair<string, int>& b) {\n                    return a.first.size() < b.first.size();\n                });\n        \n                // 单词由短到长加入双前缀树\n                for(int i = 0; i < n; ++i) {\n                    insert(wordIdx[i].first, wordIdx[i].second + 1);\n                }\n                memset(rever, 0, (reverCnt + 1)*sizeof(Tree)); reverCnt = 1;\n                memset(order, 0, (orderCnt + 1)*sizeof(Tree)); orderCnt = 1;\n                return ret;\n            }\n        };\n        ","\n        int children[1500000][26], r_children[1500000][26], isEnd[1500000], r_isEnd[1500000];\nclass Solution {\nprivate:\n    vector<vector<int>> ret = {};\n    int reverCnt = 0, orderCnt = 0;\npublic:\n    bool isPalindrome(const string& word, int i, int j) {\n        while(i < j) {\n            if(word[i++] != word[j--]) return false;\n        }\n        return true;\n    }\n\n    void insert(const string &word, const int& index) {\n        bool flag1 = true, flag2 = true;\n        // 正前缀树节点、反前缀树节点，反前缀树中与正前缀树匹配的节点、正前缀树中与反前缀树匹配的节点，前面字符、后面字符\n        int p1 = 0, p2 = 0, find1 = 0, find2 = 0, ch1 = 0, ch2 = 0;\n        int n = word.size();\n        for(int i = 0; i < n; ++i) {\n            if(flag1 && r_isEnd[find1] && isPalindrome(word, i, n - 1)) {\n                ret.emplace_back(vector<int>{index - 1, r_isEnd[find1] - 1});\n            }\n            if(flag2 && isEnd[find2] && isPalindrome(word, 0, n - 1 - i)) {\n                ret.emplace_back(vector<int>{isEnd[find2] - 1, index - 1});\n            }\n\n            ch1 = word[i] - 'a', ch2 = word[n - 1 - i] - 'a';\n\n            if(flag1) {\n                if(r_children[find1][ch1]) {\n                    find1 = r_children[find1][ch1];\n                } else {\n                    flag1 = false;\n                }\n            }\n            if(flag2) {\n                if(children[find2][ch2]) {\n                    find2 = children[find2][ch2];\n                } else {\n                    flag2 = false;\n                }\n            }\n\n            if(!children[p1][ch1]) {\n                children[p1][ch1] = ++orderCnt;\n            }\n            p1 = children[p1][ch1];\n\n            if(!r_children[p2][ch2]) {\n                r_children[p2][ch2] = ++reverCnt;\n            }\n            p2 = r_children[p2][ch2];\n        }\n        if(flag1 && r_isEnd[find1] && r_isEnd[find1] != index) {\n            ret.emplace_back(vector<int>{r_isEnd[find1] - 1, index - 1});\n            ret.emplace_back(vector<int>{index - 1, r_isEnd[find1] - 1});\n        }\n        isEnd[p1] = index;\n        r_isEnd[p2] = index;\n    }\n\n    vector<vector<int>> palindromePairs(vector<string>& words) {\n        int n = words.size();\n        vector<pair<string, int>> wordIdx(n); // 存储所有单词和对应下标\n        for(int i = 0; i < n; ++i) {\n            wordIdx[i] = {words[i], i};\n        }\n        // 按单词长度升序\n        sort(wordIdx.begin(), wordIdx.end(), [](const pair<string, int>& a, const pair<string, int>& b) {\n            return a.first.size() < b.first.size();\n        });\n\n        // 单词由短到长加入双前缀树\n        for(int i = 0; i < n; ++i) {\n            insert(wordIdx[i].first, wordIdx[i].second + 1);\n        }\n        memset(children, 0, (orderCnt + 1)*sizeof(children[0]));\n        memset(r_children, 0, (reverCnt + 1)*sizeof(r_children[0]));\n        memset(isEnd, 0, (orderCnt + 1)*sizeof(isEnd[0]));\n        memset(r_isEnd, 0, (reverCnt + 1)*sizeof(r_isEnd[0]));\n        return ret;\n    }\n};\n        ","\n        typedef unsigned long long ULL;\nconst unsigned long long mod3 = 1000000007; // 大质数作为模数\nvector<vector<int>> palindromePairs(vector<string>& words) {\n    int n = words.size();\n    ULL pows[301] = {1}; // 因为单词最多长度为301，因此幂最高为300\n    // 得到300位每一位的大小\n    for(int i = 1; i < 301; i++) {\n        pows[i] = pows[i - 1] * 26 % mod3;\n    }\n\n    ULL hash[n], rev_hash[n]; // 存储n个单词的hash值、n个单词翻转串的hash值。hash值是从串的右往左升位计算，和n进制数值的计算原理相同。\n    memset(hash, 0, sizeof hash), memset(rev_hash, 0, sizeof rev_hash);\n    int lens[n]; // 存储n个单词的长度\n    // 遍历所有单词，将单词映射成hash值\n    for(int i = 0; i < n; ++i) {\n        lens[i] = words[i].size();\n        // 遍历单词所有字符，生成两个hash值\n        for(int j = 0; j < lens[i]; ++j) {\n            rev_hash[i] = (rev_hash[i] + (words[i][j] - 96) * pows[j]) % mod3; // 从左往右升位\n            hash[i] = (hash[i] + (words[i][lens[i] - 1 - j] - 96) * pows[j]) % mod3; // 从右往左升位\n        }\n    }\n    vector<vector<int>> result = {};\n    // 遍历所有串，判断是否构成回文，构成则加入结果串。即判断：单词i的hash高位进位 + 单词j的hash = 单词j的rev_hash进位 + 单词i的rev_hash\n    for(int i = 0; i < n; ++i) {\n        for(int j = 0; j < n; ++j) {\n            if(i == j) continue;\n            if((hash[i] * pows[lens[j]] + hash[j]) % mod3 == (rev_hash[j] * pows[lens[i]] + rev_hash[i]) % mod3) {\n                result.emplace_back(vector<int>{i, j});\n            }\n        }\n    }\n    return result;\n}\n        "]
    },
    {
        "id":174,
        "description":"\n        Given an integer n, return an array ans of length n + 1 such that for each i (0 <= i <= n), ans[i] is the number of 1's in the binary representation of i.\n\n \n\nExample 1:\n\nInput: n = 2\nOutput: [0,1,1]\nExplanation:\n0 --> 0\n1 --> 1\n2 --> 10\nExample 2:\n\nInput: n = 5\nOutput: [0,1,1,2,1,2]\nExplanation:\n0 --> 0\n1 --> 1\n2 --> 10\n3 --> 11\n4 --> 100\n5 --> 101\n \n\nConstraints:\n\n0 <= n <= 10^5\n        ",
        "tag":["Bit Manipulation","Dynamic Programming"],
        "answer":["\n        class Solution {\n            public:\n                int countOnes(int x) {\n                    int ones = 0;\n                    while (x > 0) {\n                        x &= (x - 1);\n                        ones++;\n                    }\n                    return ones;\n                }\n            \n                vector<int> countBits(int n) {\n                    vector<int> bits(n + 1);\n                    for (int i = 0; i <= n; i++) {\n                        bits[i] = countOnes(i);\n                    }\n                    return bits;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<int> countBits(int n) {\n                    vector<int> bits(n + 1);\n                    int highBit = 0;\n                    for (int i = 1; i <= n; i++) {\n                        if ((i & (i - 1)) == 0) {\n                            highBit = i;\n                        }\n                        bits[i] = bits[i - highBit] + 1;\n                    }\n                    return bits;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<int> countBits(int n) {\n                    vector<int> bits(n + 1);\n                    for (int i = 1; i <= n; i++) {\n                        bits[i] = bits[i >> 1] + (i & 1);\n                    }\n                    return bits;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<int> countBits(int n) {\n                    vector<int> bits(n + 1);\n                    for (int i = 1; i <= n; i++) {\n                        bits[i] = bits[i & (i - 1)] + 1;\n                    }\n                    return bits;\n                }\n            };\n        "]
    },
    {
        "id":175,
        "description":"\n        You are given a nested list of integers nestedList. Each element is either an integer or a list whose elements may also be integers or other lists. Implement an iterator to flatten it.\n\nImplement the NestedIterator class:\n\nNestedIterator(List<NestedInteger> nestedList) Initializes the iterator with the nested list nestedList.\nint next() Returns the next integer in the nested list.\nboolean hasNext() Returns true if there are still some integers in the nested list and false otherwise.\nYour code will be tested with the following pseudocode:\n\ninitialize iterator with nestedList\nres = []\nwhile iterator.hasNext()\n    append iterator.next() to the end of res\nreturn res\nIf res matches the expected flattened list, then your code will be judged as correct.\n\n \n\nExample 1:\n\nInput: nestedList = [[1,1],2,[1,1]]\nOutput: [1,1,2,1,1]\nExplanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,1,2,1,1].\nExample 2:\n\nInput: nestedList = [1,[4,[6]]]\nOutput: [1,4,6]\nExplanation: By calling next repeatedly until hasNext returns false, the order of elements returned by next should be: [1,4,6].\n \n\nConstraints:\n\n1 <= nestedList.length <= 500\nThe values of the integers in the nested list is in the range [-10^6, 10^6].\n        ",
        "tag":["Stack","Tree","Depth-First Search","Design","Queue","Iterator"],
        "answer":["\n        class NestedIterator {\n            private:\n                vector<int> vals;\n                vector<int>::iterator cur;\n            \n                void dfs(const vector<NestedInteger> &nestedList) {\n                    for (auto &nest : nestedList) {\n                        if (nest.isInteger()) {\n                            vals.push_back(nest.getInteger());\n                        } else {\n                            dfs(nest.getList());\n                        }\n                    }\n                }\n            \n            public:\n                NestedIterator(vector<NestedInteger> &nestedList) {\n                    dfs(nestedList);\n                    cur = vals.begin();\n                }\n            \n                int next() {\n                    return *cur++;\n                }\n            \n                bool hasNext() {\n                    return cur != vals.end();\n                }\n            };\n        ","\n        class NestedIterator {\n            private:\n                // pair 中存储的是列表的当前遍历位置，以及一个尾后迭代器用于判断是否遍历到了列表末尾\n                stack<pair<vector<NestedInteger>::iterator, vector<NestedInteger>::iterator>> stk;\n            \n            public:\n                NestedIterator(vector<NestedInteger> &nestedList) {\n                    stk.emplace(nestedList.begin(), nestedList.end());\n                }\n            \n                int next() {\n                    // 由于保证调用 next 之前会调用 hasNext，直接返回栈顶列表的当前元素，然后迭代器指向下一个元素\n                    return stk.top().first++->getInteger();\n                }\n            \n                bool hasNext() {\n                    while (!stk.empty()) {\n                        auto &p = stk.top();\n                        if (p.first == p.second) { // 遍历到当前列表末尾，出栈\n                            stk.pop();\n                            continue;\n                        }\n                        if (p.first->isInteger()) {\n                            return true;\n                        }\n                        // 若当前元素为列表，则将其入栈，且迭代器指向下一个元素\n                        auto &lst = p.first++->getList();\n                        stk.emplace(lst.begin(), lst.end());\n                    }\n                    return false;\n                }\n            };\n        ","\n        class NestedIterator {\n            public:\n                NestedIterator(vector<NestedInteger> &nestedList) {\n                    for (int i = nestedList.size() - 1; i >= 0; --i) {\n                        st.push(nestedList[i]);\n                    }\n                }\n            \n                int next() {\n                    NestedInteger cur = st.top(); st.pop();\n                    return cur.getInteger();\n                }\n            \n                bool hasNext() {\n                    while (!st.empty()) {\n                        NestedInteger cur = st.top();\n                        if (cur.isInteger()) {\n                            return true;\n                        }\n                        st.pop();\n                        for (int i = cur.getList().size() - 1; i >= 0; --i) {\n                            st.push(cur.getList()[i]);\n                        }\n                    }\n                    return false;\n                }\n            private:\n                stack<NestedInteger> st;\n            };\n        "]
    },
    {
        "id":176,
        "description":"\n        Given an integer n, return true if it is a power of four. Otherwise, return false.\n\nAn integer n is a power of four, if there exists an integer x such that n == 4^x.\n\n \n\nExample 1:\n\nInput: n = 16\nOutput: true\nExample 2:\n\nInput: n = 5\nOutput: false\nExample 3:\n\nInput: n = 1\nOutput: true\n \n\nConstraints:\n\n-2^31 <= n <= 2^31 - 1\n        ",
        "tag":["Bit Manipulation","Recursion","Math"],
        "answer":["\n        class Solution {\n            public:\n                bool isPowerOfFour(int n) {\n                    return n > 0 && (n & (n - 1)) == 0 && (n & 0xaaaaaaaa) == 0;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool isPowerOfFour(int n) {\n                    return n > 0 && (n & (n - 1)) == 0 && n % 3 == 1;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool isPowerOfFour(int n) {\n                    if(n==1)\n                        return true;\n                    if(n<4)\n                        return false;\n                    while(n!=1){\n                        if(n%4!=0)\n                            return false;\n                        n/=4;\n                    }\n                    return true;\n                }\n            };\n        "]
    },
    {
        "id":177,
        "description":"\n        Given an integer n, break it into the sum of k positive integers, where k >= 2, and maximize the product of those integers.\n\nReturn the maximum product you can get.\n\n \n\nExample 1:\n\nInput: n = 2\nOutput: 1\nExplanation: 2 = 1 + 1, 1 × 1 = 1.\nExample 2:\n\nInput: n = 10\nOutput: 36\nExplanation: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36.\n \n\nConstraints:\n\n2 <= n <= 58\n        ",
        "tag":["Math","Dynamic Programming"],
        "answer":["\n        class Solution {\n            public:\n                int integerBreak(int n) {\n                    vector <int> dp(n + 1);\n                    for (int i = 2; i <= n; i++) {\n                        int curMax = 0;\n                        for (int j = 1; j < i; j++) {\n                            curMax = max(curMax, max(j * (i - j), j * dp[i - j]));\n                        }\n                        dp[i] = curMax;\n                    }\n                    return dp[n];\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int integerBreak(int n) {\n                    if (n <= 3) {\n                        return n - 1;\n                    }\n                    vector <int> dp(n + 1);\n                    dp[2] = 1;\n                    for (int i = 3; i <= n; i++) {\n                        dp[i] = max(max(2 * (i - 2), 2 * dp[i - 2]), max(3 * (i - 3), 3 * dp[i - 3]));\n                    }\n                    return dp[n];\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int integerBreak(int n) {\n                    if (n <= 3) {\n                        return n - 1;\n                    }\n                    int quotient = n / 3;\n                    int remainder = n % 3;\n                    if (remainder == 0) {\n                        return (int)pow(3, quotient);\n                    } else if (remainder == 1) {\n                        return (int)pow(3, quotient - 1) * 4;\n                    } else {\n                        return (int)pow(3, quotient) * 2;\n                    }\n                }\n            };\n        "]
    },
    {
        "id":178,
        "description":"\n        Write a function that reverses a string. The input string is given as an array of characters s.\n\nYou must do this by modifying the input array in-place with O(1) extra memory.\n\n \n\nExample 1:\n\nInput: s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\nOutput: [\"o\",\"l\",\"l\",\"e\",\"h\"]\nExample 2:\n\nInput: s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\nOutput: [\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\n \n\nConstraints:\n\n1 <= s.length <= 10^5\ns[i] is a printable ascii character.\n        ",
        "tag":["Two Pointers","String"],
        "answer":["\n        class Solution {\n            public:\n                void reverseString(vector<char>& s) {\n                    int n = s.size();\n                    for (int left = 0, right = n - 1; left < right; ++left, --right) {\n                        swap(s[left], s[right]);\n                    }\n                }\n            };\n        ","\n        class Solution {\n            public:\n                void reverseString(vector<char>& s) {\n                    int n = s.size();\n                    char temp;\n                    for(int i=0,j=n-1;i<j;i++,j--)\n                    {\n                        temp = s[i];\n                        s[i] = s[j];\n                        s[j] = temp;\n                    }\n                }\n            };\n        ","\n        class Solution {\n            public:\n                void reverseString(vector<char>& s) {\n                    int left = 0, right = s.size() - 1;\n                    while (left < right){\n                        char tmp = s[right];\n                        s[right] = s[left];\n                        s[left] = tmp; \n                        ++left;\n                        --right;\n                    }\n                }\n            };\n        "]
    },
    {
        "id":179,
        "description":"\n        Given a string s, reverse only all the vowels in the string and return it.\n\nThe vowels are 'a', 'e', 'i', 'o', and 'u', and they can appear in both lower and upper cases, more than once.\n\n \n\nExample 1:\n\nInput: s = \"hello\"\nOutput: \"holle\"\nExample 2:\n\nInput: s = \"leetcode\"\nOutput: \"leotcede\"\n \n\nConstraints:\n\n1 <= s.length <= 3 * 10^5\ns consist of printable ASCII characters.\n        ",
        "tag":["Two Pointers","String"],
        "answer":["\n        class Solution {\n            public:\n                string reverseVowels(string s) {\n                    auto isVowel = [vowels = \"aeiouAEIOU\"s](char ch) {\n                        return vowels.find(ch) != string::npos;\n                    };\n            \n                    int n = s.size();\n                    int i = 0, j = n - 1;\n                    while (i < j) {\n                        while (i < n && !isVowel(s[i])) {\n                            ++i;\n                        }\n                        while (j > 0 && !isVowel(s[j])) {\n                            --j;\n                        }\n                        if (i < j) {\n                            swap(s[i], s[j]);\n                            ++i;\n                            --j;\n                        }\n                    }\n                    return s;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                string reverseVowels(string s) {\n                    vector<char> sNum;\n                    vector<char> yuanyin = {'a','e','i','o','u','A','E','I','O','U'};\n                    for(char x:s){\n                        for(int i=0;i<yuanyin.size();i++){\n                            if(x==yuanyin[i]){\n                                sNum.push_back(x);\n                                break;\n                            }\n                        }\n                    }\n                    int fl = sNum.size()-1;\n                    for(int k = 0;k<s.size();k++){\n                        for(int i=0;i<yuanyin.size();i++){\n                            if(s[k]==yuanyin[i]){\n                                s[k] = sNum[fl];\n                                fl--;\n                                break;\n                            }\n                        }\n                    }\n                    return s;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<char> yuanyin = {'a','e','i','o','u','A','E','I','O','U'};\n                bool isyuanyin(char x){\n                    for(int k=0;k<yuanyin.size();k++){\n                            if(x==yuanyin[k]){\n                                return true;\n                            }\n                        }\n                    return false;\n                }\n                string reverseVowels(string s) { \n                    int i= 0, j = s.size()-1;\n                    while(i<j){\n                        while(i<j&&!isyuanyin(s[i])){\n                            i++;\n                        }\n                        while(i<j&&!isyuanyin(s[j])){\n                            j--;\n                        }\n                        if(i<j){\n                            swap(s[i],s[j]);\n                            i++;\n                            j--;\n                        }\n                    }\n                    return s;\n                }\n            };\n        "]
    },
    {
        "id":180,
        "description":"\n        Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.\n\n \n\nExample 1:\n\nInput: nums = [1,1,1,2,2,3], k = 2\nOutput: [1,2]\nExample 2:\n\nInput: nums = [1], k = 1\nOutput: [1]\n \n\nConstraints:\n\n1 <= nums.length <= 10^5\n-10^4 <= nums[i] <= 10^4\nk is in the range [1, the number of unique elements in the array].\nIt is guaranteed that the answer is unique.\n        ",
        "tag":["Array","Hash Table","Divide and Conquer","Bucket Sort","Counting","Quickselect","Sorting","Heap (Priority Queue)"],
        "answer":["\n        class Solution {\n            public:\n                static bool cmp(pair<int, int>& m, pair<int, int>& n) {\n                    return m.second > n.second;\n                }\n            \n                vector<int> topKFrequent(vector<int>& nums, int k) {\n                    unordered_map<int, int> occurrences;\n                    for (auto& v : nums) {\n                        occurrences[v]++;\n                    }\n            \n                    // pair 的第一个元素代表数组的值，第二个元素代表了该值出现的次数\n                    priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(&cmp)> q(cmp);\n                    for (auto& [num, count] : occurrences) {\n                        if (q.size() == k) {\n                            if (q.top().second < count) {\n                                q.pop();\n                                q.emplace(num, count);\n                            }\n                        } else {\n                            q.emplace(num, count);\n                        }\n                    }\n                    vector<int> ret;\n                    while (!q.empty()) {\n                        ret.emplace_back(q.top().first);\n                        q.pop();\n                    }\n                    return ret;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                void qsort(vector<pair<int, int>>& v, int start, int end, vector<int>& ret, int k) {\n                    int picked = rand() % (end - start + 1) + start;\n                    swap(v[picked], v[start]);\n            \n                    int pivot = v[start].second;\n                    int index = start;\n                    for (int i = start + 1; i <= end; i++) {\n                        if (v[i].second >= pivot) {\n                            swap(v[index + 1], v[i]);\n                            index++;\n                        }\n                    }\n                    swap(v[start], v[index]);\n            \n                    if (k <= index - start) {\n                        qsort(v, start, index - 1, ret, k);\n                    } else {\n                        for (int i = start; i <= index; i++) {\n                            ret.push_back(v[i].first);\n                        }\n                        if (k > index - start + 1) {\n                            qsort(v, index + 1, end, ret, k - (index - start + 1));\n                        }\n                    }\n                }\n            \n                vector<int> topKFrequent(vector<int>& nums, int k) {\n                    unordered_map<int, int> occurrences;\n                    for (auto& v: nums) {\n                        occurrences[v]++;\n                    }\n            \n                    vector<pair<int, int>> values;\n                    for (auto& kv: occurrences) {\n                        values.push_back(kv);\n                    }\n                    vector<int> ret;\n                    qsort(values, 0, values.size() - 1, ret, k);\n                    return ret;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                void sift_up(vector<vector<int>> &heap, int chlid){\n                    vector<int> val = heap[chlid];\n                    while (chlid >> 1 > 0 && val[1] < heap[chlid>>1][1]){\n                        heap[chlid] = heap[chlid>>1];\n                        chlid >>= 1;\n                    heap[chlid] = val;\n                    }\n                }\n            \n                void sift_down(vector<vector<int>> &heap, int root, int k){\n                    vector<int> val = heap[root];\n                    while (root << 1 < k){\n                        int chlid = root << 1;\n                        // 注意这里位运算优先级要加括号\n                        if ((chlid|1) < k && heap[chlid|1][1] < heap[chlid][1]) chlid |= 1;\n                        if (heap[chlid][1] < val[1]){\n                            heap[root] = heap[chlid];\n                            root = chlid;\n                        }\n                        else break;\n                    }\n                    heap[root] = val;\n                }\n            \n                vector<int> topKFrequent(vector<int>& nums, int k) {\n                    unordered_map<int, int> stat;\n                    for (auto &num : nums) stat[num]++;\n                    vector<vector<int>> vec_stat;\n                    for (auto &item : stat) vec_stat.push_back({item.first, item.second});\n            \n                    vector<vector<int>> heap;\n                    heap.push_back({0, 0});\n                    for (int i = 0; i < k; i++){\n                        heap.push_back(vec_stat[i]);\n                        sift_up(heap, heap.size()-1);\n                    }\n            \n                    for (int i = k; i < vec_stat.size(); i++){\n                        if (vec_stat[i][1] > heap[1][1]){\n                            heap[1] = vec_stat[i];\n                            sift_down(heap, 1, k+1);\n                        }\n                    }\n            \n                    vector<int> result;\n                    for (int i = 1; i < k+1; i++) result.push_back(heap[i][0]);\n                    return result;\n                }\n            };\n        "]
    },
    {
        "id":181,
        "description":"\n        Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.\n\n \n\nExample 1:\n\nInput: nums1 = [1,2,2,1], nums2 = [2,2]\nOutput: [2]\nExample 2:\n\nInput: nums1 = [4,9,5], nums2 = [9,4,9,8,4]\nOutput: [9,4]\nExplanation: [4,9] is also accepted.\n \n\nConstraints:\n\n1 <= nums1.length, nums2.length <= 1000\n0 <= nums1[i], nums2[i] <= 1000\n        ",
        "tag":["Array","Hash Table","Two Pointers","Binary Search","Sorting"],
        "answer":["\n        class Solution {\n            public:\n                vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\n                    unordered_set<int> set1, set2;\n                    for (auto& num : nums1) {\n                        set1.insert(num);\n                    }\n                    for (auto& num : nums2) {\n                        set2.insert(num);\n                    }\n                    return getIntersection(set1, set2);\n                }\n            \n                vector<int> getIntersection(unordered_set<int>& set1, unordered_set<int>& set2) {\n                    if (set1.size() > set2.size()) {\n                        return getIntersection(set2, set1);\n                    }\n                    vector<int> intersection;\n                    for (auto& num : set1) {\n                        if (set2.count(num)) {\n                            intersection.push_back(num);\n                        }\n                    }\n                    return intersection;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\n                    sort(nums1.begin(), nums1.end());\n                    sort(nums2.begin(), nums2.end());\n                    int length1 = nums1.size(), length2 = nums2.size();\n                    int index1 = 0, index2 = 0;\n                    vector<int> intersection;\n                    while (index1 < length1 && index2 < length2) {\n                        int num1 = nums1[index1], num2 = nums2[index2];\n                        if (num1 == num2) {\n                            // 保证加入元素的唯一性\n                            if (!intersection.size() || num1 != intersection.back()) {\n                                intersection.push_back(num1);\n                            }\n                            index1++;\n                            index2++;\n                        } else if (num1 < num2) {\n                            index1++;\n                        } else {\n                            index2++;\n                        }\n                    }\n                    return intersection;\n                }\n            };\n        ","\n        \nclass Solution {\n    public:\n        vector<int> intersection(vector<int>& nums1, vector<int>& nums2) {\n        std::unordered_set<int> result;\n        std::unordered_set<int> nums1_set(nums1.begin(), nums1.end());              //将nums1用哈希法存储起来（unorderd_set实现）\n        for (int i : nums2) {\n            if (nums1_set.find(i) != nums1_set.end()) {\n                result.insert(i);\n            }\n        }\n        return vector<int>(result.begin(), result.end());\n    \n        }\n    };\n        "]
    },
    {
        "id":182,
        "description":"\n        Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must appear as many times as it shows in both arrays and you may return the result in any order.\n\n \n\nExample 1:\n\nInput: nums1 = [1,2,2,1], nums2 = [2,2]\nOutput: [2,2]\nExample 2:\n\nInput: nums1 = [4,9,5], nums2 = [9,4,9,8,4]\nOutput: [4,9]\nExplanation: [9,4] is also accepted.\n \n\nConstraints:\n\n1 <= nums1.length, nums2.length <= 1000\n0 <= nums1[i], nums2[i] <= 1000\n        ",
        "tag":["Array","Hash Table","Two Pointers","Binary Search","Sorting"],
        "answer":["\n        class Solution {\n            public:\n                vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\n                    if (nums1.size() > nums2.size()) {\n                        return intersect(nums2, nums1);\n                    }\n                    unordered_map <int, int> m;\n                    for (int num : nums1) {\n                        ++m[num];\n                    }\n                    vector<int> intersection;\n                    for (int num : nums2) {\n                        if (m.count(num)) {\n                            intersection.push_back(num);\n                            --m[num];\n                            if (m[num] == 0) {\n                                m.erase(num);\n                            }\n                        }\n                    }\n                    return intersection;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\n                    sort(nums1.begin(), nums1.end());\n                    sort(nums2.begin(), nums2.end());\n                    int length1 = nums1.size(), length2 = nums2.size();\n                    vector<int> intersection;\n                    int index1 = 0, index2 = 0;\n                    while (index1 < length1 && index2 < length2) {\n                        if (nums1[index1] < nums2[index2]) {\n                            index1++;\n                        } else if (nums1[index1] > nums2[index2]) {\n                            index2++;\n                        } else {\n                            intersection.push_back(nums1[index1]);\n                            index1++;\n                            index2++;\n                        }\n                    }\n                    return intersection;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<int> intersect(vector<int>& nums1, vector<int>& nums2) {\n                    vector<int> ans;\n                    unordered_map<int, int> hash;\n                    for (auto &i : nums1) ++hash[i];\n                    for (auto &i : nums2) {\n                        if (hash.find(i) != hash.end()) {\n                            ans.emplace_back(i);\n                            --hash[i];\n                            if (hash[i] == 0) hash.erase(i);\n                        }\n                    }\n                    return ans;\n                }\n            };\n        "]
    },
    {
        "id":183,
        "description":"\n        Given a data stream input of non-negative integers a1, a2, ..., an, summarize the numbers seen so far as a list of disjoint intervals.\n\nImplement the SummaryRanges class:\n\nSummaryRanges() Initializes the object with an empty stream.\nvoid addNum(int value) Adds the integer value to the stream.\nint[][] getIntervals() Returns a summary of the integers in the stream currently as a list of disjoint intervals [starti, endi]. The answer should be sorted by starti.\n \n\nExample 1:\n\nInput\n[\"SummaryRanges\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\", \"addNum\", \"getIntervals\"]\n[[], [1], [], [3], [], [7], [], [2], [], [6], []]\nOutput\n[null, null, [[1, 1]], null, [[1, 1], [3, 3]], null, [[1, 1], [3, 3], [7, 7]], null, [[1, 3], [7, 7]], null, [[1, 3], [6, 7]]]\n\nExplanation\nSummaryRanges summaryRanges = new SummaryRanges();\nsummaryRanges.addNum(1);      // arr = [1]\nsummaryRanges.getIntervals(); // return [[1, 1]]\nsummaryRanges.addNum(3);      // arr = [1, 3]\nsummaryRanges.getIntervals(); // return [[1, 1], [3, 3]]\nsummaryRanges.addNum(7);      // arr = [1, 3, 7]\nsummaryRanges.getIntervals(); // return [[1, 1], [3, 3], [7, 7]]\nsummaryRanges.addNum(2);      // arr = [1, 2, 3, 7]\nsummaryRanges.getIntervals(); // return [[1, 3], [7, 7]]\nsummaryRanges.addNum(6);      // arr = [1, 2, 3, 6, 7]\nsummaryRanges.getIntervals(); // return [[1, 3], [6, 7]]\n \n\nConstraints:\n\n0 <= value <= 10^4\nAt most 3 * 10^4 calls will be made to addNum and getIntervals.\nAt most 10^2 calls will be made to getIntervals.\n        ",
        "tag":["Design","Binary Search","Ordered Set"],
        "answer":["\n        class SummaryRanges {\n            private:\n                map<int, int> intervals;\n            \n            public:\n                SummaryRanges() {}\n                \n                void addNum(int val) {\n                    // 找到 l1 最小的且满足 l1 > val 的区间 interval1 = [l1, r1]\n                    // 如果不存在这样的区间，interval1 为尾迭代器\n                    auto interval1 = intervals.upper_bound(val);\n                    // 找到 l0 最大的且满足 l0 <= val 的区间 interval0 = [l0, r0]\n                    // 在有序集合中，interval0 就是 interval1 的前一个区间\n                    // 如果不存在这样的区间，interval0 为尾迭代器\n                    auto interval0 = (interval1 == intervals.begin() ? intervals.end() : prev(interval1));\n            \n                    if (interval0 != intervals.end() && interval0->first <= val && val <= interval0->second) {\n                        // 情况一\n                        return;\n                    }\n                    else {\n                        bool left_aside = (interval0 != intervals.end() && interval0->second + 1 == val);\n                        bool right_aside = (interval1 != intervals.end() && interval1->first - 1 == val);\n                        if (left_aside && right_aside) {\n                            // 情况四\n                            int left = interval0->first, right = interval1->second;\n                            intervals.erase(interval0);\n                            intervals.erase(interval1);\n                            intervals.emplace(left, right);\n                        }\n                        else if (left_aside) {\n                            // 情况二\n                            ++interval0->second;\n                        }\n                        else if (right_aside) {\n                            // 情况三\n                            int right = interval1->second;\n                            intervals.erase(interval1);\n                            intervals.emplace(val, right);\n                        }\n                        else {\n                            // 情况五\n                            intervals.emplace(val, val);\n                        }\n                    }\n                }\n                \n                vector<vector<int>> getIntervals() {\n                    vector<vector<int>> ans;\n                    for (const auto& [left, right]: intervals) {\n                        ans.push_back({left, right});\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class SummaryRanges {\n            public:\n                map<int, int> interval;\n                SummaryRanges() {}\n                void addNum(int val) {\n                    auto up = interval.upper_bound(val);\n                    auto down = (up == interval.begin() ? interval.end() : prev(up));\n            \n                    if (down != interval.end() && (val >= down->first && val <= down->second)) {\n            \n                    } else if ((up != interval.end() && up->first - 1 == val) && (down != interval.end() && down->second + 1 == val)) {\n                        int l = down->first, r = up->second;\n                        interval.erase(down->first);\n                        interval.erase(up->first);\n                        interval.emplace(l, r);\n                    } else if (down != interval.end() && down->second + 1 == val) {\n                        int l = down->first, r = val;\n                        interval.erase(l);\n                        interval.emplace(l, r);\n                    } else if (up != interval.end() && up->first - 1 == val) {\n                        int l = val, r = up->second;\n                        interval.erase(up->first);\n                        interval.emplace(l, r);\n                    } else {\n                        interval.emplace(val, val);\n                    }\n                    cout << interval.size() << endl;\n            \n                }\n            \n                vector<vector<int>> getIntervals() {\n                    vector<vector<int>> ans;\n                    for (auto& it : interval) {\n                        ans.push_back({it.first, it.second});\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class SummaryRanges {\n            public:\n                vector<vector<int>> v;\n                unordered_set<int> s;\n            \n                SummaryRanges() {\n            \n                }\n            \n                int binary_search(int target, int pos) {\n                    int l = 0, r = v.size() - 1, ans;\n                    while(l <= r) {\n                        int mid = (l + r) / 2;\n                        if(v[mid][pos] == target) {\n                            ans = mid;\n                            break;\n                        } else if(v[mid][pos] > target) {\n                            r = mid - 1;\n                        } else {\n                            l = mid + 1;\n                        }\n                    }\n                    return ans;\n                }\n                \n                void addNum(int val) {\n                    if(s.count(val)) return;\n                    // 未出现过\n                    s.insert(val);\n                    if(s.count(val + 1) && s.count(val - 1)) {\n                        // 需要合并 [..., val - 1] 和 [val + 1, ...] 两个区间\n                        int left = binary_search(val - 1, 1);\n                        int right = binary_search(val + 1, 0);\n                        // printf(\"val = %d, left = %d, right = %d\n\", val, left, right);\n                        v[left][1] = v[right][1];\n                        v.erase(v.begin() + right);\n                    } else if(s.count(val + 1)) {\n                        // val + 1 出现过，说明有以 val + 1 为左端点的区间\n                        // 二分查找该区间\n                        int ans = binary_search(val + 1, 0);\n                        // 找到的区间形如 [val + 1, ...]，需要修改为 [val, ...]\n                        v[ans][0] = val;\n                    } else if(s.count(val - 1)) {\n                        // 有以 val - 1 为右端点的区间\n                        int ans = binary_search(val - 1, 1);\n                        // 找到的区间形如 [..., val - 1]，需要修改为 [..., val]\n                        v[ans][1] = val;\n                    } else {\n                        // 左右都未出现，val 形成一个独立区间\n                        v.push_back(vector<int>{val, val});\n                    }\n            \n                    // 保证数组有序性\n                    sort(v.begin(), v.end());\n                }\n                \n                vector<vector<int>> getIntervals() {\n                    return v;\n                }\n            };\n        "]
    },
    {
        "id":184,
        "description":"\n        You are given a 2D array of integers envelopes where envelopes[i] = [wi, hi] represents the width and the height of an envelope.\n\nOne envelope can fit into another if and only if both the width and height of one envelope are greater than the other envelope's width and height.\n\nReturn the maximum number of envelopes you can Russian doll (i.e., put one inside the other).\n\nNote: You cannot rotate an envelope.\n\n \n\nExample 1:\n\nInput: envelopes = [[5,4],[6,4],[6,7],[2,3]]\nOutput: 3\nExplanation: The maximum number of envelopes you can Russian doll is 3 ([2,3] => [5,4] => [6,7]).\nExample 2:\n\nInput: envelopes = [[1,1],[1,1],[1,1]]\nOutput: 1\n \n\nConstraints:\n\n1 <= envelopes.length <= 10^5\nenvelopes[i].length == 2\n1 <= wi, hi <= 10^5\n        ",
        "tag":["Array","Binary Search","Dynamic Programming","Sorting"],
        "answer":["\n        class Solution {\n            public:\n                int maxEnvelopes(vector<vector<int>>& envelopes) {\n                    if (envelopes.empty()) {\n                        return 0;\n                    }\n                    \n                    int n = envelopes.size();\n                    sort(envelopes.begin(), envelopes.end(), [](const auto& e1, const auto& e2) {\n                        return e1[0] < e2[0] || (e1[0] == e2[0] && e1[1] > e2[1]);\n                    });\n            \n                    vector<int> f(n, 1);\n                    for (int i = 1; i < n; ++i) {\n                        for (int j = 0; j < i; ++j) {\n                            if (envelopes[j][1] < envelopes[i][1]) {\n                                f[i] = max(f[i], f[j] + 1);\n                            }\n                        }\n                    }\n                    return *max_element(f.begin(), f.end());\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int maxEnvelopes(vector<vector<int>>& envelopes) {\n                    if (envelopes.empty()) {\n                        return 0;\n                    }\n                    \n                    int n = envelopes.size();\n                    sort(envelopes.begin(), envelopes.end(), [](const auto& e1, const auto& e2) {\n                        return e1[0] < e2[0] || (e1[0] == e2[0] && e1[1] > e2[1]);\n                    });\n            \n                    vector<int> f = {envelopes[0][1]};\n                    for (int i = 1; i < n; ++i) {\n                        if (int num = envelopes[i][1]; num > f.back()) {\n                            f.push_back(num);\n                        }\n                        else {\n                            auto it = lower_bound(f.begin(), f.end(), num);\n                            *it = num;\n                        }\n                    }\n                    return f.size();\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int maxEnvelopes(vector<vector<int>>& envelopes) {\n                    int n = envelopes.size();\n                    // 先按照宽做排序，越大的放在越前面\n                    sort(envelopes.begin(), envelopes.end(), [](vector<int>& a, vector<int>& b){\n                        return a[0] > b[0];\n                    });\n            \n                    // 预开空间(不妨多开几个防溢出)\n                    vector<int> dp(n + 5);\n            \n                    int ans = 0;\n                    // 依次尝试放置每个信封\n                    for(int i = 0; i < n; i++){\n                        // 遍历他之前的每个信封，看能放下他且最多层的个数\n                        int maxh = 0;\n                        for(int j = 0; j < i; j++){\n                            // 判断是否可以放下当前的信封\n                            if(envelopes[j][0] > envelopes[i][0]\n                            && envelopes[j][1] > envelopes[i][1]){\n                                // 如果可以放下当前信封，看看是不是最大高度\n                                if(maxh < dp[j]){\n                                    maxh = dp[j];\n                                }\n                            }\n                        }\n                        // 遍历一圈，找到最高，且能放下当前信封的maxh\n                        dp[i] = maxh + 1;\n            \n                        // 判断当前信封高度是不是最高高度\n                        ans = max(ans, dp[i]);\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int maxEnvelopes(vector<vector<int>>& envelopes) {\n                    int n = envelopes.size();\n            \n                    // 首先执行排序，按照宽度排序，小的在前大的在后\n                    sort(envelopes.begin(), envelopes.end(), [](vector<int>& a, vector<int>& b){\n                        if(a[0] == b[0]){\n                            // 对于宽度相等的信封，根据高度逆序，大的在前小的在后\n                            return a[1] > b[1];\n                        }\n                        return a[0] < b[0];\n                    });\n            \n                    // 预开空间,设初始值为1,即仅包含当前信封\n                    vector<int> dp(n, 1);\n            \n                    int ans = 0;\n                    // 计算最长上升子序列\n                    for(int i = 0; i < n; i++){\n                        for(int j = 0; j < i; j++){\n                            if(envelopes[j][1] < envelopes[i][1]){\n                                // 如果h严格升序，尝试更新dp[i]\n                                dp[i] = max(dp[i], dp[j] + 1);\n                            }\n                        }\n                        // 尝试更新最大值ans\n                        ans = max(ans, dp[i]);\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int maxEnvelopes(vector<vector<int>>& envelopes) {\n                    int n = envelopes.size();\n            \n                    // 首先执行排序，按照宽度排序，小的在前大的在后\n                    sort(envelopes.begin(), envelopes.end(), [](vector<int>& a, vector<int>& b){\n                        if(a[0] == b[0]){\n                            // 对于宽度相等的信封，根据高度逆序，大的在前小的在后\n                            return a[1] > b[1];\n                        }\n                        return a[0] < b[0];\n                    });\n            \n                    // 预开空间,初始值为排序后第一个信封的高度\n                    vector<int> dp(1, envelopes[0][1]);\n            \n                    int ans = 0;\n                    // 计算最长上升子序列\n                    // 第0个元素已默认放入dp，因此从1开始遍历\n                    for(int i = 1; i < n; i++){\n                        // 搜索合适的更新位置\n                        int j = 0;\n                        for(; j < dp.size(); j++){\n                            // 需要注意，只要不小于当前大小，即可更新\n                            if(dp[j] >= envelopes[i][1]){\n                                dp[j] = envelopes[i][1];\n                                break;\n                            }\n                        }\n                        // 如果整个dp列表中，不含有比当前h大的值，则扩展dp列表\n                        if(j == dp.size()){\n                            dp.emplace_back(envelopes[i][1]);\n                        }\n                    }\n                    return dp.size();\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int maxEnvelopes(vector<vector<int>>& envelopes) {\n                    int n = envelopes.size();\n            \n                    // 首先执行排序，按照宽度排序，小的在前大的在后\n                    sort(envelopes.begin(), envelopes.end(), [](vector<int>& a, vector<int>& b){\n                        if(a[0] == b[0]){\n                            // 对于宽度相等的信封，根据高度逆序，大的在前小的在后\n                            return a[1] > b[1];\n                        }\n                        return a[0] < b[0];\n                    });\n            \n                    // 预开空间,初始值为排序后第一个信封的高度\n                    vector<int> dp(1, envelopes[0][1]);\n            \n                    int ans = 0;\n                    // 计算最长上升子序列\n                    // 第0个元素已默认放入dp，因此从1开始遍历\n                    for(int i = 1; i < n; i++){\n                        // 搜索合适的更新位置，使用二分模板\n                        // 额外引入一个index来记录满足条件合法的值\n                        // 有的人的模板中，只有l和r两个变量，但是那个边界条件我总是记不住\n                        // 引入一个新的变量，个人感觉逻辑更明朗\n                        int l = 0, r = dp.size() - 1;\n                        int index = -1;\n                        while(l <= r){\n                            // mid这里用l加一半的形式，不容易溢出int\n                            int mid = l + (r - l) / 2;\n                            if(dp[mid] >= envelopes[i][1]){\n                                // 我们要找的是dp数组中第一个大于等于当前h的位置\n                                // 因此在这里更新index值\n                                index = mid;\n                                r = mid - 1;\n                            }\n                            else{\n                                l = mid + 1;\n                            }\n                        }\n                        if(index == -1){\n                            dp.emplace_back(envelopes[i][1]);\n                        }\n                        else{\n                            dp[index] = envelopes[i][1];\n                        }\n                    }\n                    return dp.size();\n                }\n            };\n        "]
    },
    {
        "id":185,
        "description":"\n        Design a simplified version of Twitter where users can post tweets, follow/unfollow another user, and is able to see the 10 most recent tweets in the user's news feed.\n\nImplement the Twitter class:\n\nTwitter() Initializes your twitter object.\nvoid postTweet(int userId, int tweetId) Composes a new tweet with ID tweetId by the user userId. Each call to this function will be made with a unique tweetId.\nList<Integer> getNewsFeed(int userId) Retrieves the 10 most recent tweet IDs in the user's news feed. Each item in the news feed must be posted by users who the user followed or by the user themself. Tweets must be ordered from most recent to least recent.\nvoid follow(int followerId, int followeeId) The user with ID followerId started following the user with ID followeeId.\nvoid unfollow(int followerId, int followeeId) The user with ID followerId started unfollowing the user with ID followeeId.\n \n\nExample 1:\n\nInput\n[\"Twitter\", \"postTweet\", \"getNewsFeed\", \"follow\", \"postTweet\", \"getNewsFeed\", \"unfollow\", \"getNewsFeed\"]\n[[], [1, 5], [1], [1, 2], [2, 6], [1], [1, 2], [1]]\nOutput\n[null, null, [5], null, null, [6, 5], null, [5]]\n\nExplanation\nTwitter twitter = new Twitter();\ntwitter.postTweet(1, 5); // User 1 posts a new tweet (id = 5).\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5]. return [5]\ntwitter.follow(1, 2);    // User 1 follows user 2.\ntwitter.postTweet(2, 6); // User 2 posts a new tweet (id = 6).\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 2 tweet ids -> [6, 5]. Tweet id 6 should precede tweet id 5 because it is posted after tweet id 5.\ntwitter.unfollow(1, 2);  // User 1 unfollows user 2.\ntwitter.getNewsFeed(1);  // User 1's news feed should return a list with 1 tweet id -> [5], since user 1 is no longer following user 2.\n \n\nConstraints:\n\n1 <= userId, followerId, followeeId <= 500\n0 <= tweetId <= 10^4\nAll the tweets have unique IDs.\nAt most 3 * 10^4 calls will be made to postTweet, getNewsFeed, follow, and unfollow.\n        ",
        "tag":["Design","Hash Table","Linked List","Heap (Priority Queue)"],
        "answer":["\n        class Twitter {\n            struct Node {\n                // 哈希表存储关注人的 Id\n                unordered_set<int> followee;\n                // 用链表存储 tweetId\n                list<int> tweet;\n            };\n            // getNewsFeed 检索的推文的上限以及 tweetId 的时间戳\n            int recentMax, time;\n            // tweetId 对应发送的时间\n            unordered_map<int, int> tweetTime;\n            // 每个用户存储的信息\n            unordered_map<int, Node> user;\n        public:\n            Twitter() {\n                time = 0;\n                recentMax = 10;\n                user.clear();\n            }\n            \n            // 初始化\n            void init(int userId) {\n                user[userId].followee.clear();\n                user[userId].tweet.clear();\n            }\n        \n            void postTweet(int userId, int tweetId) {\n                if (user.find(userId) == user.end()) {\n                    init(userId);\n                }\n                // 达到限制，剔除链表末尾元素\n                if (user[userId].tweet.size() == recentMax) {\n                    user[userId].tweet.pop_back();\n                }\n                user[userId].tweet.push_front(tweetId);\n                tweetTime[tweetId] = ++time;\n            }\n            \n            vector<int> getNewsFeed(int userId) {\n                vector<int> ans; ans.clear();\n                for (list<int>::iterator it = user[userId].tweet.begin(); it != user[userId].tweet.end(); ++it) {\n                    ans.emplace_back(*it);\n                }\n                for (int followeeId: user[userId].followee) {\n                    if (followeeId == userId) continue; // 可能出现自己关注自己的情况\n                    vector<int> res; res.clear();\n                    list<int>::iterator it = user[followeeId].tweet.begin();\n                    int i = 0;\n                    // 线性归并\n                    while (i < (int)ans.size() && it != user[followeeId].tweet.end()) {\n                        if (tweetTime[(*it)] > tweetTime[ans[i]]) {\n                            res.emplace_back(*it);\n                            ++it;\n                        } else {\n                            res.emplace_back(ans[i]);\n                            ++i;\n                        }\n                        // 已经找到这两个链表合起来后最近的 recentMax 条推文\n                        if ((int)res.size() == recentMax) break;\n                    }\n                    for (; i < (int)ans.size() && (int)res.size() < recentMax; ++i) res.emplace_back(ans[i]);\n                    for (; it != user[followeeId].tweet.end() && (int)res.size() < recentMax; ++it) res.emplace_back(*it);\n                    ans.assign(res.begin(),res.end());\n                }\n                return ans;\n            }\n            \n            void follow(int followerId, int followeeId) {\n                if (user.find(followerId) == user.end()) {\n                    init(followerId);\n                }\n                if (user.find(followeeId) == user.end()) {\n                    init(followeeId);\n                }\n                user[followerId].followee.insert(followeeId);\n            }\n            \n            void unfollow(int followerId, int followeeId) {\n                user[followerId].followee.erase(followeeId);\n            }\n        };\n        ","\n        class Twitter {\n            public:\n                Twitter() {\n            \n                }\n                \n                void postTweet(int userId, int tweetId) {\n                    tweet_meesage.push_back({userId, tweetId});\n                }\n                \n                vector<int> getNewsFeed(int userId) {\n                    int news_count = 0;\n                    vector<int> result = {};\n                    for (int i = tweet_meesage.size() - 1; i >= 0; i--) {\n                        if (result.size() >= 10) {\n                            break;\n                        }\n                        if ((tweet_meesage[i].first == userId) || \n                            (follow_tbl[userId].find(tweet_meesage[i].first) != follow_tbl[userId].end())) {\n                            result.push_back(tweet_meesage[i].second);\n                        }\n                    }\n                    return result;\n                }\n                \n                void follow(int followerId, int followeeId) {\n                    follow_tbl[followerId].insert(followeeId);\n                }\n                \n                void unfollow(int followerId, int followeeId) {\n                    follow_tbl[followerId].erase(followeeId);\n                }\n                map <int, unordered_set<int>> follow_tbl;\n                vector<pair<int, int>> tweet_meesage = {};\n            };\n        ","\n        struct Tweet{\n            int id;\n            int time;\n            Tweet* next;\n            Tweet():id(0),time(0),next(nullptr){}\n            Tweet(int _id,int _time):id(_id),time(_time),next(nullptr){}\n            Tweet(int _id,int _time,Tweet* ptr):id(_id),time(_time),next(ptr){}\n        };  \n        \n        struct user{\n            unordered_set<int> s;\n            Tweet* tweethead;\n            user(){\n                s.clear();\n                tweethead=new Tweet();\n            }\n        };\n        \n        class Twitter {\n            int time;\n            unordered_map<int,user> users;\n        public:\n            Twitter() {\n                time=0;\n                users.clear();\n            }\n            \n            void postTweet(int userId, int tweetId) {\n                if(users.find(userId)==users.end())users[userId]=user();\n                Tweet* tmp=new Tweet(tweetId,++time);\n                tmp->next=users[userId].tweethead->next;\n                users[userId].tweethead->next=tmp; \n            }\n            \n            vector<int> getNewsFeed(int userId) {\n                struct Node{\n                    int id;\n                    int time;\n                    Tweet* ptr;\n                    Node(int _id,int _time,Tweet* t):id(_id),time(_time),ptr(t){}\n                    bool operator<(const Node& node)const{\n                        return time<node.time;\n                    }\n                };\n                priority_queue<Node> pq;\n                auto it=users[userId].tweethead->next;\n                if(it!=nullptr)pq.push({it->id,it->time,it});\n                for(auto& follow:users[userId].s){\n                    if(follow==userId)continue;\n                    auto tmp=users[follow].tweethead->next;\n                    if(tmp!=nullptr)pq.push({tmp->id,tmp->time,tmp});\n                }\n                vector<int> res;\n                while(!pq.empty()){\n                    auto its=pq.top();\n                    pq.pop();\n                    res.push_back(its.id);\n                    if(res.size()==10)break;\n                    if(its.ptr->next!=nullptr)pq.push({its.ptr->next->id,its.ptr->next->time,its.ptr->next});\n                }\n                return res;\n            }\n            \n            void follow(int followerId, int followeeId) {\n                if(users.find(followerId)==users.end())users[followerId]=user();\n                if(users.find(followeeId)==users.end())users[followeeId]=user();\n                users[followerId].s.insert(followeeId);\n            }\n            \n            void unfollow(int followerId, int followeeId) {\n                if(users.find(followerId)==users.end())users[followerId]=user();\n                if(users.find(followeeId)==users.end())users[followeeId]=user();\n                users[followerId].s.erase(followeeId);\n            }\n        };\n        "]
    },
    {
        "id":186,
        "description":"\n        Given an integer n, return the count of all numbers with unique digits, x, where 0 <= x < 10^n.\n\n \n\nExample 1:\n\nInput: n = 2\nOutput: 91\nExplanation: The answer should be the total numbers in the range of 0 ≤ x < 100, excluding 11,22,33,44,55,66,77,88,99\nExample 2:\n\nInput: n = 0\nOutput: 1\n \n\nConstraints:\n\n0 <= n <= 8\n        ",
        "tag":["Math","Dynamic Programming","Backtracking"],
        "answer":["\n        class Solution {\n            public:\n                int countNumbersWithUniqueDigits(int n) {\n                    if (n == 0) {\n                        return 1;\n                    }\n                    if (n == 1) {\n                        return 10;\n                    }\n                    int ans = 10, cur = 9;\n                    for (int i = 0; i < n - 1; ++i) {\n                        cur *= 9 - i;\n                        ans += cur;\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int countNumbersWithUniqueDigits(int n) {\n                    if(n == 0) return 1;\n                    n = min(n, 10);\n                    int ans = 10, base = 9, sum = 9;\n                    for(int i = 1; i < n; ++i){\n                        ans += sum *= base--;\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int countNumbersWithUniqueDigits(int n) {\n                    vector<int> dp(9, 0);\n                    dp[0] = 1;\n                    dp[1] = 10;\n                    for(int i=2; i<=n; i++){\n                        dp[i] = dp[i-1] + (dp[i-1]-dp[i-2])*(10-(i-1)); \n                    }\n                    return dp[n];\n                }\n            };\n        "]
    },
    {
        "id":187,
        "description":"\n        You are given two jugs with capacities jug1Capacity and jug2Capacity liters. There is an infinite amount of water supply available. Determine whether it is possible to measure exactly targetCapacity liters using these two jugs.\n\nIf targetCapacity liters of water are measurable, you must have targetCapacity liters of water contained within one or both buckets by the end.\n\nOperations allowed:\n\nFill any of the jugs with water.\nEmpty any of the jugs.\nPour water from one jug into another till the other jug is completely full, or the first jug itself is empty.\n \n\nExample 1:\n\nInput: jug1Capacity = 3, jug2Capacity = 5, targetCapacity = 4\nOutput: true\nExplanation: The famous Die Hard example \nExample 2:\n\nInput: jug1Capacity = 2, jug2Capacity = 6, targetCapacity = 5\nOutput: false\nExample 3:\n\nInput: jug1Capacity = 1, jug2Capacity = 2, targetCapacity = 3\nOutput: true\n \n\nConstraints:\n\n1 <= jug1Capacity, jug2Capacity, targetCapacity <= 10^6\n        ",
        "tag":["Depth-First Search","Breadth-First Search","Math"],
        "answer":["\n        using PII = pair<int, int>;\n\nclass Solution {\npublic:\n    bool canMeasureWater(int x, int y, int z) {\n        stack<PII> stk;\n        stk.emplace(0, 0);\n        auto hash_function = [](const PII& o) {return hash<int>()(o.first) ^ hash<int>()(o.second);};\n        unordered_set<PII, decltype(hash_function)> seen(0, hash_function);\n        while (!stk.empty()) {\n            if (seen.count(stk.top())) {\n                stk.pop();\n                continue;\n            }\n            seen.emplace(stk.top());\n            \n            auto [remain_x, remain_y] = stk.top();\n            stk.pop();\n            if (remain_x == z || remain_y == z || remain_x + remain_y == z) {\n                return true;\n            }\n            // 把 X 壶灌满。\n            stk.emplace(x, remain_y);\n            // 把 Y 壶灌满。\n            stk.emplace(remain_x, y);\n            // 把 X 壶倒空。\n            stk.emplace(0, remain_y);\n            // 把 Y 壶倒空。\n            stk.emplace(remain_x, 0);\n            // 把 X 壶的水灌进 Y 壶，直至灌满或倒空。\n            stk.emplace(remain_x - min(remain_x, y - remain_y), remain_y + min(remain_x, y - remain_y));\n            // 把 Y 壶的水灌进 X 壶，直至灌满或倒空。\n            stk.emplace(remain_x + min(remain_y, x - remain_x), remain_y - min(remain_y, x - remain_x));\n        }\n        return false;\n    }\n};\n        ","\n        class Solution {\n            public:\n                bool canMeasureWater(int x, int y, int z) {\n                    if (x + y < z) {\n                        return false;\n                    }\n                    if (x == 0 || y == 0) {\n                        return z == 0 || x + y == z;\n                    }\n                    return z % gcd(x, y) == 0;\n                }\n            };\n        ","\n        class Solution {\n            inline pair<int, int> op(int type, const pair<int, int> &state, int x, int y) {\n                switch(type) {\n                    case 0 : return make_pair(x, state.second);\n                    case 1 : return make_pair(state.first, y);\n                    case 2 : return make_pair(0, state.second);\n                    case 3 : return make_pair(state.first, 0);\n                    case 4 :{\n                        int move = min(state.first, y-state.second);\n                        return make_pair(state.first - move, state.second + move);\n                    }\n                    case 5 : {\n                        int move = min(x-state.first, state.second);\n                        return make_pair(state.first + move, state.second - move);\n                    }\n                }\n                return make_pair(0,0);\n            }\n            struct HashPair {\n                size_t operator()(const pair<int, int> &key) const noexcept\n                {\n                    return (size_t(key.first)<<31) | size_t(key.second);\n                }\n            };\n            inline int64_t Hash(int x, int y) {\n                return int64_t(x) << 32 | y;\n            }\n        public:\n            bool canMeasureWater(int x, int y, int z) {\n                if(x + y < z) {   //加了一个很蠢的剪枝，作用比较大。\n                    return false;\n                }\n                unordered_set<int64_t> mark; //pair<int, int> 换成int64_t, 但是意义不大。\n                queue<pair<int,int>> q;\n                q.push(make_pair(0,0));\n                while(q.empty() == false) {\n                    auto f = q.front();\n                    q.pop();\n                    if(f.first + f.second == z) {\n                        return true;\n                    }\n                    for(int i = 0; i < 6; i++) {\n                        auto next = op(i, f, x, y);\n                        int64_t h = Hash(next.first, next.second);\n                        if(mark.find(h) != mark.end()) {\n                            continue;\n                        }\n                        mark.insert(h);\n                        q.push(next);\n                    }\n                }\n                return false;\n            }\n        };\n        "]
    },
    {
        "id":188,
        "description":"\n        Given a positive integer num, return true if num is a perfect square or false otherwise.\n\nA perfect square is an integer that is the square of an integer. In other words, it is the product of some integer with itself.\n\nYou must not use any built-in library function, such as sqrt.\n\n \n\nExample 1:\n\nInput: num = 16\nOutput: true\nExplanation: We return true because 4 * 4 = 16 and 4 is an integer.\nExample 2:\n\nInput: num = 14\nOutput: false\nExplanation: We return false because 3.742 * 3.742 = 14 and 3.742 is not an integer.\n \n\nConstraints:\n\n1 <= num <= 2^31 - 1\n        ",
        "tag":["Math","Binary Search"],
        "answer":["\n        class Solution {\n            public:\n                bool isPerfectSquare(int num) {\n                    int x = (int) sqrt(num);\n                    return x * x == num;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool isPerfectSquare(int num) {\n                    long x = 1, square = 1;\n                    while (square <= num) {\n                        if (square == num) {\n                            return true;\n                        }\n                        ++x;\n                        square = x * x;\n                    }\n                    return false;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool isPerfectSquare(int num) {\n                    int left = 0, right = num;\n                    while (left <= right) {\n                        int mid = (right - left) / 2 + left;\n                        long square = (long) mid * mid;\n                        if (square < num) {\n                            left = mid + 1;\n                        } else if (square > num) {\n                            right = mid - 1;\n                        } else {\n                            return true;\n                        }\n                    }\n                    return false;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool isPerfectSquare(int num) {\n                    double x0 = num;\n                    while (true) {\n                        double x1 = (x0 + num / x0) / 2;\n                        if (x0 - x1 < 1e-6) {\n                            break;\n                        }\n                        x0 = x1;\n                    }\n                    int x = (int) x0;\n                    return x * x == num;\n                }\n            };\n        "]
    },
    {
        "id":189,
        "description":"\n        Given a set of distinct positive integers nums, return the largest subset answer such that every pair (answer[i], answer[j]) of elements in this subset satisfies:\n\nanswer[i] % answer[j] == 0, or\nanswer[j] % answer[i] == 0\nIf there are multiple solutions, return any of them.\n\n \n\nExample 1:\n\nInput: nums = [1,2,3]\nOutput: [1,2]\nExplanation: [1,3] is also accepted.\nExample 2:\n\nInput: nums = [1,2,4,8]\nOutput: [1,2,4,8]\n \n\nConstraints:\n\n1 <= nums.length <= 1000\n1 <= nums[i] <= 2 * 10^9\nAll the integers in nums are unique.\n        ",
        "tag":["Array","Math","Dynamic Programming","Sorting"],
        "answer":["\n        class Solution {\n            public:\n                vector<int> largestDivisibleSubset(vector<int>& nums) {\n                    int len = nums.size();\n                    sort(nums.begin(), nums.end());\n            \n                    // 第 1 步：动态规划找出最大子集的个数、最大子集中的最大整数\n                    vector<int> dp(len, 1);\n                    int maxSize = 1;\n                    int maxVal = dp[0];\n                    for (int i = 1; i < len; i++) {\n                        for (int j = 0; j < i; j++) {\n                            // 题目中说「没有重复元素」很重要\n                            if (nums[i] % nums[j] == 0) {\n                                dp[i] = max(dp[i], dp[j] + 1);\n                            }\n                        }\n            \n                        if (dp[i] > maxSize) {\n                            maxSize = dp[i];\n                            maxVal = nums[i];\n                        }\n                    }\n            \n                    // 第 2 步：倒推获得最大子集\n                    vector<int> res;\n                    if (maxSize == 1) {\n                        res.push_back(nums[0]);\n                        return res;\n                    }\n            \n                    for (int i = len - 1; i >= 0 && maxSize > 0; i--) {\n                        if (dp[i] == maxSize && maxVal % nums[i] == 0) {\n                            res.push_back(nums[i]);\n                            maxVal = nums[i];\n                            maxSize--;\n                        }\n                    }\n                    return res;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<int> largestDivisibleSubset(vector<int>& nums) {\n                    sort(nums.begin(), nums.end());\n                    int n = nums.size();\n                    vector<int> f(n, 0);\n                    vector<int> g(n ,0);\n                    \n                    for(int i = 0; i < n; i++) {\n                        // 至少包含自身一个数，因此起始长度为 1，由自身转移而来\n                        int len = 1, prev = i;\n                        for(int j = 0; j < i; j++) {\n                            if(nums[i] % nums[j] == 0) {\n                                // 如果能接在更长的序列后面，则更新「最大长度」&「从何转移而来」\n                                if(f[j] + 1 > len) {\n                                    len = f[j] + 1;\n                                    prev = j;\n                                }\n                            }\n                        }\n                        f[i] = len;\n                        g[i] = prev;\n                    }\n            \n                    // 遍历所有的 f[i]，取得「最大长度」和「对应下标」\n                    int idx = max_element(f.begin(), f.end()) - f.begin();\n                    int max = f[idx];\n            \n                    // 使用 g[] 数组回溯出具体方案\n                    vector<int> ans;\n                    while(ans.size() != max) {\n                        ans.push_back(nums[idx]);\n                        idx = g[idx];\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<int> largestDivisibleSubset(vector<int>& a) {\n                    int n=a.size(),p=0,ma=1;\n                    vector<int> dp(n),f(n),ans;\n                    sort(a.begin(),a.end());\n                    dp[0]=1,f[0]=-1;\n                    for(int i=1;i<n;i++){\n                        dp[i]=1;\n                        f[i]=-1;\n                        for(int j=0;j<i;j++)\n                            if(a[i]%a[j]==0&&dp[i]<dp[j]+1){\n                                dp[i]=dp[j]+1;\n                                f[i]=j;\n                            }\n                        if(dp[i]>ma){\n                            ma=dp[i];\n                            p=i;\n                        }\n                    }\n                    while(p>=0){\n                        ans.push_back(a[p]);\n                        p=f[p];\n                    }\n                    return ans;\n                }\n            };\n        "]
    },
    {
        "id":190,
        "description":"\n        Given two integers a and b, return the sum of the two integers without using the operators + and -.\n\n \n\nExample 1:\n\nInput: a = 1, b = 2\nOutput: 3\nExample 2:\n\nInput: a = 2, b = 3\nOutput: 5\n \n\nConstraints:\n\n-1000 <= a, b <= 1000\n        ",
        "tag":["Bit Manipulation","Math"],
        "answer":["\n        class Solution {\n            public:\n                int getSum(int a, int b) {\n                    while (b != 0) {\n                        unsigned int carry = (unsigned int)(a & b) << 1;\n                        a = a ^ b;\n                        b = carry;\n                    }\n                    return a;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int getSum(int a, int b) {\n                    if(!a) return b;\n                    int sum = a ^ b, carry = (unsigned)(a & b) << 1;\n                    return getSum(carry, sum);         \n                }\n            };\n        ","\n        class Solution {\n            public:\n                int getSum(int a, int b) {\n            \n                    while (b) {\n            \n                        int temp_add = a ^ b; //不包含进位a、b每位的和\n                        //a、b每位和的进位，左移有符号值会溢出，赋给无符号的会自动取模\n                        unsigned int temp_carry = (unsigned int)(a & b) << 1; \n                        a = temp_add; //a、b每位的和赋值给a\n                        b = temp_carry; //a、b每位的进位赋值给b\n                    }\n                    return a;\n                }\n            };\n        "]
    },
    {
        "id":191,
        "description":"\n        Your task is to calculate a^b mod 1337 where a is a positive integer and b is an extremely large positive integer given in the form of an array.\n\n \n\nExample 1:\n\nInput: a = 2, b = [3]\nOutput: 8\nExample 2:\n\nInput: a = 2, b = [1,0]\nOutput: 1024\nExample 3:\n\nInput: a = 1, b = [4,3,3,8,5,2]\nOutput: 1\n \n\nConstraints:\n\n1 <= a <= 2^31 - 1\n1 <= b.length <= 2000\n0 <= b[i] <= 9\nb does not contain leading zeros.\n        ",
        "tag":["Math","Divide and Conquer"],
        "answer":["\n        class Solution {\n            const int MOD = 1337;\n        \n            int pow(int x, int n) {\n                int res = 1;\n                while (n) {\n                    if (n % 2) {\n                        res = (long) res * x % MOD;\n                    }\n                    x = (long) x * x % MOD;\n                    n /= 2;\n                }\n                return res;\n            }\n        \n        public:\n            int superPow(int a, vector<int> &b) {\n                int ans = 1;\n                for (int i = b.size() - 1; i >= 0; --i) {\n                    ans = (long) ans * pow(a, b[i]) % MOD;\n                    a = pow(a, 10);\n                }\n                return ans;\n            }\n        };\n        ","\n        class Solution {\n            const int MOD = 1337;\n        \n            int pow(int x, int n) {\n                int res = 1;\n                while (n) {\n                    if (n % 2) {\n                        res = (long) res * x % MOD;\n                    }\n                    x = (long) x * x % MOD;\n                    n /= 2;\n                }\n                return res;\n            }\n        \n        public:\n            int superPow(int a, vector<int> &b) {\n                int ans = 1;\n                for (int e: b) {\n                    ans = (long) pow(ans, 10) * pow(a, e) % MOD;\n                }\n                return ans;\n            }\n        };\n        ","\n        class Solution \n{\npublic:\n    int MOD = 1337;\n\n    int quick_mul(int x, int n)\n    {\n        int res = 1;\n        while (n > 0)\n        {\n            if (n % 2 == 1)\n            {\n                res = (res * x) % MOD;\n            }\n            n >>= 1;\n            x = (x * x) % MOD;\n        }\n        return res;\n    }\n\n\n    int superPow(int a, vector<int>& b) \n    {\n        int bn = (int)b.size();\n\n        int res = 1;\n        int x = a % MOD;\n        for (int i = bn - 1; i > -1; i --)\n        {\n            int y = b[i];\n            res = (res * quick_mul(x, y)) % MOD;\n            x = quick_mul(x, 10);\n        }\n        return res;\n    }   \n};\n        "]
    },
    {
        "id":192,
        "description":"\n        You are given two integer arrays nums1 and nums2 sorted in non-decreasing order and an integer k.\n\nDefine a pair (u, v) which consists of one element from the first array and one element from the second array.\n\nReturn the k pairs (u1, v1), (u2, v2), ..., (uk, vk) with the smallest sums.\n\n \n\nExample 1:\n\nInput: nums1 = [1,7,11], nums2 = [2,4,6], k = 3\nOutput: [[1,2],[1,4],[1,6]]\nExplanation: The first 3 pairs are returned from the sequence: [1,2],[1,4],[1,6],[7,2],[7,4],[11,2],[7,6],[11,4],[11,6]\nExample 2:\n\nInput: nums1 = [1,1,2], nums2 = [1,2,3], k = 2\nOutput: [[1,1],[1,1]]\nExplanation: The first 2 pairs are returned from the sequence: [1,1],[1,1],[1,2],[2,1],[1,2],[2,2],[1,3],[1,3],[2,3]\nExample 3:\n\nInput: nums1 = [1,2], nums2 = [3], k = 3\nOutput: [[1,3],[2,3]]\nExplanation: All possible pairs are returned from the sequence: [1,3],[2,3]\n \n\nConstraints:\n\n1 <= nums1.length, nums2.length <= 10^5\n-10^9 <= nums1[i], nums2[i] <= 10^9\nnums1 and nums2 both are sorted in non-decreasing order.\n1 <= k <= 10^4\n        ",
        "tag":["Array","Heap (Priority Queue)"],
        "answer":["\n        class Solution {\n            public:\n                vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\n                    auto cmp = [&nums1, &nums2](const pair<int, int> & a, const pair<int, int> & b) {\n                        return nums1[a.first] + nums2[a.second] > nums1[b.first] + nums2[b.second];\n                    };\n            \n                    int m = nums1.size();\n                    int n = nums2.size();\n                    vector<vector<int>> ans;   \n                    priority_queue<pair<int, int>, vector<pair<int, int>>, decltype(cmp)> pq(cmp);\n                    for (int i = 0; i < min(k, m); i++) {\n                        pq.emplace(i, 0);\n                    }\n                    while (k-- > 0 && !pq.empty()) {\n                        auto [x, y] = pq.top(); \n                        pq.pop();\n                        ans.emplace_back(initializer_list<int>{nums1[x], nums2[y]});\n                        if (y + 1 < n) {\n                            pq.emplace(x, y + 1);\n                        }\n                    }\n            \n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\n                    int m = nums1.size();\n                    int n = nums2.size();\n                    auto count = [&](int target){\n                        long long cnt = 0;\n                        int start = 0;\n                        int end = n - 1;\n                        while (start < m && end >= 0) {\n                            if (nums1[start] + nums2[end] > target) {\n                                end--;\n                            } else {\n                                cnt += end + 1;\n                                start++;\n                            }\n                        }\n                        return cnt;\n                    };\n            \n                    /*二分查找第 k 小的数对和的大小*/\n                    int left = nums1[0] + nums2[0];\n                    int right = nums1.back() + nums2.back();\n                    int pairSum = right;\n                    while (left <= right) {\n                        int mid = left + ((right - left) >> 1);\n                        if (count(mid) < k) {\n                            left = mid + 1;\n                        } else {\n                            pairSum = mid;\n                            right = mid - 1;\n                        }\n                    }\n            \n                    vector<vector<int>> ans;\n                    int pos = n - 1;\n                    /*找到小于目标值 pairSum 的数对*/\n                    for (int i = 0; i < m; i++) {\n                        while (pos >= 0 && nums1[i] + nums2[pos] >= pairSum) {\n                            pos--;\n                        }\n                        for (int j = 0; j <= pos && k > 0; j++, k--) {\n                            ans.push_back({nums1[i], nums2[j]});\n                        }\n                    }\n                    /*找到等于目标值 pairSum 的数对*/\n                    pos = n - 1;\n                    for (int i = 0; i < m && k > 0; i++) {\n                        int start1 = i;\n                        while (i < m - 1 && nums1[i] == nums1[i + 1]) {\n                            i++;\n                        }\n                        while (pos >= 0 && nums1[i] + nums2[pos] > pairSum) {\n                            pos--;\n                        }\n                        int start2 = pos;\n                        while (pos > 0 && nums2[pos] == nums2[pos - 1]) {\n                            pos--;\n                        }\n                        if (nums1[i] + nums2[pos] != pairSum) {\n                            continue;\n                        }\n                        int count = (int) min((long) k, (long) (i - start1 + 1) * (start2 - pos + 1));\n                        for (int j = 0; j < count && k > 0; j++, k--) {\n                            ans.push_back({nums1[i], nums2[pos]});\n                        }\n                    }\n                    return ans;\n                }\n            \n                long min(long num1, long num2) {\n                    return num1 <= num2 ? num1 : num2;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool flag = true;\n                vector<vector<int>> kSmallestPairs(vector<int>& nums1, vector<int>& nums2, int k) {\n                    vector<vector<int>> ans;\n                    int n = nums1.size(), m = nums2.size();\n                    if(n > m) { //始终确保nums1为两数组中长度较少的那个\n                        swap(nums1, nums2);\n                        swap(m,n);\n                        flag = false;\n                    }\n                    //定义比较规则\n                    auto cmp = [&](const auto& a, const auto& b){\n                        return nums1[a.first] + nums2[a.second] > nums1[b.first] + nums2[b.second];\n                    };\n                    priority_queue< pair<int,int>, vector<pair<int,int>>, decltype(cmp) > q(cmp);\n                    for(int i = 0; i < min(n,k); i++){\n                        q.push( {i, 0} );\n                    }\n                    while(ans.size() < k and q.size()){\n                        auto [a,b] = q.top();\n                        q.pop();\n                        flag ? ans.push_back( {nums1[a], nums2[b]}) : ans.push_back( {nums2[b], nums1[a]});\n                        if(b + 1 < m) q.push( {a, b + 1} );\n                    }\n                    return ans;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                vector<int> nums1, nums2;\n                int n, m;\n                vector<vector<int>> kSmallestPairs(vector<int>& n1, vector<int>& n2, int k) {\n                    nums1 = n1;\n                    nums2 = n2;\n                    n = nums1.size(), m = nums2.size();\n                    vector<vector<int>> ans;\n                    int L = nums1[0] + nums2[0], R = nums1[n - 1] + nums2[m - 1];\n                    while(L < R){\n                        int mid = (0LL + L + R) >> 1;\n                        if(check(mid, k)) R = mid;\n                        else L = mid + 1;\n                    }\n                    int x = R;\n                    for(int i = 0; i < n; i++){\n                        for(int j = 0; j < m; j++){\n                            if(nums1[i] + nums2[j] < x){\n                                ans.push_back( {nums1[i], nums2[j]} );\n                            }\n                            else break;\n                        }\n                    }\n                    for(int i = 0; i < n and ans.size() < k; i++){\n                        int a = nums1[i], b = x - a;\n                        L = 0, R = m - 1;\n                        while(L < R){\n                            int mid = (0LL + L + R) >> 1;\n                            if(nums2[mid] >= b) R = mid;\n                            else L = mid + 1;\n                        }\n                        if(nums2[R] != b) continue;\n                        int c = R;\n                        L = 0, R = m - 1;\n                        while(L < R){\n                            int mid = (0LL + L + R + 1) >> 1;\n                            if(nums2[mid] <= b) L = mid;\n                            else R = mid - 1;\n                        }\n                        int d = R;\n                        for(int p = c; p <= d and ans.size() < k; p++){\n                            ans.push_back( {a, b} );\n                        }\n                    }\n                    return ans;\n                }\n                bool check(int x, int k){\n                    int ans = 0;\n                    for(int i = 0; i < n && ans < k; i++){\n                        for(int j = 0; j < m and ans < k; j++){\n                            if(nums1[i] + nums2[j] <= x) ans++;\n                            else break;\n                        }\n                    }\n                    return ans >= k;\n                }\n            };\n        "]
    },
    {
        "id":193,
        "description":"\n        We are playing the Guess Game. The game is as follows:\n\nI pick a number from 1 to n. You have to guess which number I picked.\n\nEvery time you guess wrong, I will tell you whether the number I picked is higher or lower than your guess.\n\nYou call a pre-defined API int guess(int num), which returns three possible results:\n\n-1: Your guess is higher than the number I picked (i.e. num > pick).\n1: Your guess is lower than the number I picked (i.e. num < pick).\n0: your guess is equal to the number I picked (i.e. num == pick).\nReturn the number that I picked.\n\n \n\nExample 1:\n\nInput: n = 10, pick = 6\nOutput: 6\nExample 2:\n\nInput: n = 1, pick = 1\nOutput: 1\nExample 3:\n\nInput: n = 2, pick = 1\nOutput: 1\n \n\nConstraints:\n\n1 <= n <= 2^31 - 1\n1 <= pick <= n\n        ",
        "tag":["Binary Search","Interactive"],
        "answer":["\n        class Solution {\n            public:\n                int guessNumber(int n) {\n                    int left = 1, right = n;\n                    while (left < right) { // 循环直至区间左右端点相同\n                        int mid = left + (right - left) / 2; // 防止计算时溢出\n                        if (guess(mid) <= 0) {\n                            right = mid; // 答案在区间 [left, mid] 中\n                        } else {\n                            left = mid + 1; // 答案在区间 [mid+1, right] 中\n                        }\n                    }\n                    // 此时有 left == right，区间缩为一个点，即为答案\n                    return left;\n                }\n            };\n        ","\nclass Solution {\npublic:\n    int guessNumber(int n) {\n        int left = 1,right=n;\n        while(left<right){\n            int mid = left+(right-left)/2;\n            if(guess(mid)<0){\n                right = mid-1;\n            }\n            else if(guess(mid)==0)\n                return mid;\n            else{\n                left = mid+1;\n            }\n        }\n        return left;\n    }\n};\n        ","\n        class Solution {\n            public:\n                int guessNumber(int n) {\n                    long long l = 0, r = n;\n                    while (l < r) {\n                        long long m = (l + r) / 2;\n                        // if (guess(m) == 0) return m;\n                        if (guess(m) == -1 || guess(m) == 0) r = m;\n                        else l = m + 1;\n                    }\n                    return (int)r;\n                }\n            };\n        "]
    },
    {
        "id":194,
        "description":"\n        A wiggle sequence is a sequence where the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with one element and a sequence with two non-equal elements are trivially wiggle sequences.\n\nFor example, [1, 7, 4, 9, 2, 5] is a wiggle sequence because the differences (6, -3, 5, -7, 3) alternate between positive and negative.\nIn contrast, [1, 4, 7, 2, 5] and [1, 7, 4, 5, 5] are not wiggle sequences. The first is not because its first two differences are positive, and the second is not because its last difference is zero.\nA subsequence is obtained by deleting some elements (possibly zero) from the original sequence, leaving the remaining elements in their original order.\n\nGiven an integer array nums, return the length of the longest wiggle subsequence of nums.\n\n \n\nExample 1:\n\nInput: nums = [1,7,4,9,2,5]\nOutput: 6\nExplanation: The entire sequence is a wiggle sequence with differences (6, -3, 5, -7, 3).\nExample 2:\n\nInput: nums = [1,17,5,10,13,15,10,5,16,8]\nOutput: 7\nExplanation: There are several subsequences that achieve this length.\nOne is [1, 17, 10, 13, 10, 16, 8] with differences (16, -7, 3, -3, 6, -8).\nExample 3:\n\nInput: nums = [1,2,3,4,5,6,7,8,9]\nOutput: 2\n \n\nConstraints:\n\n1 <= nums.length <= 1000\n0 <= nums[i] <= 1000\n        ",
        "tag":["Greedy","Array","Dynamic Programming"],
        "answer":["\n        class Solution {\n            public:\n                int wiggleMaxLength(vector<int>& nums) {\n                    int n = nums.size();\n                    if (n < 2) {\n                        return n;\n                    }\n                    vector<int> up(n), down(n);\n                    up[0] = down[0] = 1;\n                    for (int i = 1; i < n; i++) {\n                        if (nums[i] > nums[i - 1]) {\n                            up[i] = max(up[i - 1], down[i - 1] + 1);\n                            down[i] = down[i - 1];\n                        } else if (nums[i] < nums[i - 1]) {\n                            up[i] = up[i - 1];\n                            down[i] = max(up[i - 1] + 1, down[i - 1]);\n                        } else {\n                            up[i] = up[i - 1];\n                            down[i] = down[i - 1];\n                        }\n                    }\n                    return max(up[n - 1], down[n - 1]);\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int wiggleMaxLength(vector<int>& nums) {\n                    int n = nums.size();\n                    if (n < 2) {\n                        return n;\n                    }\n                    int up = 1, down = 1;\n                    for (int i = 1; i < n; i++) {\n                        if (nums[i] > nums[i - 1]) {\n                            up = max(up, down + 1);\n                        } else if (nums[i] < nums[i - 1]) {\n                            down = max(up + 1, down);\n                        }\n                    }\n                    return max(up, down);\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int wiggleMaxLength(vector<int>& nums) {\n                    int n = nums.size();\n                    if (n < 2) {\n                        return n;\n                    }\n                    int up = 1, down = 1;\n                    for (int i = 1; i < n; i++) {\n                        if (nums[i] > nums[i - 1]) {\n                            up = down + 1;\n                        } else if (nums[i] < nums[i - 1]) {\n                            down = up + 1;\n                        }\n                    }\n                    return max(up, down);\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int wiggleMaxLength(vector<int>& nums) {\n                    int n = nums.size();\n                    if (n < 2) {\n                        return n;\n                    }\n                    int prevdiff = nums[1] - nums[0];\n                    int ret = prevdiff != 0 ? 2 : 1;\n                    for (int i = 2; i < n; i++) {\n                        int diff = nums[i] - nums[i - 1];\n                        if ((diff > 0 && prevdiff <= 0) || (diff < 0 && prevdiff >= 0)) {\n                            ret++;\n                            prevdiff = diff;\n                        }\n                    }\n                    return ret;\n                }\n            };\n        "]
    },
    {
        "id":195,
        "description":"\n        Given an array of distinct integers nums and a target integer target, return the number of possible combinations that add up to target.\n\nThe test cases are generated so that the answer can fit in a 32-bit integer.\n\n \n\nExample 1:\n\nInput: nums = [1,2,3], target = 4\nOutput: 7\nExplanation:\nThe possible combination ways are:\n(1, 1, 1, 1)\n(1, 1, 2)\n(1, 2, 1)\n(1, 3)\n(2, 1, 1)\n(2, 2)\n(3, 1)\nNote that different sequences are counted as different combinations.\nExample 2:\n\nInput: nums = [9], target = 3\nOutput: 0\n \n\nConstraints:\n\n1 <= nums.length <= 200\n1 <= nums[i] <= 1000\nAll the elements of nums are unique.\n1 <= target <= 1000\n        ",
        "tag":["Array","Dynamic Programming"],
        "answer":["\n        class Solution {\n            public:\n                int combinationSum4(vector<int>& nums, int target) {\n                    vector<int> dp(target + 1);\n                    dp[0] = 1;\n                    for (int i = 1; i <= target; i++) {\n                        for (int& num : nums) {\n                            if (num <= i && dp[i - num] < INT_MAX - dp[i]) {\n                                dp[i] += dp[i - num];\n                            }\n                        }\n                    }\n                    return dp[target];\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int combinationSum4(vector<int>& nums, int target) {\n                    vector<int> dp(target + 1, 0);\n                    dp[0] = 1;\n                    for (int i = 1; i <= target; i++) {\n                        for (auto a : nums) {\n                            if (i >= a) {\n                                dp[i] += dp[i - a];\n                            } \n                        }\n                    }\n                    return dp.back();\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int combinationSum4(vector<int>& nums, int target) {\n                    int dp[1001] = {0};\n                    int n = nums.size();\n                    dp[0] = 1;\n            \n                    for(int j = 1; j <= target; j++) {\n                        for(int i = 1; i <= n; i++) {\n                            // 因为测试用例有有dp[j] + dp[j - nums[i - 1]]超过MAX_INT，因此要判定并且用减法式子判定\n                            if(nums[i - 1] <= j && dp[j] < INT_MAX - dp[j - nums[i - 1]]) {\n                                dp[j] += dp[j - nums[i - 1]];\n                            }\n                        }\n                    }\n            \n                    return dp[target];\n                }\n            };\n        "]
    },
    {
        "id":196,
        "description":"\n        Given an n x n matrix where each of the rows and columns is sorted in ascending order, return the k^th smallest element in the matrix.\n\nNote that it is the k^th smallest element in the sorted order, not the k^th distinct element.\n\nYou must find a solution with a memory complexity better than O(n^2).\n\n \n\nExample 1:\n\nInput: matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8\nOutput: 13\nExplanation: The elements in the matrix are [1,5,9,10,11,12,13,13,15], and the 8th smallest number is 13\nExample 2:\n\nInput: matrix = [[-5]], k = 1\nOutput: -5\n \n\nConstraints:\n\nn == matrix.length == matrix[i].length\n1 <= n <= 300\n-10^9 <= matrix[i][j] <= 10^9\nAll the rows and columns of matrix are guaranteed to be sorted in non-decreasing order.\n1 <= k <= n^2\n        ",
        "tag":["Array","Binary Search","Matrix","Sorting","Heap (Priority Queue)"],
        "answer":["\n        class Solution {\n            public:\n                int kthSmallest(vector<vector<int>>& matrix, int k) {\n                    vector<int> rec;\n                    for (auto& row : matrix) {\n                        for (int it : row) {\n                            rec.push_back(it);\n                        }\n                    }\n                    sort(rec.begin(), rec.end());\n                    return rec[k - 1];\n                }\n            };\n        ","\n        class Solution {\n            public:\n                int kthSmallest(vector<vector<int>>& matrix, int k) {\n                    struct point {\n                        int val, x, y;\n                        point(int val, int x, int y) : val(val), x(x), y(y) {}\n                        bool operator> (const point& a) const { return this->val > a.val; }\n                    };\n                    priority_queue<point, vector<point>, greater<point>> que;\n                    int n = matrix.size();\n                    for (int i = 0; i < n; i++) {\n                        que.emplace(matrix[i][0], i, 0);\n                    }\n                    for (int i = 0; i < k - 1; i++) {\n                        point now = que.top();\n                        que.pop();\n                        if (now.y != n - 1) {\n                            que.emplace(matrix[now.x][now.y + 1], now.x, now.y + 1);\n                        }\n                    }\n                    return que.top().val;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool check(vector<vector<int>>& matrix, int mid, int k, int n) {\n                    int i = n - 1;\n                    int j = 0;\n                    int num = 0;\n                    while (i >= 0 && j < n) {\n                        if (matrix[i][j] <= mid) {\n                            num += i + 1;\n                            j++;\n                        } else {\n                            i--;\n                        }\n                    }\n                    return num >= k;\n                }\n            \n                int kthSmallest(vector<vector<int>>& matrix, int k) {\n                    int n = matrix.size();\n                    int left = matrix[0][0];\n                    int right = matrix[n - 1][n - 1];\n                    while (left < right) {\n                        int mid = left + ((right - left) >> 1);\n                        if (check(matrix, mid, k, n)) {\n                            right = mid;\n                        } else {\n                            left = mid + 1;\n                        }\n                    }\n                    return left;\n                }\n            };\n        "]
    },
    {
        "id":197,
        "description":"\n        Implement the RandomizedSet class:\n\nRandomizedSet() Initializes the RandomizedSet object.\nbool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise.\nbool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise.\nint getRandom() Returns a random element from the current set of elements (it's guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned.\nYou must implement the functions of the class such that each function works in average O(1) time complexity.\n\n \n\nExample 1:\n\nInput\n[\"RandomizedSet\", \"insert\", \"remove\", \"insert\", \"getRandom\", \"remove\", \"insert\", \"getRandom\"]\n[[], [1], [2], [2], [], [1], [2], []]\nOutput\n[null, true, false, true, 2, true, false, 2]\n\nExplanation\nRandomizedSet randomizedSet = new RandomizedSet();\nrandomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully.\nrandomizedSet.remove(2); // Returns false as 2 does not exist in the set.\nrandomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2].\nrandomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly.\nrandomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2].\nrandomizedSet.insert(2); // 2 was already in the set, so return false.\nrandomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.\n \n\nConstraints:\n\n-2^31 <= val <= 2^31 - 1\nAt most 2 * 10^5 calls will be made to insert, remove, and getRandom.\nThere will be at least one element in the data structure when getRandom is called.\n        ",
        "tag":["Design","Array","Hash Table","Math","Randomized"],
        "answer":["\n        class RandomizedSet {\n            public:\n                RandomizedSet() {\n                    srand((unsigned)time(NULL));\n                }\n                \n                bool insert(int val) {\n                    if (indices.count(val)) {\n                        return false;\n                    }\n                    int index = nums.size();\n                    nums.emplace_back(val);\n                    indices[val] = index;\n                    return true;\n                }\n                \n                bool remove(int val) {\n                    if (!indices.count(val)) {\n                        return false;\n                    }\n                    int index = indices[val];\n                    int last = nums.back();\n                    nums[index] = last;\n                    indices[last] = index;\n                    nums.pop_back();\n                    indices.erase(val);\n                    return true;\n                }\n                \n                int getRandom() {\n                    int randomIndex = rand()%nums.size();\n                    return nums[randomIndex];\n                }\n            private:\n                vector<int> nums;\n                unordered_map<int, int> indices;\n            };\n        ","\n        class RandomizedSet {\n            public:\n                vector<int> nums;\n                unordered_map<int,int> indexMap;\n                RandomizedSet() {\n            \n                }\n                \n                bool insert(int val) {\n                    if(indexMap.count(val)){\n                        return false;\n                    }\n                    indexMap[val] = nums.size();\n                    nums.push_back(val);\n                    return true;\n                }\n                \n                bool remove(int val) {\n                    if(!indexMap.count(val)){\n                        return false;\n                    }\n                    int index = indexMap[val];\n                    indexMap[nums.back()]=index;\n                    swap(nums.back(),nums[index]);\n                    nums.pop_back();\n                    indexMap.erase(val);\n                    return true;\n                }\n                \n                int getRandom() {\n                    return nums[rand()%nums.size()];\n                }\n            };\n        ","\n        class RandomizedSet {\n            private:\n                unordered_map<int,int> hash;    //哈希表储存元素值和对应下标，为了remove时实现O（1）\n                vector<int> dyArray;        //vector可以作为动态数组，实现getRandom和insert的常数时间操作\n            \n            public:\n                /** Initialize your data structure here. */\n                RandomizedSet() {\n            \n                }\n                \n                /** Inserts a value to the set. Returns true if the set did not already contain the specified element. */\n                bool insert(int val) {\n                    auto it = hash.find(val);\n                    if(it != hash.end()) return false;  //如果集合中已经存在val，返回false，节省时间\n                    dyArray.push_back(val);\n                    hash[val] = dyArray.size() - 1;\n                    return true;\n                }\n                \n                /** Removes a value from the set. Returns true if the set contained the specified element. */\n                bool remove(int val) {\n                    auto it = hash.find(val);\n                    if(it == hash.end()) return false;  //删除时，如果集合中不存在val，返回false\n            \n                    int lastPos = dyArray.size() - 1;   //将被删除值和数组最后一位进行交换\n                    int valPos = hash[val];\n                    dyArray[valPos] = dyArray[lastPos];\n                    dyArray.pop_back();                 //vector数组删除val\n                    hash[dyArray[valPos]] = valPos;     //被交换的值下标发生变化，需要更新\n                    hash.erase(val);                    //哈希表中删除val的项\n                    return true;\n                }\n                \n                /** Get a random element from the set. */\n                int getRandom() {\n                    int size = dyArray.size();\n                    int pos = rand()%size;  //对下标产生随机数\n                    return dyArray[pos];\n                }\n            };\n        "]
    },
    {
        "id":198,
        "description":"\n        RandomizedCollection is a data structure that contains a collection of numbers, possibly duplicates (i.e., a multiset). It should support inserting and removing specific elements and also reporting a random element.\n\nImplement the RandomizedCollection class:\n\nRandomizedCollection() Initializes the empty RandomizedCollection object.\nbool insert(int val) Inserts an item val into the multiset, even if the item is already present. Returns true if the item is not present, false otherwise.\nbool remove(int val) Removes an item val from the multiset if present. Returns true if the item is present, false otherwise. Note that if val has multiple occurrences in the multiset, we only remove one of them.\nint getRandom() Returns a random element from the current multiset of elements. The probability of each element being returned is linearly related to the number of the same values the multiset contains.\nYou must implement the functions of the class such that each function works on average O(1) time complexity.\n\nNote: The test cases are generated such that getRandom will only be called if there is at least one item in the RandomizedCollection.\n\n \n\nExample 1:\n\nInput\n[\"RandomizedCollection\", \"insert\", \"insert\", \"insert\", \"getRandom\", \"remove\", \"getRandom\"]\n[[], [1], [1], [2], [], [1], []]\nOutput\n[null, true, false, true, 2, true, 1]\n\nExplanation\nRandomizedCollection randomizedCollection = new RandomizedCollection();\nrandomizedCollection.insert(1);   // return true since the collection does not contain 1.\n                                  // Inserts 1 into the collection.\nrandomizedCollection.insert(1);   // return false since the collection contains 1.\n                                  // Inserts another 1 into the collection. Collection now contains [1,1].\nrandomizedCollection.insert(2);   // return true since the collection does not contain 2.\n                                  // Inserts 2 into the collection. Collection now contains [1,1,2].\nrandomizedCollection.getRandom(); // getRandom should:\n                                  // - return 1 with probability 2/3, or\n                                  // - return 2 with probability 1/3.\nrandomizedCollection.remove(1);   // return true since the collection contains 1.\n                                  // Removes 1 from the collection. Collection now contains [1,2].\nrandomizedCollection.getRandom(); // getRandom should return 1 or 2, both equally likely.\n \n\nConstraints:\n\n-2^31 <= val <= 2^31 - 1\nAt most 2 * 10^5 calls in total will be made to insert, remove, and getRandom.\nThere will be at least one element in the data structure when getRandom is called.\n        ",
        "tag":["Design","Array","Hash Table","Math","Randomized"],
        "answer":["\n        class RandomizedCollection {\n            public:\n                unordered_map<int, unordered_set<int>> idx;\n                vector<int> nums;\n            \n                /** Initialize your data structure here. */\n                RandomizedCollection() {\n            \n                }\n                \n                /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\n                bool insert(int val) {\n                    nums.push_back(val);\n                    idx[val].insert(nums.size() - 1);\n                    return idx[val].size() == 1;\n                }\n                \n                /** Removes a value from the collection. Returns true if the collection contained the specified element. */\n                bool remove(int val) {\n                    if (idx.find(val) == idx.end()) {\n                        return false;\n                    }\n                    int i = *(idx[val].begin());\n                    nums[i] = nums.back();\n                    idx[val].erase(i);\n                    idx[nums[i]].erase(nums.size() - 1);\n                    if (i < nums.size() - 1) {\n                        idx[nums[i]].insert(i);\n                    }\n                    if (idx[val].size() == 0) {\n                        idx.erase(val);\n                    }\n                    nums.pop_back();\n                    return true;\n                }\n                \n                /** Get a random element from the collection. */\n                int getRandom() {\n                    return nums[rand() % nums.size()];\n                }\n            };\n        ","\n        class RandomizedCollection {\n            public:\n                mutable mt19937 _re;\n                unordered_multimap<int, int> _map;\n                vector<unordered_multimap<int, int>::iterator> _vec;\n            \n                /** Initialize your data structure here. */\n                RandomizedCollection() : _re(random_device()()) {}\n            \n                /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\n                bool insert(int val) {\n                    bool ret = _map.find(val) == _map.end();\n                    _vec.push_back(_map.insert({ val,_vec.size() }));\n                    return ret;\n                }\n            \n                /** Removes a value from the collection. Returns true if the collection contained the specified element. */\n                bool remove(int val) {\n                    const auto it = _map.find(val);\n                    if (it == _map.end()) return false;\n                    _vec.back()->second = it->second;\n                    _vec[it->second] = _vec.back();\n                    _vec.pop_back();\n                    _map.erase(it);\n                    return true;\n                }\n            \n                /** Get a random element from the collection. */\n                int getRandom() const {\n                    uniform_int_distribution<int> ud(0, _vec.size() - 1);\n                    //这条语句编译通过需要把mt19937成员_re标记为mutable\n                    //否则必须放弃getRandom()函数的const属性\n                    return _vec[ud(_re)]->first;\n                }\n            };\n        ","\n        class RandomizedCollection {\n            public:\n                unordered_map<int, unordered_set<int> > value_indices;\n                vector<int> nums;\n                /** Initialize your data structure here. */\n                RandomizedCollection() {\n                    \n                }\n                \n                /** Inserts a value to the collection. Returns true if the collection did not already contain the specified element. */\n                bool insert(int val) {\n                    bool res = value_indices.count(val) == 0;\n                    nums.push_back(val);\n                    value_indices[val].insert(nums.size() - 1);\n                    return res;\n                }\n                \n                /** Removes a value from the collection. Returns true if the collection contained the specified element. */\n                bool remove(int val) {\n                    if (value_indices.count(val) == 0) return false;\n                    int tail = nums.back();\n                    if (tail == val) {\n                        value_indices[val].erase(nums.size() - 1);\n                        nums.pop_back();\n                    } else {\n                        int ind = *value_indices[val].begin();\n                        nums[ind] = tail;\n                        value_indices[tail].erase(nums.size() - 1);\n                        value_indices[tail].insert(ind);\n                        value_indices[val].erase(ind);\n                        nums.pop_back();\n                    }\n                    if (value_indices[val].empty()) {\n                        value_indices.erase(val);\n                    }\n                    return true;\n                }\n                \n                /** Get a random element from the collection. */\n                int getRandom() {\n                    int s = nums.size();\n                    int r = rand() % s;\n                    return nums[r];\n                }\n            };\n        "]
    },
    {
        "id":199,
        "description":"\n        Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the letters from magazine and false otherwise.\n\nEach letter in magazine can only be used once in ransomNote.\n\n \n\nExample 1:\n\nInput: ransomNote = \"a\", magazine = \"b\"\nOutput: false\nExample 2:\n\nInput: ransomNote = \"aa\", magazine = \"ab\"\nOutput: false\nExample 3:\n\nInput: ransomNote = \"aa\", magazine = \"aab\"\nOutput: true\n \n\nConstraints:\n\n1 <= ransomNote.length, magazine.length <= 10^5\nransomNote and magazine consist of lowercase English letters.\n        ",
        "tag":["Hash Table","String","Counting"],
        "answer":["\n        class Solution {\n            public:\n                bool canConstruct(string ransomNote, string magazine) {\n                    if (ransomNote.size() > magazine.size()) {\n                        return false;\n                    }\n                    vector<int> cnt(26);\n                    for (auto & c : magazine) {\n                        cnt[c - 'a']++;\n                    }\n                    for (auto & c : ransomNote) {\n                        cnt[c - 'a']--;\n                        if (cnt[c - 'a'] < 0) {\n                            return false;\n                        }\n                    }\n                    return true;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool canConstruct(string ransomNote, string magazine) {\n                    int counts[26] = {0};   // 统计每个字符的次数\n                    for(auto ch: magazine){\n                        counts[ch - 'a']++;     // 统计magazine字符串中每种字符的个数\n                    }\n                    for(auto ch: ransomNote){\n                        if(counts[ch - 'a'] == 0)return false;   // 如果这个字符数量为0，无法匹配，直接返回\n                        counts[ch - 'a']--;     // 否则这个字符数量减一\n                    }\n                    return true;\n                }\n            };\n        ","\n        class Solution {\n            public:\n                bool canConstruct(string ransomNote, string magazine) {\n                    if(ransomNote.size() > magazine.size()) return false;\n                    vector<int> mag(26);\n                    for(char c : magazine){\n                        mag[c - 'a']++;\n                    }\n                    for(char c : ransomNote){\n                        if(mag[c - 'a'] == 0) return false;\n                        else mag[c - 'a']--;\n                    }\n                    return true;\n                }\n            };\n        "]
    },
    {
        "id":200,
        "description":"\n        Given an integer array nums, design an algorithm to randomly shuffle the array. All permutations of the array should be equally likely as a result of the shuffling.\n\nImplement the Solution class:\n\nSolution(int[] nums) Initializes the object with the integer array nums.\nint[] reset() Resets the array to its original configuration and returns it.\nint[] shuffle() Returns a random shuffling of the array.\n \n\nExample 1:\n\nInput\n[\"Solution\", \"shuffle\", \"reset\", \"shuffle\"]\n[[[1, 2, 3]], [], [], []]\nOutput\n[null, [3, 1, 2], [1, 2, 3], [1, 3, 2]]\n\nExplanation\nSolution solution = new Solution([1, 2, 3]);\nsolution.shuffle();    // Shuffle the array [1,2,3] and return its result.\n                       // Any permutation of [1,2,3] must be equally likely to be returned.\n                       // Example: return [3, 1, 2]\nsolution.reset();      // Resets the array back to its original configuration [1,2,3]. Return [1, 2, 3]\nsolution.shuffle();    // Returns the random shuffling of array [1,2,3]. Example: return [1, 3, 2]\n\n \n\nConstraints:\n\n1 <= nums.length <= 50\n-10^6 <= nums[i] <= 10^6\nAll the elements of nums are unique.\nAt most 10^4 calls in total will be made to reset and shuffle.\n        ",
        "tag":["Array","Math","Randomized"],
        "answer":["\n        class Solution {\n            public:\n                Solution(vector<int>& nums) {\n                    this->nums = nums;\n                    this->original.resize(nums.size());\n                    copy(nums.begin(), nums.end(), original.begin());\n                }\n                \n                vector<int> reset() {\n                    copy(original.begin(), original.end(), nums.begin());\n                    return nums;\n                }\n                \n                vector<int> shuffle() {\n                    vector<int> shuffled = vector<int>(nums.size());\n                    list<int> lst(nums.begin(), nums.end());\n                  \n                    for (int i = 0; i < nums.size(); ++i) {\n                        int j = rand()%(lst.size());\n                        auto it = lst.begin();\n                        advance(it, j);\n                        shuffled[i] = *it;\n                        lst.erase(it);\n                    }\n                    copy(shuffled.begin(), shuffled.end(), nums.begin());\n                    return nums;\n                }\n            private:\n                vector<int> nums;\n                vector<int> original;\n            };\n        ","\n        class Solution {\n            public:\n                Solution(vector<int>& nums) {\n                    this->nums = nums;\n                    this->original.resize(nums.size());\n                    copy(nums.begin(), nums.end(), original.begin());\n                }\n                \n                vector<int> reset() {\n                    copy(original.begin(), original.end(), nums.begin());\n                    return nums;\n                }\n                \n                vector<int> shuffle() {\n                    for (int i = 0; i < nums.size(); ++i) {\n                        int j = i + rand() % (nums.size() - i);\n                        swap(nums[i], nums[j]);\n                    }\n                    return nums;\n                }\n            private:\n                vector<int> nums;\n                vector<int> original;\n            };\n        ","\n        class Solution {\n            public:\n                vector<int> origin;\n                vector<int> current;\n                int n;\n            \n                Solution(vector<int>& nums) {\n                    origin = nums;\n                    current = nums;\n                    n = nums.size();\n                }\n                \n                vector<int> reset() {\n                    current = origin;\n                    return current;\n                }\n                \n                vector<int> shuffle() {\n                    for (int i = 0; i < n; i++) {\n                        int tmp;\n                        int target = i + rand() % (n - i);\n                        tmp = current[i];\n                        current[i] = current[target];\n                        current[target] = tmp;\n                    }\n                    return current;\n                }\n            };\n        "]
    }
]